directive @external on FIELD_DEFINITION

directive @key(fields: _FieldSet!) on INTERFACE | OBJECT

directive @provides(fields: _FieldSet!) on FIELD_DEFINITION

directive @requires(fields: _FieldSet!) on FIELD_DEFINITION

"""
An InTouch account
"""
type Account implements Node {
  """
  Reads and enables pagination through a set of `Note`.
  """
  authoredNotes(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: NoteCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: NoteFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Note`.
    """
    orderBy: [NotesOrderBy!] = [PRIMARY_KEY_ASC]
  ): NotesConnection!

  """
  Reads and enables pagination through a set of `Certification`.
  """
  certificationsByDoceboUserId(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CertificationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CertificationFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Certification`.
    """
    orderBy: [CertificationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CertificationsConnection!

  """
  Reads and enables pagination through a set of `CompanyMember`.
  """
  companyMembers(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CompanyMemberCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CompanyMemberFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `CompanyMember`.
    """
    orderBy: [CompanyMembersOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompanyMembersConnection!

  """
  When the account was created
  """
  created: Datetime
  createdAt: Datetime!

  """
  User account in Docebo
  """
  doceboUserId: Int

  """
  Username in Docebo.  Needed to generate the SSO link
  """
  doceboUsername: String

  """
  The email address associated with the account
  """
  email: String!

  """
  Reads and enables pagination through a set of `EvidenceItem`.
  """
  evidenceItemsByUploaderAccountId(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EvidenceItemCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EvidenceItemFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `EvidenceItem`.
    """
    orderBy: [EvidenceItemsOrderBy!] = [PRIMARY_KEY_ASC]
  ): EvidenceItemsConnection!

  """
  First name
  """
  firstName: String
  formattedRole: String

  """
  Reads and enables pagination through a set of `Guarantee`.
  """
  guaranteesByRequestorAccountId(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GuaranteeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: GuaranteeFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Guarantee`.
    """
    orderBy: [GuaranteesOrderBy!] = [PRIMARY_KEY_ASC]
  ): GuaranteesConnection!

  """
  Reads and enables pagination through a set of `Guarantee`.
  """
  guaranteesByReviewerAccountId(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GuaranteeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: GuaranteeFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Guarantee`.
    """
    orderBy: [GuaranteesOrderBy!] = [PRIMARY_KEY_ASC]
  ): GuaranteesConnection!

  """
  Primary key
  """
  id: Int!

  """
  Reads and enables pagination through a set of `Invitation`.
  """
  invitationsBySenderAccountId(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: InvitationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: InvitationFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Invitation`.
    """
    orderBy: [InvitationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): InvitationsConnection!

  """
  Last name
  """
  lastName: String

  """
  Reads a single `Market` that is related to this `Account`.
  """
  market: Market

  """
  fk
  """
  marketId: Int

  """
  Use to know if the user it is been migrated in Auth0 (the reset password mail it is been sent)
  """
  migratedToAuth0: Boolean

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Reads and enables pagination through a set of `Notification`.
  """
  notifications(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: NotificationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: NotificationFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Notification`.
    """
    orderBy: [NotificationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): NotificationsConnection!

  """
  A phone number that can optionally be provided, and is useful for Company Admin people to provide
  """
  phone: String

  """
  File reference. A profile picture of the user
  """
  photo: String

  """
  Reads and enables pagination through a set of `ProjectMember`.
  """
  projectMembers(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectMemberCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProjectMemberFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `ProjectMember`.
    """
    orderBy: [ProjectMembersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectMembersConnection!

  """
  ek
  """
  role: Role
  signedPhotoUrl: String

  """
  ek
  """
  status: AccountStatus
  updatedAt: Datetime!
}

"""
The fields on `account` to look up the row to connect.
"""
input AccountAccountDoceboUserIdKeyConnect {
  """
  User account in Docebo
  """
  doceboUserId: Int!
}

"""
The fields on `account` to look up the row to delete.
"""
input AccountAccountDoceboUserIdKeyDelete {
  """
  User account in Docebo
  """
  doceboUserId: Int!
}

"""
The fields on `account` to look up the row to connect.
"""
input AccountAccountEmailKeyConnect {
  """
  The email address associated with the account
  """
  email: String!
}

"""
The fields on `account` to look up the row to delete.
"""
input AccountAccountEmailKeyDelete {
  """
  The email address associated with the account
  """
  email: String!
}

"""
The fields on `account` to look up the row to connect.
"""
input AccountAccountPkeyConnect {
  """
  Primary key
  """
  id: Int!
}

"""
The fields on `account` to look up the row to delete.
"""
input AccountAccountPkeyDelete {
  """
  Primary key
  """
  id: Int!
}

"""
A condition to be used against `Account` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input AccountCondition {
  """
  Checks for equality with the object’s `doceboUserId` field.
  """
  doceboUserId: Int

  """
  Checks for equality with the object’s `email` field.
  """
  email: String

  """
  Checks for equality with the object’s `id` field.
  """
  id: Int

  """
  Checks for equality with the object’s `marketId` field.
  """
  marketId: Int
}

"""
A filter to be used against `Account` object types. All fields are combined with a logical ‘and.’
"""
input AccountFilter {
  """
  Checks for all expressions in this list.
  """
  and: [AccountFilter!]

  """
  Filter by the object’s `doceboUserId` field.
  """
  doceboUserId: IntFilter

  """
  Filter by the object’s `email` field.
  """
  email: StringFilter

  """
  Filter by the object’s `id` field.
  """
  id: IntFilter

  """
  Filter by the object’s `marketId` field.
  """
  marketId: IntFilter

  """
  Negates the expression.
  """
  not: AccountFilter

  """
  Checks for any expressions in this list.
  """
  or: [AccountFilter!]
}

"""
An input for mutations affecting `Account`
"""
input AccountInput {
  certificationsUsingDoceboUserId: CertificationDoceboUserIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberAccountIdFkeyInverseInput

  """
  When the account was created
  """
  created: Datetime
  createdAt: Datetime

  """
  User account in Docebo
  """
  doceboUserId: Int

  """
  Username in Docebo.  Needed to generate the SSO link
  """
  doceboUsername: String

  """
  The email address associated with the account
  """
  email: String!
  evidenceItemsUsingId: EvidenceItemUploaderAccountIdFkeyInverseInput

  """
  First name
  """
  firstName: String
  guaranteesToRequestorAccountIdUsingId: GuaranteeRequestorAccountIdFkeyInverseInput
  guaranteesToReviewerAccountIdUsingId: GuaranteeReviewerAccountIdFkeyInverseInput

  """
  Primary key
  """
  id: Int
  invitationsUsingId: InvitationSenderAccountIdFkeyInverseInput

  """
  Last name
  """
  lastName: String
  marketCode: String

  """
  fk
  """
  marketId: Int
  marketToMarketId: AccountMarketIdFkeyInput

  """
  Use to know if the user it is been migrated in Auth0 (the reset password mail it is been sent)
  """
  migratedToAuth0: Boolean

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String
  notesUsingId: NoteAuthorIdFkeyInverseInput
  notificationsUsingId: NotificationAccountIdFkeyInverseInput

  """
  A phone number that can optionally be provided, and is useful for Company Admin people to provide
  """
  phone: String

  """
  File reference. A profile picture of the user
  """
  photo: String
  projectMembersUsingId: ProjectMemberAccountIdFkeyInverseInput

  """
  ek
  """
  role: Role

  """
  ek
  """
  status: AccountStatus
  updatedAt: Datetime
}

"""
Input for the nested mutation of `market` in the `AccountInput` mutation.
"""
input AccountMarketIdFkeyInput {
  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectByDoceboCatalogueId: MarketMarketDoceboCatalogueIdKeyConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectByDomain: MarketMarketDomainKeyConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectById: MarketMarketPkeyConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectByNodeId: MarketNodeIdConnect

  """
  A `MarketInput` object that will be created and connected to this object.
  """
  create: AccountMarketIdFkeyMarketCreateInput

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteByDoceboCatalogueId: MarketMarketDoceboCatalogueIdKeyDelete

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteByDomain: MarketMarketDomainKeyDelete

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteById: MarketMarketPkeyDelete

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteByNodeId: MarketNodeIdDelete

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateByDoceboCatalogueId: MarketOnAccountForAccountMarketIdFkeyUsingMarketDoceboCatalogueIdKeyUpdate

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateByDomain: MarketOnAccountForAccountMarketIdFkeyUsingMarketDomainKeyUpdate

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateById: MarketOnAccountForAccountMarketIdFkeyUsingMarketPkeyUpdate

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateByNodeId: AccountOnAccountForAccountMarketIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `account` in the `MarketInput` mutation.
"""
input AccountMarketIdFkeyInverseInput {
  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByDoceboUserId: [AccountAccountDoceboUserIdKeyConnect!]

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByEmail: [AccountAccountEmailKeyConnect!]

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectById: [AccountAccountPkeyConnect!]

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByNodeId: [AccountNodeIdConnect!]

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByDoceboUserId: [AccountAccountDoceboUserIdKeyDelete!]

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByEmail: [AccountAccountEmailKeyDelete!]

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteById: [AccountAccountPkeyDelete!]

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByNodeId: [AccountNodeIdDelete!]

  """
  Flag indicating whether all other `account` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByDoceboUserId: [AccountOnAccountForAccountMarketIdFkeyUsingAccountDoceboUserIdKeyUpdate!]

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByEmail: [AccountOnAccountForAccountMarketIdFkeyUsingAccountEmailKeyUpdate!]

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateById: [AccountOnAccountForAccountMarketIdFkeyUsingAccountPkeyUpdate!]

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByNodeId: [MarketOnAccountForAccountMarketIdFkeyNodeIdUpdate!]
}

"""
The `market` to be created by this mutation.
"""
input AccountMarketIdFkeyMarketCreateInput {
  accountsUsingId: AccountMarketIdFkeyInverseInput

  """
  The space in Contenful
  """
  cmsSpaceId: String
  companiesUsingId: CompanyMarketIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberMarketIdFkeyInverseInput
  createdAt: Datetime

  """
  The default catalogue for the Market.  All users in the Market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int
  doceboCatalogueIdT2: Int
  doceboCatalogueIdT3: Int
  doceboCatalogueIdT4: Int

  """
  The Docebo branch that new user are inserted into if they register as a Company Admin. Note that this never gets updated by InTouch. Originally there was going to be a distinction between installer branches and admin branches in Docebo, but this is no longer the preferred approach.
  """
  doceboCompanyAdminBranchId: String

  """
  The Docebo branch that new user are inserted into if they register as an installer.  Note that this never gets updated by InTouch.  Originally there was going to be a distinction between installer branches and admin branches in Docebo, but this is no longer the preferred approach.
  """
  doceboInstallersBranchId: String

  """
  the country code used for example as the subdomain
  """
  domain: String!

  """
  The coordinates of the middle of the Market on a map
  """
  geoMiddle: PointInput

  """
  Reference to the Google Analytics tracking ID that is used for the Country GA reports
  """
  gtag: String
  gtagMarketMedia: String

  """
  Primary key
  """
  id: Int

  """
  ek
  """
  language: Language!

  """
  The length of the radius in km (from the geo_middle lat/lng), for which the Google Places API biases the search results for address autocomplete. Locations outside of the radius will not be excluded.
  """
  locationBiasRadiusKm: Int

  """
  The address of the merchandising site for the market.  CTAs of the MERCHANDISING type will link to this address
  """
  merchandisingUrl: String

  """
  A short name for the market, e.g. Italy, Norway, Netherlands
  """
  name: String
  productsUsingId: ProductMarketIdFkeyInverseInput

  """
  Whether the market supports Projects.  If so then the Projects link should be available in th left hand navigation.
  """
  projectsEnabled: Boolean

  """
  The mailbox on intouch.bmigroup.com that emails will be sent from for this Market
  """
  sendMailbox: String

  """
  The From name used when sending an email
  """
  sendName: String
  systemMembersUsingId: SystemMemberMarketIdFkeyInverseInput
  systemsUsingId: SystemMarketIdFkeyInverseInput
  updatedAt: Datetime
}

"""
The globally unique `ID` look up for the row to connect.
"""
input AccountNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `account` to be connected.
  """
  nodeId: ID!
}

"""
The globally unique `ID` look up for the row to delete.
"""
input AccountNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `account` to be deleted.
  """
  nodeId: ID!
}

"""
The globally unique `ID` look up for the row to update.
"""
input AccountOnAccountForAccountMarketIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `market` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: MarketPatch!
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnAccountForAccountMarketIdFkeyUsingAccountDoceboUserIdKeyUpdate {
  """
  User account in Docebo
  """
  doceboUserId: Int!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnAccountForAccountMarketIdFkeyPatch!
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnAccountForAccountMarketIdFkeyUsingAccountEmailKeyUpdate {
  """
  The email address associated with the account
  """
  email: String!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnAccountForAccountMarketIdFkeyPatch!
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnAccountForAccountMarketIdFkeyUsingAccountPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnAccountForAccountMarketIdFkeyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input AccountOnCertificationForCertificationDoceboUserIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `certification` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `certification` being updated.
  """
  patch: CertificationPatch!
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnCertificationForCertificationDoceboUserIdFkeyUsingAccountDoceboUserIdKeyUpdate {
  """
  User account in Docebo
  """
  doceboUserId: Int!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnCertificationForCertificationDoceboUserIdFkeyPatch!
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnCertificationForCertificationDoceboUserIdFkeyUsingAccountEmailKeyUpdate {
  """
  The email address associated with the account
  """
  email: String!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnCertificationForCertificationDoceboUserIdFkeyPatch!
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnCertificationForCertificationDoceboUserIdFkeyUsingAccountPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnCertificationForCertificationDoceboUserIdFkeyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input AccountOnCompanyMemberForCompanyMemberAccountIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `companyMember` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `companyMember` being updated.
  """
  patch: CompanyMemberPatch!
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnCompanyMemberForCompanyMemberAccountIdFkeyUsingAccountDoceboUserIdKeyUpdate {
  """
  User account in Docebo
  """
  doceboUserId: Int!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnCompanyMemberForCompanyMemberAccountIdFkeyPatch!
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnCompanyMemberForCompanyMemberAccountIdFkeyUsingAccountEmailKeyUpdate {
  """
  The email address associated with the account
  """
  email: String!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnCompanyMemberForCompanyMemberAccountIdFkeyPatch!
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnCompanyMemberForCompanyMemberAccountIdFkeyUsingAccountPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnCompanyMemberForCompanyMemberAccountIdFkeyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input AccountOnEvidenceItemForEvidenceItemUploaderAccountIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `evidenceItem` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `evidenceItem` being updated.
  """
  patch: EvidenceItemPatch!
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnEvidenceItemForEvidenceItemUploaderAccountIdFkeyUsingAccountDoceboUserIdKeyUpdate {
  """
  User account in Docebo
  """
  doceboUserId: Int!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnEvidenceItemForEvidenceItemUploaderAccountIdFkeyPatch!
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnEvidenceItemForEvidenceItemUploaderAccountIdFkeyUsingAccountEmailKeyUpdate {
  """
  The email address associated with the account
  """
  email: String!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnEvidenceItemForEvidenceItemUploaderAccountIdFkeyPatch!
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnEvidenceItemForEvidenceItemUploaderAccountIdFkeyUsingAccountPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnEvidenceItemForEvidenceItemUploaderAccountIdFkeyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input AccountOnGuaranteeForGuaranteeRequestorAccountIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `guarantee` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `guarantee` being updated.
  """
  patch: GuaranteePatch!
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnGuaranteeForGuaranteeRequestorAccountIdFkeyUsingAccountDoceboUserIdKeyUpdate {
  """
  User account in Docebo
  """
  doceboUserId: Int!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnGuaranteeForGuaranteeRequestorAccountIdFkeyPatch!
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnGuaranteeForGuaranteeRequestorAccountIdFkeyUsingAccountEmailKeyUpdate {
  """
  The email address associated with the account
  """
  email: String!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnGuaranteeForGuaranteeRequestorAccountIdFkeyPatch!
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnGuaranteeForGuaranteeRequestorAccountIdFkeyUsingAccountPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnGuaranteeForGuaranteeRequestorAccountIdFkeyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input AccountOnGuaranteeForGuaranteeReviewerAccountIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `guarantee` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `guarantee` being updated.
  """
  patch: GuaranteePatch!
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnGuaranteeForGuaranteeReviewerAccountIdFkeyUsingAccountDoceboUserIdKeyUpdate {
  """
  User account in Docebo
  """
  doceboUserId: Int!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnGuaranteeForGuaranteeReviewerAccountIdFkeyPatch!
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnGuaranteeForGuaranteeReviewerAccountIdFkeyUsingAccountEmailKeyUpdate {
  """
  The email address associated with the account
  """
  email: String!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnGuaranteeForGuaranteeReviewerAccountIdFkeyPatch!
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnGuaranteeForGuaranteeReviewerAccountIdFkeyUsingAccountPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnGuaranteeForGuaranteeReviewerAccountIdFkeyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input AccountOnInvitationForInvitationSenderAccountIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `invitation` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `invitation` being updated.
  """
  patch: InvitationPatch!
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnInvitationForInvitationSenderAccountIdFkeyUsingAccountDoceboUserIdKeyUpdate {
  """
  User account in Docebo
  """
  doceboUserId: Int!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnInvitationForInvitationSenderAccountIdFkeyPatch!
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnInvitationForInvitationSenderAccountIdFkeyUsingAccountEmailKeyUpdate {
  """
  The email address associated with the account
  """
  email: String!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnInvitationForInvitationSenderAccountIdFkeyPatch!
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnInvitationForInvitationSenderAccountIdFkeyUsingAccountPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnInvitationForInvitationSenderAccountIdFkeyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input AccountOnNoteForNoteAuthorIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `note` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `note` being updated.
  """
  patch: NotePatch!
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnNoteForNoteAuthorIdFkeyUsingAccountDoceboUserIdKeyUpdate {
  """
  User account in Docebo
  """
  doceboUserId: Int!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnNoteForNoteAuthorIdFkeyPatch!
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnNoteForNoteAuthorIdFkeyUsingAccountEmailKeyUpdate {
  """
  The email address associated with the account
  """
  email: String!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnNoteForNoteAuthorIdFkeyPatch!
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnNoteForNoteAuthorIdFkeyUsingAccountPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnNoteForNoteAuthorIdFkeyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input AccountOnNotificationForNotificationAccountIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `notification` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `notification` being updated.
  """
  patch: NotificationPatch!
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnNotificationForNotificationAccountIdFkeyUsingAccountDoceboUserIdKeyUpdate {
  """
  User account in Docebo
  """
  doceboUserId: Int!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnNotificationForNotificationAccountIdFkeyPatch!
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnNotificationForNotificationAccountIdFkeyUsingAccountEmailKeyUpdate {
  """
  The email address associated with the account
  """
  email: String!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnNotificationForNotificationAccountIdFkeyPatch!
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnNotificationForNotificationAccountIdFkeyUsingAccountPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnNotificationForNotificationAccountIdFkeyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input AccountOnProjectMemberForProjectMemberAccountIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `projectMember` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `projectMember` being updated.
  """
  patch: ProjectMemberPatch!
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnProjectMemberForProjectMemberAccountIdFkeyUsingAccountDoceboUserIdKeyUpdate {
  """
  User account in Docebo
  """
  doceboUserId: Int!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnProjectMemberForProjectMemberAccountIdFkeyPatch!
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnProjectMemberForProjectMemberAccountIdFkeyUsingAccountEmailKeyUpdate {
  """
  The email address associated with the account
  """
  email: String!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnProjectMemberForProjectMemberAccountIdFkeyPatch!
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnProjectMemberForProjectMemberAccountIdFkeyUsingAccountPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnProjectMemberForProjectMemberAccountIdFkeyPatch!
}

"""
Represents an update to a `Account`. Fields that are set will be updated.
"""
input AccountPatch {
  certificationsUsingDoceboUserId: CertificationDoceboUserIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberAccountIdFkeyInverseInput

  """
  When the account was created
  """
  created: Datetime
  createdAt: Datetime

  """
  User account in Docebo
  """
  doceboUserId: Int

  """
  Username in Docebo.  Needed to generate the SSO link
  """
  doceboUsername: String

  """
  The email address associated with the account
  """
  email: String
  evidenceItemsUsingId: EvidenceItemUploaderAccountIdFkeyInverseInput

  """
  First name
  """
  firstName: String
  guaranteesToRequestorAccountIdUsingId: GuaranteeRequestorAccountIdFkeyInverseInput
  guaranteesToReviewerAccountIdUsingId: GuaranteeReviewerAccountIdFkeyInverseInput

  """
  Primary key
  """
  id: Int
  invitationsUsingId: InvitationSenderAccountIdFkeyInverseInput

  """
  Last name
  """
  lastName: String

  """
  fk
  """
  marketId: Int
  marketToMarketId: AccountMarketIdFkeyInput

  """
  Use to know if the user it is been migrated in Auth0 (the reset password mail it is been sent)
  """
  migratedToAuth0: Boolean

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String
  notesUsingId: NoteAuthorIdFkeyInverseInput
  notificationsUsingId: NotificationAccountIdFkeyInverseInput

  """
  A phone number that can optionally be provided, and is useful for Company Admin people to provide
  """
  phone: String

  """
  File reference. A profile picture of the user
  """
  photo: String
  photoUpload: Upload
  projectMembersUsingId: ProjectMemberAccountIdFkeyInverseInput

  """
  ek
  """
  role: Role
  shouldRemovePhoto: Boolean

  """
  ek
  """
  status: AccountStatus
  termsCondition: Boolean
  updatedAt: Datetime
}

enum AccountStatus {
  ACTIVE
  NEW
  SUSPENDED
}

"""
A connection to a list of `Account` values.
"""
type AccountsConnection {
  """
  A list of edges which contains the `Account` and cursor to aid in pagination.
  """
  edges: [AccountsEdge!]!

  """
  A list of `Account` objects.
  """
  nodes: [Account!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Account` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `Account` edge in the connection.
"""
type AccountsEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Account` at the end of the edge.
  """
  node: Account!
}

"""
Methods to use when ordering `Account`.
"""
enum AccountsOrderBy {
  DOCEBO_USER_ID_ASC
  DOCEBO_USER_ID_DESC
  EMAIL_ASC
  EMAIL_DESC
  ID_ASC
  ID_DESC
  MARKET_ID_ASC
  MARKET_ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A generic address
"""
type Address implements Node {
  """
  Reads and enables pagination through a set of `Company`.
  """
  companiesByRegisteredAddressId(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CompanyCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CompanyFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Company`.
    """
    orderBy: [CompaniesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompaniesConnection!

  """
  Reads and enables pagination through a set of `Company`.
  """
  companiesByTradingAddressId(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CompanyCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CompanyFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Company`.
    """
    orderBy: [CompaniesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompaniesConnection!

  """
  The coordinates on a map of the world
  """
  coordinates: Point

  """
  The country for this address
  """
  country: String
  createdAt: Datetime!

  """
  First line of this address
  """
  firstLine: String

  """
  Primary key
  """
  id: Int!

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  The postcode for this address
  """
  postcode: String

  """
  Reads and enables pagination through a set of `Project`.
  """
  projectsByBuildingOwnerAddressId(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProjectFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Project`.
    """
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectsConnection!

  """
  Reads and enables pagination through a set of `Project`.
  """
  projectsBySiteAddressId(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProjectFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Project`.
    """
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectsConnection!

  """
  The region if relevant
  """
  region: String

  """
  Second line of this address
  """
  secondLine: String

  """
  The postal town
  """
  town: String
  updatedAt: Datetime!
}

"""
The fields on `address` to look up the row to connect.
"""
input AddressAddressPkeyConnect {
  """
  Primary key
  """
  id: Int!
}

"""
The fields on `address` to look up the row to delete.
"""
input AddressAddressPkeyDelete {
  """
  Primary key
  """
  id: Int!
}

"""
A condition to be used against `Address` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input AddressCondition {
  """
  Checks for equality with the object’s `id` field.
  """
  id: Int
}

"""
A filter to be used against `Address` object types. All fields are combined with a logical ‘and.’
"""
input AddressFilter {
  """
  Checks for all expressions in this list.
  """
  and: [AddressFilter!]

  """
  Filter by the object’s `id` field.
  """
  id: IntFilter

  """
  Negates the expression.
  """
  not: AddressFilter

  """
  Checks for any expressions in this list.
  """
  or: [AddressFilter!]
}

"""
An input for mutations affecting `Address`
"""
input AddressInput {
  companiesToRegisteredAddressIdUsingId: CompanyRegisteredAddressIdFkeyInverseInput
  companiesToTradingAddressIdUsingId: CompanyTradingAddressIdFkeyInverseInput

  """
  The coordinates on a map of the world
  """
  coordinates: PointInput

  """
  The country for this address
  """
  country: String
  createdAt: Datetime

  """
  First line of this address
  """
  firstLine: String

  """
  Primary key
  """
  id: Int

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String

  """
  The postcode for this address
  """
  postcode: String
  projectsToBuildingOwnerAddressIdUsingId: ProjectBuildingOwnerAddressIdFkeyInverseInput
  projectsToSiteAddressIdUsingId: ProjectSiteAddressIdFkeyInverseInput

  """
  The region if relevant
  """
  region: String

  """
  Second line of this address
  """
  secondLine: String

  """
  The postal town
  """
  town: String
  updatedAt: Datetime
}

"""
The globally unique `ID` look up for the row to connect.
"""
input AddressNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `address` to be connected.
  """
  nodeId: ID!
}

"""
The globally unique `ID` look up for the row to delete.
"""
input AddressNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `address` to be deleted.
  """
  nodeId: ID!
}

"""
The globally unique `ID` look up for the row to update.
"""
input AddressOnCompanyForCompanyRegisteredAddressIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `company` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: CompanyPatch!
}

"""
The fields on `address` to look up the row to update.
"""
input AddressOnCompanyForCompanyRegisteredAddressIdFkeyUsingAddressPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `address` being updated.
  """
  patch: updateAddressOnCompanyForCompanyRegisteredAddressIdFkeyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input AddressOnCompanyForCompanyTradingAddressIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `company` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: CompanyPatch!
}

"""
The fields on `address` to look up the row to update.
"""
input AddressOnCompanyForCompanyTradingAddressIdFkeyUsingAddressPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `address` being updated.
  """
  patch: updateAddressOnCompanyForCompanyTradingAddressIdFkeyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input AddressOnProjectForProjectBuildingOwnerAddressIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `project` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `project` being updated.
  """
  patch: ProjectPatch!
}

"""
The fields on `address` to look up the row to update.
"""
input AddressOnProjectForProjectBuildingOwnerAddressIdFkeyUsingAddressPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `address` being updated.
  """
  patch: updateAddressOnProjectForProjectBuildingOwnerAddressIdFkeyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input AddressOnProjectForProjectSiteAddressIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `project` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `project` being updated.
  """
  patch: ProjectPatch!
}

"""
The fields on `address` to look up the row to update.
"""
input AddressOnProjectForProjectSiteAddressIdFkeyUsingAddressPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `address` being updated.
  """
  patch: updateAddressOnProjectForProjectSiteAddressIdFkeyPatch!
}

"""
Represents an update to a `Address`. Fields that are set will be updated.
"""
input AddressPatch {
  companiesToRegisteredAddressIdUsingId: CompanyRegisteredAddressIdFkeyInverseInput
  companiesToTradingAddressIdUsingId: CompanyTradingAddressIdFkeyInverseInput

  """
  The coordinates on a map of the world
  """
  coordinates: PointInput

  """
  The country for this address
  """
  country: String
  createdAt: Datetime

  """
  First line of this address
  """
  firstLine: String

  """
  Primary key
  """
  id: Int

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String

  """
  The postcode for this address
  """
  postcode: String
  projectsToBuildingOwnerAddressIdUsingId: ProjectBuildingOwnerAddressIdFkeyInverseInput
  projectsToSiteAddressIdUsingId: ProjectSiteAddressIdFkeyInverseInput

  """
  The region if relevant
  """
  region: String

  """
  Second line of this address
  """
  secondLine: String

  """
  The postal town
  """
  town: String
  updatedAt: Datetime
}

"""
A connection to a list of `Address` values.
"""
type AddressesConnection {
  """
  A list of edges which contains the `Address` and cursor to aid in pagination.
  """
  edges: [AddressesEdge!]!

  """
  A list of `Address` objects.
  """
  nodes: [Address!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Address` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `Address` edge in the connection.
"""
type AddressesEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Address` at the end of the edge.
  """
  node: Address!
}

"""
Methods to use when ordering `Address`.
"""
enum AddressesOrderBy {
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
Represents a binary file in a space. An asset can be any file type.
"""
type Asset {
  contentType(locale: String): String
  contentfulMetadata: ContentfulMetadata!
  description(locale: String): String
  fileName(locale: String): String
  height(locale: String): Int
  linkedFrom(allowedLocales: [String]): AssetLinkingCollections
  size(locale: String): Int
  sys: Sys!
  title(locale: String): String
  url(locale: String, transform: ImageTransformOptions): String
  width(locale: String): Int
}

type AssetCollection {
  items: [Asset]!
  limit: Int!
  skip: Int!
  total: Int!
}

input AssetFilter {
  AND: [AssetFilter]
  OR: [AssetFilter]
  contentType: String
  contentType_contains: String
  contentType_exists: Boolean
  contentType_in: [String]
  contentType_not: String
  contentType_not_contains: String
  contentType_not_in: [String]
  contentfulMetadata: ContentfulMetadataFilter
  description: String
  description_contains: String
  description_exists: Boolean
  description_in: [String]
  description_not: String
  description_not_contains: String
  description_not_in: [String]
  fileName: String
  fileName_contains: String
  fileName_exists: Boolean
  fileName_in: [String]
  fileName_not: String
  fileName_not_contains: String
  fileName_not_in: [String]
  height: Int
  height_exists: Boolean
  height_gt: Int
  height_gte: Int
  height_in: [Int]
  height_lt: Int
  height_lte: Int
  height_not: Int
  height_not_in: [Int]
  size: Int
  size_exists: Boolean
  size_gt: Int
  size_gte: Int
  size_in: [Int]
  size_lt: Int
  size_lte: Int
  size_not: Int
  size_not_in: [Int]
  sys: SysFilter
  title: String
  title_contains: String
  title_exists: Boolean
  title_in: [String]
  title_not: String
  title_not_contains: String
  title_not_in: [String]
  url: String
  url_contains: String
  url_exists: Boolean
  url_in: [String]
  url_not: String
  url_not_contains: String
  url_not_in: [String]
  width: Int
  width_exists: Boolean
  width_gt: Int
  width_gte: Int
  width_in: [Int]
  width_lt: Int
  width_lte: Int
  width_not: Int
  width_not_in: [Int]
}

type AssetLinkingCollections {
  carouselItemCollection(
    limit: Int = 100
    locale: String
    preview: Boolean
    skip: Int = 0
  ): CarouselItemCollection
  entryCollection(
    limit: Int = 100
    locale: String
    preview: Boolean
    skip: Int = 0
  ): EntryCollection
  guaranteeTemplateCollection(
    limit: Int = 100
    locale: String
    preview: Boolean
    skip: Int = 0
  ): GuaranteeTemplateCollection
  guaranteeTypeCollection(
    limit: Int = 100
    locale: String
    preview: Boolean
    skip: Int = 0
  ): GuaranteeTypeCollection
  mediaToolCollection(
    limit: Int = 100
    locale: String
    preview: Boolean
    skip: Int = 0
  ): MediaToolCollection
  partnerBrandCollection(
    limit: Int = 100
    locale: String
    preview: Boolean
    skip: Int = 0
  ): PartnerBrandCollection
  trainingContentCollection(
    limit: Int = 100
    locale: String
    preview: Boolean
    skip: Int = 0
  ): TrainingContentCollection
}

enum AssetOrder {
  contentType_ASC
  contentType_DESC
  fileName_ASC
  fileName_DESC
  height_ASC
  height_DESC
  size_ASC
  size_DESC
  sys_firstPublishedAt_ASC
  sys_firstPublishedAt_DESC
  sys_id_ASC
  sys_id_DESC
  sys_publishedAt_ASC
  sys_publishedAt_DESC
  sys_publishedVersion_ASC
  sys_publishedVersion_DESC
  url_ASC
  url_DESC
  width_ASC
  width_DESC
}

type Auth0ImportResult {
  connection: String
  connection_id: String
  created_at: String
  id: String
  status: String
  type: String
}

"""
A signed eight-byte integer. The upper big integer values are greater than the
max value for a JavaScript number. Therefore all big integers will be output as
strings and not numbers.
"""
scalar BigInt

"""
A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’
"""
input BooleanFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Boolean

  """
  Equal to the specified value.
  """
  equalTo: Boolean

  """
  Greater than the specified value.
  """
  greaterThan: Boolean

  """
  Greater than or equal to the specified value.
  """
  greaterThanOrEqualTo: Boolean

  """
  Included in the specified list.
  """
  in: [Boolean!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """
  Less than the specified value.
  """
  lessThan: Boolean

  """
  Less than or equal to the specified value.
  """
  lessThanOrEqualTo: Boolean

  """
  Equal to the specified value, treating null like an ordinary value.
  """
  notDistinctFrom: Boolean

  """
  Not equal to the specified value.
  """
  notEqualTo: Boolean

  """
  Not included in the specified list.
  """
  notIn: [Boolean!]
}

input BulkImportInput {
  dryRun: Boolean
  files: [Upload!]!
}

enum BusinessType {
  ARCHITECT
  CONTRACTOR
  CORP_DEVELOPER
  MERCHANT
}

"""
Ordered list of items to be rendered as a carousel. [See type definition](https://app.contentful.com/spaces/j30snaps0u9c/content_types/carousel)
"""
type Carousel implements Entry {
  audienceRole(locale: String): String
  contentfulMetadata: ContentfulMetadata!
  linkedFrom(allowedLocales: [String]): CarouselLinkingCollections
  listCollection(
    limit: Int = 100
    locale: String
    preview: Boolean
    skip: Int = 0
  ): CarouselListCollection
  name(locale: String): String
  sys: Sys!
}

type CarouselCollection {
  items: [Carousel]!
  limit: Int!
  skip: Int!
  total: Int!
}

input CarouselFilter {
  AND: [CarouselFilter]
  OR: [CarouselFilter]
  audienceRole: String
  audienceRole_contains: String
  audienceRole_exists: Boolean
  audienceRole_in: [String]
  audienceRole_not: String
  audienceRole_not_contains: String
  audienceRole_not_in: [String]
  contentfulMetadata: ContentfulMetadataFilter
  listCollection_exists: Boolean
  name: String
  name_contains: String
  name_exists: Boolean
  name_in: [String]
  name_not: String
  name_not_contains: String
  name_not_in: [String]
  sys: SysFilter
}

"""
Content that appears in the main carousel.  Note that there are two other minor carousels in InTouch, the Benefits Carousel and the Company Administrators carousel (probably redundant).  This entity is for content you see in the big one which contains promotional messages that do not link anywhere. [See type definition](https://app.contentful.com/spaces/j30snaps0u9c/content_types/carouselItem)
"""
type CarouselItem implements Entry {
  audienceTiers(locale: String): [String]
  body(locale: String): String
  contentfulMetadata: ContentfulMetadata!
  cta(locale: String): String
  customUrl(locale: String): String
  customUrlButtonText(locale: String): String
  header(locale: String): String
  image(locale: String, preview: Boolean): Asset
  linkedFrom(allowedLocales: [String]): CarouselItemLinkingCollections
  sys: Sys!
}

type CarouselItemCollection {
  items: [CarouselItem]!
  limit: Int!
  skip: Int!
  total: Int!
}

input CarouselItemFilter {
  AND: [CarouselItemFilter]
  OR: [CarouselItemFilter]
  audienceTiers_contains_all: [String]
  audienceTiers_contains_none: [String]
  audienceTiers_contains_some: [String]
  audienceTiers_exists: Boolean
  body: String
  body_contains: String
  body_exists: Boolean
  body_in: [String]
  body_not: String
  body_not_contains: String
  body_not_in: [String]
  contentfulMetadata: ContentfulMetadataFilter
  cta: String
  cta_contains: String
  cta_exists: Boolean
  cta_in: [String]
  cta_not: String
  cta_not_contains: String
  cta_not_in: [String]
  customUrl: String
  customUrlButtonText: String
  customUrlButtonText_contains: String
  customUrlButtonText_exists: Boolean
  customUrlButtonText_in: [String]
  customUrlButtonText_not: String
  customUrlButtonText_not_contains: String
  customUrlButtonText_not_in: [String]
  customUrl_contains: String
  customUrl_exists: Boolean
  customUrl_in: [String]
  customUrl_not: String
  customUrl_not_contains: String
  customUrl_not_in: [String]
  header: String
  header_contains: String
  header_exists: Boolean
  header_in: [String]
  header_not: String
  header_not_contains: String
  header_not_in: [String]
  image_exists: Boolean
  sys: SysFilter
}

type CarouselItemLinkingCollections {
  carouselCollection(
    limit: Int = 100
    locale: String
    preview: Boolean
    skip: Int = 0
  ): CarouselCollection
  entryCollection(
    limit: Int = 100
    locale: String
    preview: Boolean
    skip: Int = 0
  ): EntryCollection
}

enum CarouselItemOrder {
  cta_ASC
  cta_DESC
  customUrlButtonText_ASC
  customUrlButtonText_DESC
  customUrl_ASC
  customUrl_DESC
  header_ASC
  header_DESC
  sys_firstPublishedAt_ASC
  sys_firstPublishedAt_DESC
  sys_id_ASC
  sys_id_DESC
  sys_publishedAt_ASC
  sys_publishedAt_DESC
  sys_publishedVersion_ASC
  sys_publishedVersion_DESC
}

type CarouselLinkingCollections {
  entryCollection(
    limit: Int = 100
    locale: String
    preview: Boolean
    skip: Int = 0
  ): EntryCollection
}

type CarouselListCollection {
  items: [CarouselItem]!
  limit: Int!
  skip: Int!
  total: Int!
}

enum CarouselOrder {
  audienceRole_ASC
  audienceRole_DESC
  name_ASC
  name_DESC
  sys_firstPublishedAt_ASC
  sys_firstPublishedAt_DESC
  sys_id_ASC
  sys_id_DESC
  sys_publishedAt_ASC
  sys_publishedAt_DESC
  sys_publishedVersion_ASC
  sys_publishedVersion_DESC
}

"""
A company that has been registered in InTouch
"""
type Certification implements Node {
  createdAt: Datetime!

  """
  Reads a single `Account` that is related to this `Certification`.
  """
  doceboUser: Account

  """
  fk
  """
  doceboUserId: Int

  """
  The last day that this certification is valid
  """
  expiryDate: Datetime

  """
  Primary key
  """
  id: Int!

  """
  The name of the certification according to Docebo
  """
  name: String

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  technology
  """
  technology: String
  updatedAt: Datetime!
}

"""
The fields on `certification` to look up the row to connect.
"""
input CertificationCertificationPkeyConnect {
  """
  Primary key
  """
  id: Int!
}

"""
The fields on `certification` to look up the row to delete.
"""
input CertificationCertificationPkeyDelete {
  """
  Primary key
  """
  id: Int!
}

"""
A condition to be used against `Certification` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input CertificationCondition {
  """
  Checks for equality with the object’s `doceboUserId` field.
  """
  doceboUserId: Int

  """
  Checks for equality with the object’s `expiryDate` field.
  """
  expiryDate: Datetime

  """
  Checks for equality with the object’s `id` field.
  """
  id: Int

  """
  Checks for equality with the object’s `technology` field.
  """
  technology: String
}

"""
The `certification` to be created by this mutation.
"""
input CertificationDoceboUserIdFkeyCertificationCreateInput {
  accountToDoceboUserId: CertificationDoceboUserIdFkeyInput
  createdAt: Datetime

  """
  The last day that this certification is valid
  """
  expiryDate: Datetime

  """
  Primary key
  """
  id: Int

  """
  The name of the certification according to Docebo
  """
  name: String

  """
  technology
  """
  technology: String
  updatedAt: Datetime
}

"""
Input for the nested mutation of `account` in the `CertificationInput` mutation.
"""
input CertificationDoceboUserIdFkeyInput {
  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByDoceboUserId: AccountAccountDoceboUserIdKeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByEmail: AccountAccountEmailKeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectById: AccountAccountPkeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByNodeId: AccountNodeIdConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByDoceboUserId: AccountAccountDoceboUserIdKeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByEmail: AccountAccountEmailKeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteById: AccountAccountPkeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByNodeId: AccountNodeIdDelete

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByDoceboUserId: AccountOnCertificationForCertificationDoceboUserIdFkeyUsingAccountDoceboUserIdKeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByEmail: AccountOnCertificationForCertificationDoceboUserIdFkeyUsingAccountEmailKeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateById: AccountOnCertificationForCertificationDoceboUserIdFkeyUsingAccountPkeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByNodeId: CertificationOnCertificationForCertificationDoceboUserIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `certification` in the `AccountInput` mutation.
"""
input CertificationDoceboUserIdFkeyInverseInput {
  """
  The primary key(s) for `certification` for the far side of the relationship.
  """
  connectById: [CertificationCertificationPkeyConnect!]

  """
  The primary key(s) for `certification` for the far side of the relationship.
  """
  connectByNodeId: [CertificationNodeIdConnect!]

  """
  A `CertificationInput` object that will be created and connected to this object.
  """
  create: [CertificationDoceboUserIdFkeyCertificationCreateInput!]

  """
  The primary key(s) for `certification` for the far side of the relationship.
  """
  deleteById: [CertificationCertificationPkeyDelete!]

  """
  The primary key(s) for `certification` for the far side of the relationship.
  """
  deleteByNodeId: [CertificationNodeIdDelete!]

  """
  Flag indicating whether all other `certification` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `certification` for the far side of the relationship.
  """
  updateById: [CertificationOnCertificationForCertificationDoceboUserIdFkeyUsingCertificationPkeyUpdate!]

  """
  The primary key(s) and patch data for `certification` for the far side of the relationship.
  """
  updateByNodeId: [AccountOnCertificationForCertificationDoceboUserIdFkeyNodeIdUpdate!]
}

"""
A filter to be used against `Certification` object types. All fields are combined with a logical ‘and.’
"""
input CertificationFilter {
  """
  Checks for all expressions in this list.
  """
  and: [CertificationFilter!]

  """
  Filter by the object’s `doceboUserId` field.
  """
  doceboUserId: IntFilter

  """
  Filter by the object’s `expiryDate` field.
  """
  expiryDate: DatetimeFilter

  """
  Filter by the object’s `id` field.
  """
  id: IntFilter

  """
  Negates the expression.
  """
  not: CertificationFilter

  """
  Checks for any expressions in this list.
  """
  or: [CertificationFilter!]

  """
  Filter by the object’s `technology` field.
  """
  technology: StringFilter
}

"""
An input for mutations affecting `Certification`
"""
input CertificationInput {
  accountToDoceboUserId: CertificationDoceboUserIdFkeyInput
  createdAt: Datetime

  """
  fk
  """
  doceboUserId: Int

  """
  The last day that this certification is valid
  """
  expiryDate: Datetime

  """
  Primary key
  """
  id: Int

  """
  The name of the certification according to Docebo
  """
  name: String

  """
  technology
  """
  technology: String
  updatedAt: Datetime
}

"""
The globally unique `ID` look up for the row to connect.
"""
input CertificationNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `certification` to be connected.
  """
  nodeId: ID!
}

"""
The globally unique `ID` look up for the row to delete.
"""
input CertificationNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `certification` to be deleted.
  """
  nodeId: ID!
}

"""
The globally unique `ID` look up for the row to update.
"""
input CertificationOnCertificationForCertificationDoceboUserIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `account` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: AccountPatch!
}

"""
The fields on `certification` to look up the row to update.
"""
input CertificationOnCertificationForCertificationDoceboUserIdFkeyUsingCertificationPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `certification` being updated.
  """
  patch: updateCertificationOnCertificationForCertificationDoceboUserIdFkeyPatch!
}

"""
Represents an update to a `Certification`. Fields that are set will be updated.
"""
input CertificationPatch {
  accountToDoceboUserId: CertificationDoceboUserIdFkeyInput
  createdAt: Datetime

  """
  fk
  """
  doceboUserId: Int

  """
  The last day that this certification is valid
  """
  expiryDate: Datetime

  """
  Primary key
  """
  id: Int

  """
  The name of the certification according to Docebo
  """
  name: String

  """
  technology
  """
  technology: String
  updatedAt: Datetime
}

"""
A connection to a list of `Certification` values.
"""
type CertificationsConnection {
  """
  A list of edges which contains the `Certification` and cursor to aid in pagination.
  """
  edges: [CertificationsEdge!]!

  """
  A list of `Certification` objects.
  """
  nodes: [Certification!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Certification` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `Certification` edge in the connection.
"""
type CertificationsEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Certification` at the end of the edge.
  """
  node: Certification!
}

"""
Methods to use when ordering `Certification`.
"""
enum CertificationsOrderBy {
  DOCEBO_USER_ID_ASC
  DOCEBO_USER_ID_DESC
  EXPIRY_DATE_ASC
  EXPIRY_DATE_DESC
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  TECHNOLOGY_ASC
  TECHNOLOGY_DESC
}

type CheckUserValidityPayload {
  success: String
}

"""
A connection to a list of `Company` values.
"""
type CompaniesConnection {
  """
  A list of edges which contains the `Company` and cursor to aid in pagination.
  """
  edges: [CompaniesEdge!]!

  """
  A list of `Company` objects.
  """
  nodes: [Company!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Company` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `Company` edge in the connection.
"""
type CompaniesEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Company` at the end of the edge.
  """
  node: Company!
}

"""
Methods to use when ordering `Company`.
"""
enum CompaniesOrderBy {
  ID_ASC
  ID_DESC
  MARKET_ID_ASC
  MARKET_ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  REFERENCE_NUMBER_ASC
  REFERENCE_NUMBER_DESC
  REGISTERED_ADDRESS_ID_ASC
  REGISTERED_ADDRESS_ID_DESC
  TRADING_ADDRESS_ID_ASC
  TRADING_ADDRESS_ID_DESC
}

"""
A company that has been registered in InTouch
"""
type Company implements Node {
  """
  A descirption of the Company intended for Find a Roofer
  """
  aboutUs: String

  """
  ek
  """
  businessType: BusinessType
  certifications: [Technology]!

  """
  Reads and enables pagination through a set of `CompanyDocument`.
  """
  companyDocuments(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CompanyDocumentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CompanyDocumentFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `CompanyDocument`.
    """
    orderBy: [CompanyDocumentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompanyDocumentsConnection!

  """
  Reads and enables pagination through a set of `CompanyMember`.
  """
  companyMembers(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CompanyMemberCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CompanyMemberFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `CompanyMember`.
    """
    orderBy: [CompanyMembersOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompanyMembersConnection!

  """
  Reads and enables pagination through a set of `CompanyOperation`.
  """
  companyOperationsByCompany(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CompanyOperationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CompanyOperationFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `CompanyOperation`.
    """
    orderBy: [CompanyOperationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompanyOperationsConnection!
  createdAt: Datetime!

  """
  The Company facebook website
  """
  facebook: String

  """
  Primary key
  """
  id: Int!

  """
  Reads and enables pagination through a set of `Invitation`.
  """
  invitations(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: InvitationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: InvitationFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Invitation`.
    """
    orderBy: [InvitationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): InvitationsConnection!
  isProfileComplete: Boolean!

  """
  Their Company LinkedIn page URL
  """
  linkedIn: String

  """
  A reference to the logo image
  """
  logo: String

  """
  Reads a single `Market` that is related to this `Company`.
  """
  market: Market

  """
  fk
  """
  marketId: Int

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String

  """
  The registered name of the Company
  """
  name: String

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  the email address to contact the owner
  """
  ownerEmail: String

  """
  the name of the owner of the Company
  """
  ownerFullname: String

  """
  the phone number to contact the owner
  """
  ownerPhone: String

  """
  The Company public phone number
  """
  phone: String

  """
  Reads and enables pagination through a set of `Project`.
  """
  projects(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProjectFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Project`.
    """
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectsConnection!

  """
  The email address that they can be contacted with by the public assuming they are listed
  """
  publicEmail: String

  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: Int!

  """
  Reads a single `Address` that is related to this `Company`.
  """
  registeredAddress: Address

  """
  fk
  """
  registeredAddressId: Int

  """
  Used for reference when importing data from the legacy system
  """
  registeredAddressMigrationId: String

  """
  the email address of the person who filled out the company registration form
  """
  registeredBy: String

  """
  the date that the Company registration form was submitted
  """
  registeredDate: Datetime

  """
  ek
  """
  status: CompanyStatus

  """
  The Tax number in that Market, such as the VAT number
  """
  taxNumber: String

  """
  ek
  """
  tier: Tier

  """
  Reads a single `Address` that is related to this `Company`.
  """
  tradingAddress: Address

  """
  fk
  """
  tradingAddressId: Int

  """
  Used for reference when importing data from the legacy system
  """
  tradingAddressMigrationId: String
  updatedAt: Datetime!

  """
  The Company website URL
  """
  website: String
}

"""
The fields on `company` to look up the row to connect.
"""
input CompanyCompanyMarketIdNameKeyConnect {
  """
  fk
  """
  marketId: Int!

  """
  The registered name of the Company
  """
  name: String!
}

"""
The fields on `company` to look up the row to delete.
"""
input CompanyCompanyMarketIdNameKeyDelete {
  """
  fk
  """
  marketId: Int!

  """
  The registered name of the Company
  """
  name: String!
}

"""
The fields on `company` to look up the row to connect.
"""
input CompanyCompanyPkeyConnect {
  """
  Primary key
  """
  id: Int!
}

"""
The fields on `company` to look up the row to delete.
"""
input CompanyCompanyPkeyDelete {
  """
  Primary key
  """
  id: Int!
}

"""
The fields on `company` to look up the row to connect.
"""
input CompanyCompanyReferenceNumberKeyConnect {
  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: Int!
}

"""
The fields on `company` to look up the row to delete.
"""
input CompanyCompanyReferenceNumberKeyDelete {
  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: Int!
}

"""
A condition to be used against `Company` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input CompanyCondition {
  """
  Checks for equality with the object’s `id` field.
  """
  id: Int

  """
  Checks for equality with the object’s `marketId` field.
  """
  marketId: Int

  """
  Checks for equality with the object’s `referenceNumber` field.
  """
  referenceNumber: Int

  """
  Checks for equality with the object’s `registeredAddressId` field.
  """
  registeredAddressId: Int

  """
  Checks for equality with the object’s `tradingAddressId` field.
  """
  tradingAddressId: Int
}

"""
A document uploaded by the Company to InTouch that appears on their Company Profile, for example an insurance certificate
"""
type CompanyDocument implements Node {
  """
  Reads a single `Company` that is related to this `CompanyDocument`.
  """
  company: Company

  """
  fk
  """
  companyId: Int
  createdAt: Datetime!

  """
  The reference to the document
  """
  document: String
  documentType: CompanyDocumentType

  """
  Primary key
  """
  id: Int!
  name: String

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  signedDocumentUrl: String
  size: Int
  updatedAt: Datetime!
}

"""
The fields on `companyDocument` to look up the row to connect.
"""
input CompanyDocumentCompanyDocumentPkeyConnect {
  """
  Primary key
  """
  id: Int!
}

"""
The fields on `companyDocument` to look up the row to delete.
"""
input CompanyDocumentCompanyDocumentPkeyDelete {
  """
  Primary key
  """
  id: Int!
}

"""
The `companyDocument` to be created by this mutation.
"""
input CompanyDocumentCompanyIdFkeyCompanyDocumentCreateInput {
  attachmentUpload: Upload
  companyToCompanyId: CompanyDocumentCompanyIdFkeyInput
  createdAt: Datetime

  """
  The reference to the document
  """
  document: String

  """
  Primary key
  """
  id: Int
  updatedAt: Datetime
}

"""
Input for the nested mutation of `company` in the `CompanyDocumentInput` mutation.
"""
input CompanyDocumentCompanyIdFkeyInput {
  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectById: CompanyCompanyPkeyConnect

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByMarketIdAndName: CompanyCompanyMarketIdNameKeyConnect

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByNodeId: CompanyNodeIdConnect

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByReferenceNumber: CompanyCompanyReferenceNumberKeyConnect

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteById: CompanyCompanyPkeyDelete

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByMarketIdAndName: CompanyCompanyMarketIdNameKeyDelete

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByNodeId: CompanyNodeIdDelete

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByReferenceNumber: CompanyCompanyReferenceNumberKeyDelete

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateById: CompanyOnCompanyDocumentForCompanyDocumentCompanyIdFkeyUsingCompanyPkeyUpdate

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByMarketIdAndName: CompanyOnCompanyDocumentForCompanyDocumentCompanyIdFkeyUsingCompanyMarketIdNameKeyUpdate

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByNodeId: CompanyDocumentOnCompanyDocumentForCompanyDocumentCompanyIdFkeyNodeIdUpdate

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByReferenceNumber: CompanyOnCompanyDocumentForCompanyDocumentCompanyIdFkeyUsingCompanyReferenceNumberKeyUpdate
}

"""
Input for the nested mutation of `companyDocument` in the `CompanyInput` mutation.
"""
input CompanyDocumentCompanyIdFkeyInverseInput {
  """
  The primary key(s) for `companyDocument` for the far side of the relationship.
  """
  connectById: [CompanyDocumentCompanyDocumentPkeyConnect!]

  """
  The primary key(s) for `companyDocument` for the far side of the relationship.
  """
  connectByNodeId: [CompanyDocumentNodeIdConnect!]

  """
  A `CompanyDocumentInput` object that will be created and connected to this object.
  """
  create: [CompanyDocumentCompanyIdFkeyCompanyDocumentCreateInput!]

  """
  The primary key(s) for `companyDocument` for the far side of the relationship.
  """
  deleteById: [CompanyDocumentCompanyDocumentPkeyDelete!]

  """
  The primary key(s) for `companyDocument` for the far side of the relationship.
  """
  deleteByNodeId: [CompanyDocumentNodeIdDelete!]

  """
  Flag indicating whether all other `companyDocument` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `companyDocument` for the far side of the relationship.
  """
  updateById: [CompanyDocumentOnCompanyDocumentForCompanyDocumentCompanyIdFkeyUsingCompanyDocumentPkeyUpdate!]

  """
  The primary key(s) and patch data for `companyDocument` for the far side of the relationship.
  """
  updateByNodeId: [CompanyOnCompanyDocumentForCompanyDocumentCompanyIdFkeyNodeIdUpdate!]
}

"""
A condition to be used against `CompanyDocument` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input CompanyDocumentCondition {
  """
  Checks for equality with the object’s `companyId` field.
  """
  companyId: Int

  """
  Checks for equality with the object’s `id` field.
  """
  id: Int
}

"""
A filter to be used against `CompanyDocument` object types. All fields are combined with a logical ‘and.’
"""
input CompanyDocumentFilter {
  """
  Checks for all expressions in this list.
  """
  and: [CompanyDocumentFilter!]

  """
  Filter by the object’s `companyId` field.
  """
  companyId: IntFilter

  """
  Filter by the object’s `id` field.
  """
  id: IntFilter

  """
  Negates the expression.
  """
  not: CompanyDocumentFilter

  """
  Checks for any expressions in this list.
  """
  or: [CompanyDocumentFilter!]
}

"""
An input for mutations affecting `CompanyDocument`
"""
input CompanyDocumentInput {
  attachmentUpload: Upload

  """
  fk
  """
  companyId: Int
  companyToCompanyId: CompanyDocumentCompanyIdFkeyInput
  createdAt: Datetime

  """
  The reference to the document
  """
  document: String

  """
  Primary key
  """
  id: Int
  updatedAt: Datetime
}

"""
The globally unique `ID` look up for the row to connect.
"""
input CompanyDocumentNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `companyDocument` to be connected.
  """
  nodeId: ID!
}

"""
The globally unique `ID` look up for the row to delete.
"""
input CompanyDocumentNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `companyDocument` to be deleted.
  """
  nodeId: ID!
}

"""
The globally unique `ID` look up for the row to update.
"""
input CompanyDocumentOnCompanyDocumentForCompanyDocumentCompanyIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `company` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: CompanyPatch!
}

"""
The fields on `companyDocument` to look up the row to update.
"""
input CompanyDocumentOnCompanyDocumentForCompanyDocumentCompanyIdFkeyUsingCompanyDocumentPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `companyDocument` being updated.
  """
  patch: updateCompanyDocumentOnCompanyDocumentForCompanyDocumentCompanyIdFkeyPatch!
}

"""
Represents an update to a `CompanyDocument`. Fields that are set will be updated.
"""
input CompanyDocumentPatch {
  """
  fk
  """
  companyId: Int
  companyToCompanyId: CompanyDocumentCompanyIdFkeyInput
  createdAt: Datetime

  """
  The reference to the document
  """
  document: String

  """
  Primary key
  """
  id: Int
  updatedAt: Datetime
}

enum CompanyDocumentType {
  JPEG
  JPG
  PDF
  PNG
}

"""
A connection to a list of `CompanyDocument` values.
"""
type CompanyDocumentsConnection {
  """
  A list of edges which contains the `CompanyDocument` and cursor to aid in pagination.
  """
  edges: [CompanyDocumentsEdge!]!

  """
  A list of `CompanyDocument` objects.
  """
  nodes: [CompanyDocument!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `CompanyDocument` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `CompanyDocument` edge in the connection.
"""
type CompanyDocumentsEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `CompanyDocument` at the end of the edge.
  """
  node: CompanyDocument!
}

"""
Methods to use when ordering `CompanyDocument`.
"""
enum CompanyDocumentsOrderBy {
  COMPANY_ID_ASC
  COMPANY_ID_DESC
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A filter to be used against `Company` object types. All fields are combined with a logical ‘and.’
"""
input CompanyFilter {
  """
  Checks for all expressions in this list.
  """
  and: [CompanyFilter!]

  """
  Filter by the object’s `id` field.
  """
  id: IntFilter

  """
  Filter by the object’s `marketId` field.
  """
  marketId: IntFilter

  """
  Negates the expression.
  """
  not: CompanyFilter

  """
  Checks for any expressions in this list.
  """
  or: [CompanyFilter!]

  """
  Filter by the object’s `referenceNumber` field.
  """
  referenceNumber: IntFilter

  """
  Filter by the object’s `registeredAddressId` field.
  """
  registeredAddressId: IntFilter

  """
  Filter by the object’s `tradingAddressId` field.
  """
  tradingAddressId: IntFilter
}

"""
Input for the nested mutation of `market` in the `CompanyInput` mutation.
"""
input CompanyMarketIdFkeyInput {
  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectByDoceboCatalogueId: MarketMarketDoceboCatalogueIdKeyConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectByDomain: MarketMarketDomainKeyConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectById: MarketMarketPkeyConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectByNodeId: MarketNodeIdConnect

  """
  A `MarketInput` object that will be created and connected to this object.
  """
  create: CompanyMarketIdFkeyMarketCreateInput

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteByDoceboCatalogueId: MarketMarketDoceboCatalogueIdKeyDelete

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteByDomain: MarketMarketDomainKeyDelete

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteById: MarketMarketPkeyDelete

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteByNodeId: MarketNodeIdDelete

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateByDoceboCatalogueId: MarketOnCompanyForCompanyMarketIdFkeyUsingMarketDoceboCatalogueIdKeyUpdate

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateByDomain: MarketOnCompanyForCompanyMarketIdFkeyUsingMarketDomainKeyUpdate

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateById: MarketOnCompanyForCompanyMarketIdFkeyUsingMarketPkeyUpdate

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateByNodeId: CompanyOnCompanyForCompanyMarketIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `company` in the `MarketInput` mutation.
"""
input CompanyMarketIdFkeyInverseInput {
  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectById: [CompanyCompanyPkeyConnect!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByMarketIdAndName: [CompanyCompanyMarketIdNameKeyConnect!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByNodeId: [CompanyNodeIdConnect!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByReferenceNumber: [CompanyCompanyReferenceNumberKeyConnect!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteById: [CompanyCompanyPkeyDelete!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByMarketIdAndName: [CompanyCompanyMarketIdNameKeyDelete!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByNodeId: [CompanyNodeIdDelete!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByReferenceNumber: [CompanyCompanyReferenceNumberKeyDelete!]

  """
  Flag indicating whether all other `company` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateById: [CompanyOnCompanyForCompanyMarketIdFkeyUsingCompanyPkeyUpdate!]

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByMarketIdAndName: [CompanyOnCompanyForCompanyMarketIdFkeyUsingCompanyMarketIdNameKeyUpdate!]

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByNodeId: [MarketOnCompanyForCompanyMarketIdFkeyNodeIdUpdate!]

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByReferenceNumber: [CompanyOnCompanyForCompanyMarketIdFkeyUsingCompanyReferenceNumberKeyUpdate!]
}

"""
The `market` to be created by this mutation.
"""
input CompanyMarketIdFkeyMarketCreateInput {
  accountsUsingId: AccountMarketIdFkeyInverseInput

  """
  The space in Contenful
  """
  cmsSpaceId: String
  companiesUsingId: CompanyMarketIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberMarketIdFkeyInverseInput
  createdAt: Datetime

  """
  The default catalogue for the Market.  All users in the Market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int
  doceboCatalogueIdT2: Int
  doceboCatalogueIdT3: Int
  doceboCatalogueIdT4: Int

  """
  The Docebo branch that new user are inserted into if they register as a Company Admin. Note that this never gets updated by InTouch. Originally there was going to be a distinction between installer branches and admin branches in Docebo, but this is no longer the preferred approach.
  """
  doceboCompanyAdminBranchId: String

  """
  The Docebo branch that new user are inserted into if they register as an installer.  Note that this never gets updated by InTouch.  Originally there was going to be a distinction between installer branches and admin branches in Docebo, but this is no longer the preferred approach.
  """
  doceboInstallersBranchId: String

  """
  the country code used for example as the subdomain
  """
  domain: String!

  """
  The coordinates of the middle of the Market on a map
  """
  geoMiddle: PointInput

  """
  Reference to the Google Analytics tracking ID that is used for the Country GA reports
  """
  gtag: String
  gtagMarketMedia: String

  """
  Primary key
  """
  id: Int

  """
  ek
  """
  language: Language!

  """
  The length of the radius in km (from the geo_middle lat/lng), for which the Google Places API biases the search results for address autocomplete. Locations outside of the radius will not be excluded.
  """
  locationBiasRadiusKm: Int

  """
  The address of the merchandising site for the market.  CTAs of the MERCHANDISING type will link to this address
  """
  merchandisingUrl: String

  """
  A short name for the market, e.g. Italy, Norway, Netherlands
  """
  name: String
  productsUsingId: ProductMarketIdFkeyInverseInput

  """
  Whether the market supports Projects.  If so then the Projects link should be available in th left hand navigation.
  """
  projectsEnabled: Boolean

  """
  The mailbox on intouch.bmigroup.com that emails will be sent from for this Market
  """
  sendMailbox: String

  """
  The From name used when sending an email
  """
  sendName: String
  systemMembersUsingId: SystemMemberMarketIdFkeyInverseInput
  systemsUsingId: SystemMarketIdFkeyInverseInput
  updatedAt: Datetime
}

"""
A connection between a user and a company
"""
type CompanyMember implements Node {
  """
  Reads a single `Account` that is related to this `CompanyMember`.
  """
  account: Account

  """
  fk
  """
  accountId: Int!

  """
  Reads a single `Company` that is related to this `CompanyMember`.
  """
  company: Company

  """
  fk
  """
  companyId: Int!
  createdAt: Datetime!

  """
  Primary key
  """
  id: Int!

  """
  Reads a single `Market` that is related to this `CompanyMember`.
  """
  market: Market

  """
  fk
  """
  marketId: Int!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  updatedAt: Datetime!
}

"""
The `companyMember` to be created by this mutation.
"""
input CompanyMemberAccountIdFkeyCompanyMemberCreateInput {
  accountToAccountId: CompanyMemberAccountIdFkeyInput

  """
  fk
  """
  companyId: Int
  companyToCompanyId: CompanyMemberCompanyIdFkeyInput
  createdAt: Datetime

  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int
  marketToMarketId: CompanyMemberMarketIdFkeyInput
  updatedAt: Datetime
}

"""
Input for the nested mutation of `account` in the `CompanyMemberInput` mutation.
"""
input CompanyMemberAccountIdFkeyInput {
  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByDoceboUserId: AccountAccountDoceboUserIdKeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByEmail: AccountAccountEmailKeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectById: AccountAccountPkeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByNodeId: AccountNodeIdConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByDoceboUserId: AccountAccountDoceboUserIdKeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByEmail: AccountAccountEmailKeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteById: AccountAccountPkeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByNodeId: AccountNodeIdDelete

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByDoceboUserId: AccountOnCompanyMemberForCompanyMemberAccountIdFkeyUsingAccountDoceboUserIdKeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByEmail: AccountOnCompanyMemberForCompanyMemberAccountIdFkeyUsingAccountEmailKeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateById: AccountOnCompanyMemberForCompanyMemberAccountIdFkeyUsingAccountPkeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByNodeId: CompanyMemberOnCompanyMemberForCompanyMemberAccountIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `companyMember` in the `AccountInput` mutation.
"""
input CompanyMemberAccountIdFkeyInverseInput {
  """
  The primary key(s) for `companyMember` for the far side of the relationship.
  """
  connectById: [CompanyMemberCompanyMemberPkeyConnect!]

  """
  The primary key(s) for `companyMember` for the far side of the relationship.
  """
  connectByMarketIdAndAccountIdAndCompanyId: [CompanyMemberCompanyMemberMarketIdAccountIdCompanyIdKeyConnect!]

  """
  The primary key(s) for `companyMember` for the far side of the relationship.
  """
  connectByNodeId: [CompanyMemberNodeIdConnect!]

  """
  A `CompanyMemberInput` object that will be created and connected to this object.
  """
  create: [CompanyMemberAccountIdFkeyCompanyMemberCreateInput!]

  """
  The primary key(s) for `companyMember` for the far side of the relationship.
  """
  deleteById: [CompanyMemberCompanyMemberPkeyDelete!]

  """
  The primary key(s) for `companyMember` for the far side of the relationship.
  """
  deleteByMarketIdAndAccountIdAndCompanyId: [CompanyMemberCompanyMemberMarketIdAccountIdCompanyIdKeyDelete!]

  """
  The primary key(s) for `companyMember` for the far side of the relationship.
  """
  deleteByNodeId: [CompanyMemberNodeIdDelete!]

  """
  Flag indicating whether all other `companyMember` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `companyMember` for the far side of the relationship.
  """
  updateById: [CompanyMemberOnCompanyMemberForCompanyMemberAccountIdFkeyUsingCompanyMemberPkeyUpdate!]

  """
  The primary key(s) and patch data for `companyMember` for the far side of the relationship.
  """
  updateByMarketIdAndAccountIdAndCompanyId: [CompanyMemberOnCompanyMemberForCompanyMemberAccountIdFkeyUsingCompanyMemberMarketIdAccountIdCompanyIdKeyUpdate!]

  """
  The primary key(s) and patch data for `companyMember` for the far side of the relationship.
  """
  updateByNodeId: [AccountOnCompanyMemberForCompanyMemberAccountIdFkeyNodeIdUpdate!]
}

"""
The `companyMember` to be created by this mutation.
"""
input CompanyMemberCompanyIdFkeyCompanyMemberCreateInput {
  """
  fk
  """
  accountId: Int
  accountToAccountId: CompanyMemberAccountIdFkeyInput
  companyToCompanyId: CompanyMemberCompanyIdFkeyInput
  createdAt: Datetime

  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int
  marketToMarketId: CompanyMemberMarketIdFkeyInput
  updatedAt: Datetime
}

"""
Input for the nested mutation of `company` in the `CompanyMemberInput` mutation.
"""
input CompanyMemberCompanyIdFkeyInput {
  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectById: CompanyCompanyPkeyConnect

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByMarketIdAndName: CompanyCompanyMarketIdNameKeyConnect

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByNodeId: CompanyNodeIdConnect

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByReferenceNumber: CompanyCompanyReferenceNumberKeyConnect

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteById: CompanyCompanyPkeyDelete

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByMarketIdAndName: CompanyCompanyMarketIdNameKeyDelete

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByNodeId: CompanyNodeIdDelete

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByReferenceNumber: CompanyCompanyReferenceNumberKeyDelete

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateById: CompanyOnCompanyMemberForCompanyMemberCompanyIdFkeyUsingCompanyPkeyUpdate

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByMarketIdAndName: CompanyOnCompanyMemberForCompanyMemberCompanyIdFkeyUsingCompanyMarketIdNameKeyUpdate

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByNodeId: CompanyMemberOnCompanyMemberForCompanyMemberCompanyIdFkeyNodeIdUpdate

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByReferenceNumber: CompanyOnCompanyMemberForCompanyMemberCompanyIdFkeyUsingCompanyReferenceNumberKeyUpdate
}

"""
Input for the nested mutation of `companyMember` in the `CompanyInput` mutation.
"""
input CompanyMemberCompanyIdFkeyInverseInput {
  """
  The primary key(s) for `companyMember` for the far side of the relationship.
  """
  connectById: [CompanyMemberCompanyMemberPkeyConnect!]

  """
  The primary key(s) for `companyMember` for the far side of the relationship.
  """
  connectByMarketIdAndAccountIdAndCompanyId: [CompanyMemberCompanyMemberMarketIdAccountIdCompanyIdKeyConnect!]

  """
  The primary key(s) for `companyMember` for the far side of the relationship.
  """
  connectByNodeId: [CompanyMemberNodeIdConnect!]

  """
  A `CompanyMemberInput` object that will be created and connected to this object.
  """
  create: [CompanyMemberCompanyIdFkeyCompanyMemberCreateInput!]

  """
  The primary key(s) for `companyMember` for the far side of the relationship.
  """
  deleteById: [CompanyMemberCompanyMemberPkeyDelete!]

  """
  The primary key(s) for `companyMember` for the far side of the relationship.
  """
  deleteByMarketIdAndAccountIdAndCompanyId: [CompanyMemberCompanyMemberMarketIdAccountIdCompanyIdKeyDelete!]

  """
  The primary key(s) for `companyMember` for the far side of the relationship.
  """
  deleteByNodeId: [CompanyMemberNodeIdDelete!]

  """
  Flag indicating whether all other `companyMember` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `companyMember` for the far side of the relationship.
  """
  updateById: [CompanyMemberOnCompanyMemberForCompanyMemberCompanyIdFkeyUsingCompanyMemberPkeyUpdate!]

  """
  The primary key(s) and patch data for `companyMember` for the far side of the relationship.
  """
  updateByMarketIdAndAccountIdAndCompanyId: [CompanyMemberOnCompanyMemberForCompanyMemberCompanyIdFkeyUsingCompanyMemberMarketIdAccountIdCompanyIdKeyUpdate!]

  """
  The primary key(s) and patch data for `companyMember` for the far side of the relationship.
  """
  updateByNodeId: [CompanyOnCompanyMemberForCompanyMemberCompanyIdFkeyNodeIdUpdate!]
}

"""
The fields on `companyMember` to look up the row to connect.
"""
input CompanyMemberCompanyMemberMarketIdAccountIdCompanyIdKeyConnect {
  """
  fk
  """
  accountId: Int!

  """
  fk
  """
  companyId: Int!

  """
  fk
  """
  marketId: Int!
}

"""
The fields on `companyMember` to look up the row to delete.
"""
input CompanyMemberCompanyMemberMarketIdAccountIdCompanyIdKeyDelete {
  """
  fk
  """
  accountId: Int!

  """
  fk
  """
  companyId: Int!

  """
  fk
  """
  marketId: Int!
}

"""
The fields on `companyMember` to look up the row to connect.
"""
input CompanyMemberCompanyMemberPkeyConnect {
  """
  Primary key
  """
  id: Int!
}

"""
The fields on `companyMember` to look up the row to delete.
"""
input CompanyMemberCompanyMemberPkeyDelete {
  """
  Primary key
  """
  id: Int!
}

"""
A condition to be used against `CompanyMember` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input CompanyMemberCondition {
  """
  Checks for equality with the object’s `accountId` field.
  """
  accountId: Int

  """
  Checks for equality with the object’s `companyId` field.
  """
  companyId: Int

  """
  Checks for equality with the object’s `id` field.
  """
  id: Int

  """
  Checks for equality with the object’s `marketId` field.
  """
  marketId: Int
}

"""
A filter to be used against `CompanyMember` object types. All fields are combined with a logical ‘and.’
"""
input CompanyMemberFilter {
  """
  Filter by the object’s `accountId` field.
  """
  accountId: IntFilter

  """
  Checks for all expressions in this list.
  """
  and: [CompanyMemberFilter!]

  """
  Filter by the object’s `companyId` field.
  """
  companyId: IntFilter

  """
  Filter by the object’s `id` field.
  """
  id: IntFilter

  """
  Filter by the object’s `marketId` field.
  """
  marketId: IntFilter

  """
  Negates the expression.
  """
  not: CompanyMemberFilter

  """
  Checks for any expressions in this list.
  """
  or: [CompanyMemberFilter!]
}

"""
An input for mutations affecting `CompanyMember`
"""
input CompanyMemberInput {
  """
  fk
  """
  accountId: Int
  accountToAccountId: CompanyMemberAccountIdFkeyInput

  """
  fk
  """
  companyId: Int
  companyToCompanyId: CompanyMemberCompanyIdFkeyInput
  createdAt: Datetime

  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int
  marketToMarketId: CompanyMemberMarketIdFkeyInput
  updatedAt: Datetime
}

"""
The `companyMember` to be created by this mutation.
"""
input CompanyMemberMarketIdFkeyCompanyMemberCreateInput {
  """
  fk
  """
  accountId: Int
  accountToAccountId: CompanyMemberAccountIdFkeyInput

  """
  fk
  """
  companyId: Int
  companyToCompanyId: CompanyMemberCompanyIdFkeyInput
  createdAt: Datetime

  """
  Primary key
  """
  id: Int
  marketToMarketId: CompanyMemberMarketIdFkeyInput
  updatedAt: Datetime
}

"""
Input for the nested mutation of `market` in the `CompanyMemberInput` mutation.
"""
input CompanyMemberMarketIdFkeyInput {
  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectByDoceboCatalogueId: MarketMarketDoceboCatalogueIdKeyConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectByDomain: MarketMarketDomainKeyConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectById: MarketMarketPkeyConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectByNodeId: MarketNodeIdConnect

  """
  A `MarketInput` object that will be created and connected to this object.
  """
  create: CompanyMemberMarketIdFkeyMarketCreateInput

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteByDoceboCatalogueId: MarketMarketDoceboCatalogueIdKeyDelete

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteByDomain: MarketMarketDomainKeyDelete

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteById: MarketMarketPkeyDelete

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteByNodeId: MarketNodeIdDelete

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateByDoceboCatalogueId: MarketOnCompanyMemberForCompanyMemberMarketIdFkeyUsingMarketDoceboCatalogueIdKeyUpdate

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateByDomain: MarketOnCompanyMemberForCompanyMemberMarketIdFkeyUsingMarketDomainKeyUpdate

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateById: MarketOnCompanyMemberForCompanyMemberMarketIdFkeyUsingMarketPkeyUpdate

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateByNodeId: CompanyMemberOnCompanyMemberForCompanyMemberMarketIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `companyMember` in the `MarketInput` mutation.
"""
input CompanyMemberMarketIdFkeyInverseInput {
  """
  The primary key(s) for `companyMember` for the far side of the relationship.
  """
  connectById: [CompanyMemberCompanyMemberPkeyConnect!]

  """
  The primary key(s) for `companyMember` for the far side of the relationship.
  """
  connectByMarketIdAndAccountIdAndCompanyId: [CompanyMemberCompanyMemberMarketIdAccountIdCompanyIdKeyConnect!]

  """
  The primary key(s) for `companyMember` for the far side of the relationship.
  """
  connectByNodeId: [CompanyMemberNodeIdConnect!]

  """
  A `CompanyMemberInput` object that will be created and connected to this object.
  """
  create: [CompanyMemberMarketIdFkeyCompanyMemberCreateInput!]

  """
  The primary key(s) for `companyMember` for the far side of the relationship.
  """
  deleteById: [CompanyMemberCompanyMemberPkeyDelete!]

  """
  The primary key(s) for `companyMember` for the far side of the relationship.
  """
  deleteByMarketIdAndAccountIdAndCompanyId: [CompanyMemberCompanyMemberMarketIdAccountIdCompanyIdKeyDelete!]

  """
  The primary key(s) for `companyMember` for the far side of the relationship.
  """
  deleteByNodeId: [CompanyMemberNodeIdDelete!]

  """
  Flag indicating whether all other `companyMember` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `companyMember` for the far side of the relationship.
  """
  updateById: [CompanyMemberOnCompanyMemberForCompanyMemberMarketIdFkeyUsingCompanyMemberPkeyUpdate!]

  """
  The primary key(s) and patch data for `companyMember` for the far side of the relationship.
  """
  updateByMarketIdAndAccountIdAndCompanyId: [CompanyMemberOnCompanyMemberForCompanyMemberMarketIdFkeyUsingCompanyMemberMarketIdAccountIdCompanyIdKeyUpdate!]

  """
  The primary key(s) and patch data for `companyMember` for the far side of the relationship.
  """
  updateByNodeId: [MarketOnCompanyMemberForCompanyMemberMarketIdFkeyNodeIdUpdate!]
}

"""
The `market` to be created by this mutation.
"""
input CompanyMemberMarketIdFkeyMarketCreateInput {
  accountsUsingId: AccountMarketIdFkeyInverseInput

  """
  The space in Contenful
  """
  cmsSpaceId: String
  companiesUsingId: CompanyMarketIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberMarketIdFkeyInverseInput
  createdAt: Datetime

  """
  The default catalogue for the Market.  All users in the Market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int
  doceboCatalogueIdT2: Int
  doceboCatalogueIdT3: Int
  doceboCatalogueIdT4: Int

  """
  The Docebo branch that new user are inserted into if they register as a Company Admin. Note that this never gets updated by InTouch. Originally there was going to be a distinction between installer branches and admin branches in Docebo, but this is no longer the preferred approach.
  """
  doceboCompanyAdminBranchId: String

  """
  The Docebo branch that new user are inserted into if they register as an installer.  Note that this never gets updated by InTouch.  Originally there was going to be a distinction between installer branches and admin branches in Docebo, but this is no longer the preferred approach.
  """
  doceboInstallersBranchId: String

  """
  the country code used for example as the subdomain
  """
  domain: String!

  """
  The coordinates of the middle of the Market on a map
  """
  geoMiddle: PointInput

  """
  Reference to the Google Analytics tracking ID that is used for the Country GA reports
  """
  gtag: String
  gtagMarketMedia: String

  """
  Primary key
  """
  id: Int

  """
  ek
  """
  language: Language!

  """
  The length of the radius in km (from the geo_middle lat/lng), for which the Google Places API biases the search results for address autocomplete. Locations outside of the radius will not be excluded.
  """
  locationBiasRadiusKm: Int

  """
  The address of the merchandising site for the market.  CTAs of the MERCHANDISING type will link to this address
  """
  merchandisingUrl: String

  """
  A short name for the market, e.g. Italy, Norway, Netherlands
  """
  name: String
  productsUsingId: ProductMarketIdFkeyInverseInput

  """
  Whether the market supports Projects.  If so then the Projects link should be available in th left hand navigation.
  """
  projectsEnabled: Boolean

  """
  The mailbox on intouch.bmigroup.com that emails will be sent from for this Market
  """
  sendMailbox: String

  """
  The From name used when sending an email
  """
  sendName: String
  systemMembersUsingId: SystemMemberMarketIdFkeyInverseInput
  systemsUsingId: SystemMarketIdFkeyInverseInput
  updatedAt: Datetime
}

"""
The globally unique `ID` look up for the row to connect.
"""
input CompanyMemberNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `companyMember` to be connected.
  """
  nodeId: ID!
}

"""
The globally unique `ID` look up for the row to delete.
"""
input CompanyMemberNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `companyMember` to be deleted.
  """
  nodeId: ID!
}

"""
The globally unique `ID` look up for the row to update.
"""
input CompanyMemberOnCompanyMemberForCompanyMemberAccountIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `account` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: AccountPatch!
}

"""
The fields on `companyMember` to look up the row to update.
"""
input CompanyMemberOnCompanyMemberForCompanyMemberAccountIdFkeyUsingCompanyMemberMarketIdAccountIdCompanyIdKeyUpdate {
  """
  fk
  """
  accountId: Int!

  """
  fk
  """
  companyId: Int!

  """
  fk
  """
  marketId: Int!

  """
  An object where the defined keys will be set on the `companyMember` being updated.
  """
  patch: updateCompanyMemberOnCompanyMemberForCompanyMemberAccountIdFkeyPatch!
}

"""
The fields on `companyMember` to look up the row to update.
"""
input CompanyMemberOnCompanyMemberForCompanyMemberAccountIdFkeyUsingCompanyMemberPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `companyMember` being updated.
  """
  patch: updateCompanyMemberOnCompanyMemberForCompanyMemberAccountIdFkeyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input CompanyMemberOnCompanyMemberForCompanyMemberCompanyIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `company` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: CompanyPatch!
}

"""
The fields on `companyMember` to look up the row to update.
"""
input CompanyMemberOnCompanyMemberForCompanyMemberCompanyIdFkeyUsingCompanyMemberMarketIdAccountIdCompanyIdKeyUpdate {
  """
  fk
  """
  accountId: Int!

  """
  fk
  """
  companyId: Int!

  """
  fk
  """
  marketId: Int!

  """
  An object where the defined keys will be set on the `companyMember` being updated.
  """
  patch: updateCompanyMemberOnCompanyMemberForCompanyMemberCompanyIdFkeyPatch!
}

"""
The fields on `companyMember` to look up the row to update.
"""
input CompanyMemberOnCompanyMemberForCompanyMemberCompanyIdFkeyUsingCompanyMemberPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `companyMember` being updated.
  """
  patch: updateCompanyMemberOnCompanyMemberForCompanyMemberCompanyIdFkeyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input CompanyMemberOnCompanyMemberForCompanyMemberMarketIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `market` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: MarketPatch!
}

"""
The fields on `companyMember` to look up the row to update.
"""
input CompanyMemberOnCompanyMemberForCompanyMemberMarketIdFkeyUsingCompanyMemberMarketIdAccountIdCompanyIdKeyUpdate {
  """
  fk
  """
  accountId: Int!

  """
  fk
  """
  companyId: Int!

  """
  fk
  """
  marketId: Int!

  """
  An object where the defined keys will be set on the `companyMember` being updated.
  """
  patch: updateCompanyMemberOnCompanyMemberForCompanyMemberMarketIdFkeyPatch!
}

"""
The fields on `companyMember` to look up the row to update.
"""
input CompanyMemberOnCompanyMemberForCompanyMemberMarketIdFkeyUsingCompanyMemberPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `companyMember` being updated.
  """
  patch: updateCompanyMemberOnCompanyMemberForCompanyMemberMarketIdFkeyPatch!
}

"""
Represents an update to a `CompanyMember`. Fields that are set will be updated.
"""
input CompanyMemberPatch {
  """
  fk
  """
  accountId: Int
  accountToAccountId: CompanyMemberAccountIdFkeyInput

  """
  fk
  """
  companyId: Int
  companyToCompanyId: CompanyMemberCompanyIdFkeyInput
  createdAt: Datetime

  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int
  marketToMarketId: CompanyMemberMarketIdFkeyInput
  updatedAt: Datetime
}

"""
A connection to a list of `CompanyMember` values.
"""
type CompanyMembersConnection {
  """
  A list of edges which contains the `CompanyMember` and cursor to aid in pagination.
  """
  edges: [CompanyMembersEdge!]!

  """
  A list of `CompanyMember` objects.
  """
  nodes: [CompanyMember!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `CompanyMember` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `CompanyMember` edge in the connection.
"""
type CompanyMembersEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `CompanyMember` at the end of the edge.
  """
  node: CompanyMember!
}

"""
Methods to use when ordering `CompanyMember`.
"""
enum CompanyMembersOrderBy {
  ACCOUNT_ID_ASC
  ACCOUNT_ID_DESC
  COMPANY_ID_ASC
  COMPANY_ID_DESC
  ID_ASC
  ID_DESC
  MARKET_ID_ASC
  MARKET_ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
The globally unique `ID` look up for the row to connect.
"""
input CompanyNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `company` to be connected.
  """
  nodeId: ID!
}

"""
The globally unique `ID` look up for the row to delete.
"""
input CompanyNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `company` to be deleted.
  """
  nodeId: ID!
}

"""
The globally unique `ID` look up for the row to update.
"""
input CompanyOnCompanyDocumentForCompanyDocumentCompanyIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `companyDocument` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `companyDocument` being updated.
  """
  patch: CompanyDocumentPatch!
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnCompanyDocumentForCompanyDocumentCompanyIdFkeyUsingCompanyMarketIdNameKeyUpdate {
  """
  fk
  """
  marketId: Int!

  """
  The registered name of the Company
  """
  name: String!

  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnCompanyDocumentForCompanyDocumentCompanyIdFkeyPatch!
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnCompanyDocumentForCompanyDocumentCompanyIdFkeyUsingCompanyPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnCompanyDocumentForCompanyDocumentCompanyIdFkeyPatch!
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnCompanyDocumentForCompanyDocumentCompanyIdFkeyUsingCompanyReferenceNumberKeyUpdate {
  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnCompanyDocumentForCompanyDocumentCompanyIdFkeyPatch!

  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: Int!
}

"""
The globally unique `ID` look up for the row to update.
"""
input CompanyOnCompanyForCompanyMarketIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `market` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: MarketPatch!
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnCompanyForCompanyMarketIdFkeyUsingCompanyMarketIdNameKeyUpdate {
  """
  fk
  """
  marketId: Int!

  """
  The registered name of the Company
  """
  name: String!

  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnCompanyForCompanyMarketIdFkeyPatch!
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnCompanyForCompanyMarketIdFkeyUsingCompanyPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnCompanyForCompanyMarketIdFkeyPatch!
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnCompanyForCompanyMarketIdFkeyUsingCompanyReferenceNumberKeyUpdate {
  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnCompanyForCompanyMarketIdFkeyPatch!

  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: Int!
}

"""
The globally unique `ID` look up for the row to update.
"""
input CompanyOnCompanyForCompanyRegisteredAddressIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `address` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `address` being updated.
  """
  patch: AddressPatch!
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnCompanyForCompanyRegisteredAddressIdFkeyUsingCompanyMarketIdNameKeyUpdate {
  """
  fk
  """
  marketId: Int!

  """
  The registered name of the Company
  """
  name: String!

  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnCompanyForCompanyRegisteredAddressIdFkeyPatch!
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnCompanyForCompanyRegisteredAddressIdFkeyUsingCompanyPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnCompanyForCompanyRegisteredAddressIdFkeyPatch!
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnCompanyForCompanyRegisteredAddressIdFkeyUsingCompanyReferenceNumberKeyUpdate {
  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnCompanyForCompanyRegisteredAddressIdFkeyPatch!

  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: Int!
}

"""
The globally unique `ID` look up for the row to update.
"""
input CompanyOnCompanyForCompanyTradingAddressIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `address` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `address` being updated.
  """
  patch: AddressPatch!
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnCompanyForCompanyTradingAddressIdFkeyUsingCompanyMarketIdNameKeyUpdate {
  """
  fk
  """
  marketId: Int!

  """
  The registered name of the Company
  """
  name: String!

  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnCompanyForCompanyTradingAddressIdFkeyPatch!
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnCompanyForCompanyTradingAddressIdFkeyUsingCompanyPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnCompanyForCompanyTradingAddressIdFkeyPatch!
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnCompanyForCompanyTradingAddressIdFkeyUsingCompanyReferenceNumberKeyUpdate {
  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnCompanyForCompanyTradingAddressIdFkeyPatch!

  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: Int!
}

"""
The globally unique `ID` look up for the row to update.
"""
input CompanyOnCompanyMemberForCompanyMemberCompanyIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `companyMember` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `companyMember` being updated.
  """
  patch: CompanyMemberPatch!
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnCompanyMemberForCompanyMemberCompanyIdFkeyUsingCompanyMarketIdNameKeyUpdate {
  """
  fk
  """
  marketId: Int!

  """
  The registered name of the Company
  """
  name: String!

  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnCompanyMemberForCompanyMemberCompanyIdFkeyPatch!
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnCompanyMemberForCompanyMemberCompanyIdFkeyUsingCompanyPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnCompanyMemberForCompanyMemberCompanyIdFkeyPatch!
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnCompanyMemberForCompanyMemberCompanyIdFkeyUsingCompanyReferenceNumberKeyUpdate {
  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnCompanyMemberForCompanyMemberCompanyIdFkeyPatch!

  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: Int!
}

"""
The globally unique `ID` look up for the row to update.
"""
input CompanyOnCompanyOperationForCompanyOperationCompanyFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `companyOperation` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `companyOperation` being updated.
  """
  patch: CompanyOperationPatch!
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnCompanyOperationForCompanyOperationCompanyFkeyUsingCompanyMarketIdNameKeyUpdate {
  """
  fk
  """
  marketId: Int!

  """
  The registered name of the Company
  """
  name: String!

  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnCompanyOperationForCompanyOperationCompanyFkeyPatch!
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnCompanyOperationForCompanyOperationCompanyFkeyUsingCompanyPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnCompanyOperationForCompanyOperationCompanyFkeyPatch!
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnCompanyOperationForCompanyOperationCompanyFkeyUsingCompanyReferenceNumberKeyUpdate {
  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnCompanyOperationForCompanyOperationCompanyFkeyPatch!

  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: Int!
}

"""
The globally unique `ID` look up for the row to update.
"""
input CompanyOnInvitationForInvitationCompanyIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `invitation` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `invitation` being updated.
  """
  patch: InvitationPatch!
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnInvitationForInvitationCompanyIdFkeyUsingCompanyMarketIdNameKeyUpdate {
  """
  fk
  """
  marketId: Int!

  """
  The registered name of the Company
  """
  name: String!

  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnInvitationForInvitationCompanyIdFkeyPatch!
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnInvitationForInvitationCompanyIdFkeyUsingCompanyPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnInvitationForInvitationCompanyIdFkeyPatch!
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnInvitationForInvitationCompanyIdFkeyUsingCompanyReferenceNumberKeyUpdate {
  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnInvitationForInvitationCompanyIdFkeyPatch!

  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: Int!
}

"""
The globally unique `ID` look up for the row to update.
"""
input CompanyOnProjectForProjectCompanyIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `project` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `project` being updated.
  """
  patch: ProjectPatch!
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnProjectForProjectCompanyIdFkeyUsingCompanyMarketIdNameKeyUpdate {
  """
  fk
  """
  marketId: Int!

  """
  The registered name of the Company
  """
  name: String!

  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnProjectForProjectCompanyIdFkeyPatch!
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnProjectForProjectCompanyIdFkeyUsingCompanyPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnProjectForProjectCompanyIdFkeyPatch!
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnProjectForProjectCompanyIdFkeyUsingCompanyReferenceNumberKeyUpdate {
  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnProjectForProjectCompanyIdFkeyPatch!

  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: Int!
}

"""
The assignment of an operation type to a Company by the Market Admin.  A Company can be assigned multiple types from the allowed enums list.  The operation types that a Company has are sent to Find a Roofer.
"""
type CompanyOperation implements Node {
  """
  fk
  """
  company: Int!

  """
  Reads a single `Company` that is related to this `CompanyOperation`.
  """
  companyByCompany: Company
  createdAt: Datetime!

  """
  Primary key
  """
  id: Int!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  ek
  """
  operation: Operation!
  updatedAt: Datetime!
}

"""
The `companyOperation` to be created by this mutation.
"""
input CompanyOperationCompanyFkeyCompanyOperationCreateInput {
  companyToCompany: CompanyOperationCompanyFkeyInput
  createdAt: Datetime

  """
  Primary key
  """
  id: Int

  """
  ek
  """
  operation: Operation!
  updatedAt: Datetime
}

"""
Input for the nested mutation of `company` in the `CompanyOperationInput` mutation.
"""
input CompanyOperationCompanyFkeyInput {
  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectById: CompanyCompanyPkeyConnect

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByMarketIdAndName: CompanyCompanyMarketIdNameKeyConnect

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByNodeId: CompanyNodeIdConnect

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByReferenceNumber: CompanyCompanyReferenceNumberKeyConnect

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteById: CompanyCompanyPkeyDelete

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByMarketIdAndName: CompanyCompanyMarketIdNameKeyDelete

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByNodeId: CompanyNodeIdDelete

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByReferenceNumber: CompanyCompanyReferenceNumberKeyDelete

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateById: CompanyOnCompanyOperationForCompanyOperationCompanyFkeyUsingCompanyPkeyUpdate

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByMarketIdAndName: CompanyOnCompanyOperationForCompanyOperationCompanyFkeyUsingCompanyMarketIdNameKeyUpdate

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByNodeId: CompanyOperationOnCompanyOperationForCompanyOperationCompanyFkeyNodeIdUpdate

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByReferenceNumber: CompanyOnCompanyOperationForCompanyOperationCompanyFkeyUsingCompanyReferenceNumberKeyUpdate
}

"""
Input for the nested mutation of `companyOperation` in the `CompanyInput` mutation.
"""
input CompanyOperationCompanyFkeyInverseInput {
  """
  The primary key(s) for `companyOperation` for the far side of the relationship.
  """
  connectById: [CompanyOperationCompanyOperationPkeyConnect!]

  """
  The primary key(s) for `companyOperation` for the far side of the relationship.
  """
  connectByNodeId: [CompanyOperationNodeIdConnect!]

  """
  A `CompanyOperationInput` object that will be created and connected to this object.
  """
  create: [CompanyOperationCompanyFkeyCompanyOperationCreateInput!]

  """
  The primary key(s) for `companyOperation` for the far side of the relationship.
  """
  deleteById: [CompanyOperationCompanyOperationPkeyDelete!]

  """
  The primary key(s) for `companyOperation` for the far side of the relationship.
  """
  deleteByNodeId: [CompanyOperationNodeIdDelete!]

  """
  Flag indicating whether all other `companyOperation` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `companyOperation` for the far side of the relationship.
  """
  updateById: [CompanyOperationOnCompanyOperationForCompanyOperationCompanyFkeyUsingCompanyOperationPkeyUpdate!]

  """
  The primary key(s) and patch data for `companyOperation` for the far side of the relationship.
  """
  updateByNodeId: [CompanyOnCompanyOperationForCompanyOperationCompanyFkeyNodeIdUpdate!]
}

"""
The fields on `companyOperation` to look up the row to connect.
"""
input CompanyOperationCompanyOperationPkeyConnect {
  """
  Primary key
  """
  id: Int!
}

"""
The fields on `companyOperation` to look up the row to delete.
"""
input CompanyOperationCompanyOperationPkeyDelete {
  """
  Primary key
  """
  id: Int!
}

"""
A condition to be used against `CompanyOperation` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input CompanyOperationCondition {
  """
  Checks for equality with the object’s `company` field.
  """
  company: Int

  """
  Checks for equality with the object’s `id` field.
  """
  id: Int
}

"""
A filter to be used against `CompanyOperation` object types. All fields are combined with a logical ‘and.’
"""
input CompanyOperationFilter {
  """
  Checks for all expressions in this list.
  """
  and: [CompanyOperationFilter!]

  """
  Filter by the object’s `company` field.
  """
  company: IntFilter

  """
  Filter by the object’s `id` field.
  """
  id: IntFilter

  """
  Negates the expression.
  """
  not: CompanyOperationFilter

  """
  Checks for any expressions in this list.
  """
  or: [CompanyOperationFilter!]
}

"""
An input for mutations affecting `CompanyOperation`
"""
input CompanyOperationInput {
  """
  fk
  """
  company: Int
  companyToCompany: CompanyOperationCompanyFkeyInput
  createdAt: Datetime

  """
  Primary key
  """
  id: Int

  """
  ek
  """
  operation: Operation!
  updatedAt: Datetime
}

"""
The globally unique `ID` look up for the row to connect.
"""
input CompanyOperationNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `companyOperation` to be connected.
  """
  nodeId: ID!
}

"""
The globally unique `ID` look up for the row to delete.
"""
input CompanyOperationNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `companyOperation` to be deleted.
  """
  nodeId: ID!
}

"""
The globally unique `ID` look up for the row to update.
"""
input CompanyOperationOnCompanyOperationForCompanyOperationCompanyFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `company` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: CompanyPatch!
}

"""
The fields on `companyOperation` to look up the row to update.
"""
input CompanyOperationOnCompanyOperationForCompanyOperationCompanyFkeyUsingCompanyOperationPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `companyOperation` being updated.
  """
  patch: updateCompanyOperationOnCompanyOperationForCompanyOperationCompanyFkeyPatch!
}

"""
Represents an update to a `CompanyOperation`. Fields that are set will be updated.
"""
input CompanyOperationPatch {
  """
  fk
  """
  company: Int
  companyToCompany: CompanyOperationCompanyFkeyInput
  createdAt: Datetime

  """
  Primary key
  """
  id: Int

  """
  ek
  """
  operation: Operation
  updatedAt: Datetime
}

"""
A connection to a list of `CompanyOperation` values.
"""
type CompanyOperationsConnection {
  """
  A list of edges which contains the `CompanyOperation` and cursor to aid in pagination.
  """
  edges: [CompanyOperationsEdge!]!

  """
  A list of `CompanyOperation` objects.
  """
  nodes: [CompanyOperation!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `CompanyOperation` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `CompanyOperation` edge in the connection.
"""
type CompanyOperationsEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `CompanyOperation` at the end of the edge.
  """
  node: CompanyOperation!
}

"""
Methods to use when ordering `CompanyOperation`.
"""
enum CompanyOperationsOrderBy {
  COMPANY_ASC
  COMPANY_DESC
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
Represents an update to a `Company`. Fields that are set will be updated.
"""
input CompanyPatch {
  """
  A descirption of the Company intended for Find a Roofer
  """
  aboutUs: String
  addressToRegisteredAddressId: CompanyRegisteredAddressIdFkeyInput
  addressToTradingAddressId: CompanyTradingAddressIdFkeyInput

  """
  ek
  """
  businessType: BusinessType
  companyDocumentsUsingId: CompanyDocumentCompanyIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberCompanyIdFkeyInverseInput
  companyOperationsUsingId: CompanyOperationCompanyFkeyInverseInput
  createdAt: Datetime

  """
  The Company facebook website
  """
  facebook: String

  """
  Primary key
  """
  id: Int
  invitationsUsingId: InvitationCompanyIdFkeyInverseInput

  """
  Their Company LinkedIn page URL
  """
  linkedIn: String

  """
  A reference to the logo image
  """
  logo: String
  logoUpload: Upload

  """
  fk
  """
  marketId: Int
  marketToMarketId: CompanyMarketIdFkeyInput

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String

  """
  The registered name of the Company
  """
  name: String

  """
  the email address to contact the owner
  """
  ownerEmail: String

  """
  the name of the owner of the Company
  """
  ownerFullname: String

  """
  the phone number to contact the owner
  """
  ownerPhone: String

  """
  The Company public phone number
  """
  phone: String
  projectsUsingId: ProjectCompanyIdFkeyInverseInput

  """
  The email address that they can be contacted with by the public assuming they are listed
  """
  publicEmail: String

  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: Int

  """
  fk
  """
  registeredAddressId: Int

  """
  Used for reference when importing data from the legacy system
  """
  registeredAddressMigrationId: String

  """
  the email address of the person who filled out the company registration form
  """
  registeredBy: String

  """
  the date that the Company registration form was submitted
  """
  registeredDate: Datetime
  shouldRemoveLogo: Boolean

  """
  ek
  """
  status: CompanyStatus

  """
  The Tax number in that Market, such as the VAT number
  """
  taxNumber: String

  """
  ek
  """
  tier: Tier

  """
  fk
  """
  tradingAddressId: Int

  """
  Used for reference when importing data from the legacy system
  """
  tradingAddressMigrationId: String
  updatedAt: Datetime

  """
  The Company website URL
  """
  website: String
}

"""
The `address` to be created by this mutation.
"""
input CompanyRegisteredAddressIdFkeyAddressCreateInput {
  companiesToRegisteredAddressIdUsingId: CompanyRegisteredAddressIdFkeyInverseInput
  companiesToTradingAddressIdUsingId: CompanyTradingAddressIdFkeyInverseInput

  """
  The coordinates on a map of the world
  """
  coordinates: PointInput

  """
  The country for this address
  """
  country: String
  createdAt: Datetime

  """
  First line of this address
  """
  firstLine: String

  """
  Primary key
  """
  id: Int

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String

  """
  The postcode for this address
  """
  postcode: String
  projectsToBuildingOwnerAddressIdUsingId: ProjectBuildingOwnerAddressIdFkeyInverseInput
  projectsToSiteAddressIdUsingId: ProjectSiteAddressIdFkeyInverseInput

  """
  The region if relevant
  """
  region: String

  """
  Second line of this address
  """
  secondLine: String

  """
  The postal town
  """
  town: String
  updatedAt: Datetime
}

"""
Input for the nested mutation of `address` in the `CompanyInput` mutation.
"""
input CompanyRegisteredAddressIdFkeyInput {
  """
  The primary key(s) for `address` for the far side of the relationship.
  """
  connectById: AddressAddressPkeyConnect

  """
  The primary key(s) for `address` for the far side of the relationship.
  """
  connectByNodeId: AddressNodeIdConnect

  """
  A `AddressInput` object that will be created and connected to this object.
  """
  create: CompanyRegisteredAddressIdFkeyAddressCreateInput

  """
  The primary key(s) for `address` for the far side of the relationship.
  """
  deleteById: AddressAddressPkeyDelete

  """
  The primary key(s) for `address` for the far side of the relationship.
  """
  deleteByNodeId: AddressNodeIdDelete

  """
  The primary key(s) and patch data for `address` for the far side of the relationship.
  """
  updateById: AddressOnCompanyForCompanyRegisteredAddressIdFkeyUsingAddressPkeyUpdate

  """
  The primary key(s) and patch data for `address` for the far side of the relationship.
  """
  updateByNodeId: CompanyOnCompanyForCompanyRegisteredAddressIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `company` in the `AddressInput` mutation.
"""
input CompanyRegisteredAddressIdFkeyInverseInput {
  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectById: [CompanyCompanyPkeyConnect!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByMarketIdAndName: [CompanyCompanyMarketIdNameKeyConnect!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByNodeId: [CompanyNodeIdConnect!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByReferenceNumber: [CompanyCompanyReferenceNumberKeyConnect!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteById: [CompanyCompanyPkeyDelete!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByMarketIdAndName: [CompanyCompanyMarketIdNameKeyDelete!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByNodeId: [CompanyNodeIdDelete!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByReferenceNumber: [CompanyCompanyReferenceNumberKeyDelete!]

  """
  Flag indicating whether all other `company` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateById: [CompanyOnCompanyForCompanyRegisteredAddressIdFkeyUsingCompanyPkeyUpdate!]

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByMarketIdAndName: [CompanyOnCompanyForCompanyRegisteredAddressIdFkeyUsingCompanyMarketIdNameKeyUpdate!]

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByNodeId: [AddressOnCompanyForCompanyRegisteredAddressIdFkeyNodeIdUpdate!]

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByReferenceNumber: [CompanyOnCompanyForCompanyRegisteredAddressIdFkeyUsingCompanyReferenceNumberKeyUpdate!]
}

enum CompanyStatus {
  ACTIVE
  DEACTIVATED
  NEW
}

"""
The `address` to be created by this mutation.
"""
input CompanyTradingAddressIdFkeyAddressCreateInput {
  companiesToRegisteredAddressIdUsingId: CompanyRegisteredAddressIdFkeyInverseInput
  companiesToTradingAddressIdUsingId: CompanyTradingAddressIdFkeyInverseInput

  """
  The coordinates on a map of the world
  """
  coordinates: PointInput

  """
  The country for this address
  """
  country: String
  createdAt: Datetime

  """
  First line of this address
  """
  firstLine: String

  """
  Primary key
  """
  id: Int

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String

  """
  The postcode for this address
  """
  postcode: String
  projectsToBuildingOwnerAddressIdUsingId: ProjectBuildingOwnerAddressIdFkeyInverseInput
  projectsToSiteAddressIdUsingId: ProjectSiteAddressIdFkeyInverseInput

  """
  The region if relevant
  """
  region: String

  """
  Second line of this address
  """
  secondLine: String

  """
  The postal town
  """
  town: String
  updatedAt: Datetime
}

"""
Input for the nested mutation of `address` in the `CompanyInput` mutation.
"""
input CompanyTradingAddressIdFkeyInput {
  """
  The primary key(s) for `address` for the far side of the relationship.
  """
  connectById: AddressAddressPkeyConnect

  """
  The primary key(s) for `address` for the far side of the relationship.
  """
  connectByNodeId: AddressNodeIdConnect

  """
  A `AddressInput` object that will be created and connected to this object.
  """
  create: CompanyTradingAddressIdFkeyAddressCreateInput

  """
  The primary key(s) for `address` for the far side of the relationship.
  """
  deleteById: AddressAddressPkeyDelete

  """
  The primary key(s) for `address` for the far side of the relationship.
  """
  deleteByNodeId: AddressNodeIdDelete

  """
  The primary key(s) and patch data for `address` for the far side of the relationship.
  """
  updateById: AddressOnCompanyForCompanyTradingAddressIdFkeyUsingAddressPkeyUpdate

  """
  The primary key(s) and patch data for `address` for the far side of the relationship.
  """
  updateByNodeId: CompanyOnCompanyForCompanyTradingAddressIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `company` in the `AddressInput` mutation.
"""
input CompanyTradingAddressIdFkeyInverseInput {
  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectById: [CompanyCompanyPkeyConnect!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByMarketIdAndName: [CompanyCompanyMarketIdNameKeyConnect!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByNodeId: [CompanyNodeIdConnect!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByReferenceNumber: [CompanyCompanyReferenceNumberKeyConnect!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteById: [CompanyCompanyPkeyDelete!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByMarketIdAndName: [CompanyCompanyMarketIdNameKeyDelete!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByNodeId: [CompanyNodeIdDelete!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByReferenceNumber: [CompanyCompanyReferenceNumberKeyDelete!]

  """
  Flag indicating whether all other `company` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateById: [CompanyOnCompanyForCompanyTradingAddressIdFkeyUsingCompanyPkeyUpdate!]

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByMarketIdAndName: [CompanyOnCompanyForCompanyTradingAddressIdFkeyUsingCompanyMarketIdNameKeyUpdate!]

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByNodeId: [AddressOnCompanyForCompanyTradingAddressIdFkeyNodeIdUpdate!]

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByReferenceNumber: [CompanyOnCompanyForCompanyTradingAddressIdFkeyUsingCompanyReferenceNumberKeyUpdate!]
}

"""
Contact details that appear as cards on the Company Page [See type definition](https://app.contentful.com/spaces/j30snaps0u9c/content_types/contactDetails)
"""
type ContactDetails implements Entry {
  contentfulMetadata: ContentfulMetadata!
  email(locale: String): String
  fullName(locale: String): String
  linkedFrom(allowedLocales: [String]): ContactDetailsLinkingCollections
  phoneNumber(locale: String): String
  subHeading(locale: String): String
  sys: Sys!
}

type ContactDetailsCollection {
  items: [ContactDetails]!
  limit: Int!
  skip: Int!
  total: Int!
}

input ContactDetailsFilter {
  AND: [ContactDetailsFilter]
  OR: [ContactDetailsFilter]
  contentfulMetadata: ContentfulMetadataFilter
  email: String
  email_contains: String
  email_exists: Boolean
  email_in: [String]
  email_not: String
  email_not_contains: String
  email_not_in: [String]
  fullName: String
  fullName_contains: String
  fullName_exists: Boolean
  fullName_in: [String]
  fullName_not: String
  fullName_not_contains: String
  fullName_not_in: [String]
  phoneNumber: String
  phoneNumber_contains: String
  phoneNumber_exists: Boolean
  phoneNumber_in: [String]
  phoneNumber_not: String
  phoneNumber_not_contains: String
  phoneNumber_not_in: [String]
  subHeading: String
  subHeading_contains: String
  subHeading_exists: Boolean
  subHeading_in: [String]
  subHeading_not: String
  subHeading_not_contains: String
  subHeading_not_in: [String]
  sys: SysFilter
}

type ContactDetailsLinkingCollections {
  entryCollection(
    limit: Int = 100
    locale: String
    preview: Boolean
    skip: Int = 0
  ): EntryCollection
  marketContentCollection(
    limit: Int = 100
    locale: String
    preview: Boolean
    skip: Int = 0
  ): MarketContentCollection
}

enum ContactDetailsOrder {
  email_ASC
  email_DESC
  fullName_ASC
  fullName_DESC
  phoneNumber_ASC
  phoneNumber_DESC
  subHeading_ASC
  subHeading_DESC
  sys_firstPublishedAt_ASC
  sys_firstPublishedAt_DESC
  sys_id_ASC
  sys_id_DESC
  sys_publishedAt_ASC
  sys_publishedAt_DESC
  sys_publishedVersion_ASC
  sys_publishedVersion_DESC
}

"""
A standard webpage with just information and no iteractive functionality.  Currently limited to those pages targeted in the footer, which are Cookies Policy, Terms of use and the Privacy Policy [See type definition](https://app.contentful.com/spaces/j30snaps0u9c/content_types/contentArticle)
"""
type ContentArticle implements Entry {
  body(locale: String): ContentArticleBody
  contentfulMetadata: ContentfulMetadata!
  linkedFrom(allowedLocales: [String]): ContentArticleLinkingCollections
  relativePath(locale: String): String
  sys: Sys!
  title(locale: String): String
}

type ContentArticleBody {
  json: JSON!
  links: ContentArticleBodyLinks!
}

type ContentArticleBodyAssets {
  block: [Asset]!
  hyperlink: [Asset]!
}

type ContentArticleBodyEntries {
  block: [Entry]!
  hyperlink: [Entry]!
  inline: [Entry]!
}

type ContentArticleBodyLinks {
  assets: ContentArticleBodyAssets!
  entries: ContentArticleBodyEntries!
}

type ContentArticleCollection {
  items: [ContentArticle]!
  limit: Int!
  skip: Int!
  total: Int!
}

input ContentArticleFilter {
  AND: [ContentArticleFilter]
  OR: [ContentArticleFilter]
  body_contains: String
  body_exists: Boolean
  body_not_contains: String
  contentfulMetadata: ContentfulMetadataFilter
  relativePath: String
  relativePath_contains: String
  relativePath_exists: Boolean
  relativePath_in: [String]
  relativePath_not: String
  relativePath_not_contains: String
  relativePath_not_in: [String]
  sys: SysFilter
  title: String
  title_contains: String
  title_exists: Boolean
  title_in: [String]
  title_not: String
  title_not_contains: String
  title_not_in: [String]
}

type ContentArticleLinkingCollections {
  entryCollection(
    limit: Int = 100
    locale: String
    preview: Boolean
    skip: Int = 0
  ): EntryCollection
  marketContentCollection(
    limit: Int = 100
    locale: String
    preview: Boolean
    skip: Int = 0
  ): MarketContentCollection
}

enum ContentArticleOrder {
  relativePath_ASC
  relativePath_DESC
  sys_firstPublishedAt_ASC
  sys_firstPublishedAt_DESC
  sys_id_ASC
  sys_id_DESC
  sys_publishedAt_ASC
  sys_publishedAt_DESC
  sys_publishedVersion_ASC
  sys_publishedVersion_DESC
  title_ASC
  title_DESC
}

type ContentfulAsset {
  contentType: String
  description: String
  fileName: String
  title: String
  url: String
}

type ContentfulEvidenceCategory {
  description: ContentfulEvidenceCategoryDescription
  minimumUploads: Int
  name: String
  referenceCode: String
  sys: ContentfulSys!
}

type ContentfulEvidenceCategoryCollection {
  items: [ContentfulEvidenceCategory]
}

type ContentfulEvidenceCategoryDescription {
  json: JSON!
}

enum ContentfulGuaranteeCoverageType {
  PRODUCT
  SOLUTION
  SYSTEM
}

type ContentfulGuaranteeTemplate {
  approvalMessage: ContentfulMessage
  coverage: String
  displayName: String
  filenamePrefix: String
  footer: String
  guaranteeScope: String
  headingBeneficiary: String
  headingBuildingAddress: String
  headingBuildingOwnerName: String
  headingContractor: String
  headingContractorId: String
  headingContractorName: String
  headingExpiry: String
  headingGuarantee: String
  headingGuaranteeId: String
  headingProducts: String
  headingRoofArea: String
  headingRoofType: String
  headingScope: String
  headingStartDate: String
  headingValidity: String
  languageCode: String
  languageDescriptor: String
  logo: ContentfulAsset
  mailBody: String
  mailSubject: String
  maintenanceTemplate: ContentfulAsset
  rejectionMessage: ContentfulMessage
  roofType: String
  signatory: String
  technology: ContentfulTechnologyType
  terms: ContentfulAsset
  titleLine1: String
  titleLine2: String
}

type ContentfulGuaranteeTemplatesCollection {
  items: [ContentfulGuaranteeTemplate]
  total: Int!
}

type ContentfulGuaranteeType {
  coverage: ContentfulGuaranteeCoverageType
  displayName: String
  evidenceCategoriesCollection: ContentfulEvidenceCategoryCollection
  guaranteeReferenceCode: GuaranteeReferenceCode
  guaranteeTemplatesCollection: ContentfulGuaranteeTemplatesCollection
  languageCode: String
  maximumValidityYears: Int
  name: String
  ranking: Int
  signature: ContentfulAsset
  sys: ContentfulSys!
  technology: ContentfulTechnologyType
  tiersAvailable: [ContentfulTiers]
}

type ContentfulGuaranteeTypeCollection {
  items: [ContentfulGuaranteeType]
}

type ContentfulMessage {
  emailBody: String
  event: ContentfulMessageEventType
  format: [ContentfulMessageFormat]
  notificationBody: String
  subject: String
}

enum ContentfulMessageEventType {
  ADMIN_INVITED
  CERTIFICATION_EXPIRED
  MEMBER_INVITED
  NEWUSER_INVITED
  OWNER_INVITED
  PROFILE_REMINDER
  REGISTRATION_ACTIVATED
  REGISTRATION_CONGRATS
  REQUEST_APPROVED
  REQUEST_REJECTED
  ROLE_ASSIGNED
  TEAM_JOINED
  TIER_ASSIGNED
}

enum ContentfulMessageFormat {
  EMAIL
  NOTIFICATION
}

type ContentfulMetadata {
  tags: [ContentfulTag]!
}

input ContentfulMetadataFilter {
  tags: ContentfulMetadataTagsFilter
  tags_exists: Boolean
}

input ContentfulMetadataTagsFilter {
  id_contains_all: [String]
  id_contains_none: [String]
  id_contains_some: [String]
}

type ContentfulSys {
  id: String!
}

"""
Represents a tag entity for finding and organizing content easily.
    Find out more here: https://www.contentful.com/developers/docs/references/content-delivery-api/#/reference/content-tags
"""
type ContentfulTag {
  id: String
  name: String
}

enum ContentfulTechnologyType {
  FLAT
  OTHER
  PITCHED
}

enum ContentfulTiers {
  T1
  T2
  T3
  T4
  T5
  T6
  T7
}

"""
A training course that BMI offers in Docebo
"""
type Course {
  """
  Reads and enables pagination through a set of `CourseCatalogue`.
  """
  courseCatalogues(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CourseCatalogueCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `CourseCatalogue`.
    """
    orderBy: [CourseCataloguesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CourseCataloguesConnection!

  """
  Reads and enables pagination through a set of `CourseEnrollment`.
  """
  courseEnrollments(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CourseEnrollmentCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `CourseEnrollment`.
    """
    orderBy: [CourseEnrollmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CourseEnrollmentsConnection!

  """
  Docebo CourseId
  """
  courseId: Int
  createdAt: Datetime!

  """
  Text description from Docebo
  """
  description: String

  """
  Primary key
  """
  id: Int!

  """
  A reference to the image
  """
  image: String

  """
  A short name for the Course taken from Docebo
  """
  name: String

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Promoted courses a listed higher than others
  """
  promoted: Boolean

  """
  Course slug
  """
  slug: String

  """
  technology
  """
  technology: String

  """
  Some text from Docebo indicating whether it is a webinar, classroom etc
  """
  trainingType: String
  updatedAt: Datetime!
}

"""
Course Catalog
"""
type CourseCatalogue {
  """
  market
  """
  catalogueId: Int

  """
  Reads a single `Course` that is related to this `CourseCatalogue`.
  """
  course: Course

  """
  fk
  """
  courseId: Int
  createdAt: Datetime!

  """
  Primary key
  """
  id: Int!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  updatedAt: Datetime!
}

"""
A condition to be used against `CourseCatalogue` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input CourseCatalogueCondition {
  """
  Checks for equality with the object’s `catalogueId` field.
  """
  catalogueId: Int

  """
  Checks for equality with the object’s `courseId` field.
  """
  courseId: Int

  """
  Checks for equality with the object’s `id` field.
  """
  id: Int
}

"""
An input for mutations affecting `CourseCatalogue`
"""
input CourseCatalogueInput {
  """
  market
  """
  catalogueId: Int

  """
  fk
  """
  courseId: Int
  createdAt: Datetime

  """
  Primary key
  """
  id: Int
  updatedAt: Datetime
}

"""
Represents an update to a `CourseCatalogue`. Fields that are set will be updated.
"""
input CourseCataloguePatch {
  """
  market
  """
  catalogueId: Int

  """
  fk
  """
  courseId: Int
  createdAt: Datetime

  """
  Primary key
  """
  id: Int
  updatedAt: Datetime
}

"""
Course Catalog temp table.  The course cataloogues from docebo are pulled into here first, before being merged into the course_catalogue table.
"""
type CourseCatalogueTemp {
  """
  catalogue
  """
  catalogueId: Int

  """
  course
  """
  courseId: Int
  createdAt: Datetime!

  """
  Primary key
  """
  id: Int!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  updatedAt: Datetime!
}

"""
A condition to be used against `CourseCatalogueTemp` object types. All fields
are tested for equality and combined with a logical ‘and.’
"""
input CourseCatalogueTempCondition {
  """
  Checks for equality with the object’s `id` field.
  """
  id: Int
}

"""
An input for mutations affecting `CourseCatalogueTemp`
"""
input CourseCatalogueTempInput {
  """
  catalogue
  """
  catalogueId: Int

  """
  course
  """
  courseId: Int
  createdAt: Datetime

  """
  Primary key
  """
  id: Int
  updatedAt: Datetime
}

"""
Represents an update to a `CourseCatalogueTemp`. Fields that are set will be updated.
"""
input CourseCatalogueTempPatch {
  """
  catalogue
  """
  catalogueId: Int

  """
  course
  """
  courseId: Int
  createdAt: Datetime

  """
  Primary key
  """
  id: Int
  updatedAt: Datetime
}

"""
A connection to a list of `CourseCatalogueTemp` values.
"""
type CourseCatalogueTempsConnection {
  """
  A list of edges which contains the `CourseCatalogueTemp` and cursor to aid in pagination.
  """
  edges: [CourseCatalogueTempsEdge!]!

  """
  A list of `CourseCatalogueTemp` objects.
  """
  nodes: [CourseCatalogueTemp!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `CourseCatalogueTemp` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `CourseCatalogueTemp` edge in the connection.
"""
type CourseCatalogueTempsEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `CourseCatalogueTemp` at the end of the edge.
  """
  node: CourseCatalogueTemp!
}

"""
Methods to use when ordering `CourseCatalogueTemp`.
"""
enum CourseCatalogueTempsOrderBy {
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
All input for the `courseCatalogueUpdateByTemp` mutation.
"""
input CourseCatalogueUpdateByTempInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""
The output of our `courseCatalogueUpdateByTemp` mutation.
"""
type CourseCatalogueUpdateByTempPayload {
  bigInt: BigInt

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `courseCatalogueUpdate` mutation.
"""
input CourseCatalogueUpdateInput {
  catalogues: [CourseCatalogueInput]

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""
The output of our `courseCatalogueUpdate` mutation.
"""
type CourseCatalogueUpdatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
A connection to a list of `CourseCatalogue` values.
"""
type CourseCataloguesConnection {
  """
  A list of edges which contains the `CourseCatalogue` and cursor to aid in pagination.
  """
  edges: [CourseCataloguesEdge!]!

  """
  A list of `CourseCatalogue` objects.
  """
  nodes: [CourseCatalogue!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `CourseCatalogue` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `CourseCatalogue` edge in the connection.
"""
type CourseCataloguesEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `CourseCatalogue` at the end of the edge.
  """
  node: CourseCatalogue!
}

"""
Methods to use when ordering `CourseCatalogue`.
"""
enum CourseCataloguesOrderBy {
  CATALOGUE_ID_ASC
  CATALOGUE_ID_DESC
  COURSE_ID_ASC
  COURSE_ID_DESC
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Course` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input CourseCondition {
  """
  Checks for equality with the object’s `courseId` field.
  """
  courseId: Int

  """
  Checks for equality with the object’s `id` field.
  """
  id: Int
}

"""
Course Enrollments
"""
type CourseEnrollment {
  """
  Reads a single `Course` that is related to this `CourseEnrollment`.
  """
  course: Course

  """
  fk
  """
  courseId: Int
  createdAt: Datetime!

  """
  Primary key
  """
  id: Int!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  status
  """
  status: String
  updatedAt: Datetime!

  """
  url
  """
  url: String

  """
  account
  """
  userId: Int
}

"""
A condition to be used against `CourseEnrollment` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input CourseEnrollmentCondition {
  """
  Checks for equality with the object’s `courseId` field.
  """
  courseId: Int

  """
  Checks for equality with the object’s `id` field.
  """
  id: Int

  """
  Checks for equality with the object’s `userId` field.
  """
  userId: Int
}

"""
An input for mutations affecting `CourseEnrollment`
"""
input CourseEnrollmentInput {
  """
  fk
  """
  courseId: Int
  createdAt: Datetime

  """
  Primary key
  """
  id: Int

  """
  status
  """
  status: String
  updatedAt: Datetime

  """
  url
  """
  url: String

  """
  account
  """
  userId: Int
}

"""
Represents an update to a `CourseEnrollment`. Fields that are set will be updated.
"""
input CourseEnrollmentPatch {
  """
  fk
  """
  courseId: Int
  createdAt: Datetime

  """
  Primary key
  """
  id: Int

  """
  status
  """
  status: String
  updatedAt: Datetime

  """
  url
  """
  url: String

  """
  account
  """
  userId: Int
}

"""
Course Enrollments temp table.  Enrollements are brought in here from Docebo first, before being merged into the course_enrollemnt table
"""
type CourseEnrollmentTemp {
  """
  course
  """
  courseId: Int
  createdAt: Datetime!

  """
  Primary key
  """
  id: Int!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  status
  """
  status: String
  updatedAt: Datetime!

  """
  url
  """
  url: String

  """
  account
  """
  userId: Int
}

"""
A condition to be used against `CourseEnrollmentTemp` object types. All fields
are tested for equality and combined with a logical ‘and.’
"""
input CourseEnrollmentTempCondition {
  """
  Checks for equality with the object’s `id` field.
  """
  id: Int
}

"""
An input for mutations affecting `CourseEnrollmentTemp`
"""
input CourseEnrollmentTempInput {
  """
  course
  """
  courseId: Int
  createdAt: Datetime

  """
  Primary key
  """
  id: Int

  """
  status
  """
  status: String
  updatedAt: Datetime

  """
  url
  """
  url: String

  """
  account
  """
  userId: Int
}

"""
Represents an update to a `CourseEnrollmentTemp`. Fields that are set will be updated.
"""
input CourseEnrollmentTempPatch {
  """
  course
  """
  courseId: Int
  createdAt: Datetime

  """
  Primary key
  """
  id: Int

  """
  status
  """
  status: String
  updatedAt: Datetime

  """
  url
  """
  url: String

  """
  account
  """
  userId: Int
}

"""
A connection to a list of `CourseEnrollmentTemp` values.
"""
type CourseEnrollmentTempsConnection {
  """
  A list of edges which contains the `CourseEnrollmentTemp` and cursor to aid in pagination.
  """
  edges: [CourseEnrollmentTempsEdge!]!

  """
  A list of `CourseEnrollmentTemp` objects.
  """
  nodes: [CourseEnrollmentTemp!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `CourseEnrollmentTemp` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `CourseEnrollmentTemp` edge in the connection.
"""
type CourseEnrollmentTempsEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `CourseEnrollmentTemp` at the end of the edge.
  """
  node: CourseEnrollmentTemp!
}

"""
Methods to use when ordering `CourseEnrollmentTemp`.
"""
enum CourseEnrollmentTempsOrderBy {
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
All input for the `courseEnrollmentUpdateByTemp` mutation.
"""
input CourseEnrollmentUpdateByTempInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""
The output of our `courseEnrollmentUpdateByTemp` mutation.
"""
type CourseEnrollmentUpdateByTempPayload {
  bigInt: BigInt

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `courseEnrollmentUpdate` mutation.
"""
input CourseEnrollmentUpdateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  enrollments: [CourseEnrollmentInput]
}

"""
The output of our `courseEnrollmentUpdate` mutation.
"""
type CourseEnrollmentUpdatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
A connection to a list of `CourseEnrollment` values.
"""
type CourseEnrollmentsConnection {
  """
  A list of edges which contains the `CourseEnrollment` and cursor to aid in pagination.
  """
  edges: [CourseEnrollmentsEdge!]!

  """
  A list of `CourseEnrollment` objects.
  """
  nodes: [CourseEnrollment!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `CourseEnrollment` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `CourseEnrollment` edge in the connection.
"""
type CourseEnrollmentsEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `CourseEnrollment` at the end of the edge.
  """
  node: CourseEnrollment!
}

"""
Methods to use when ordering `CourseEnrollment`.
"""
enum CourseEnrollmentsOrderBy {
  COURSE_ID_ASC
  COURSE_ID_DESC
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  USER_ID_ASC
  USER_ID_DESC
}

"""
An input for mutations affecting `Course`
"""
input CourseInput {
  """
  Docebo CourseId
  """
  courseId: Int
  createdAt: Datetime

  """
  Text description from Docebo
  """
  description: String

  """
  Primary key
  """
  id: Int

  """
  A reference to the image
  """
  image: String

  """
  A short name for the Course taken from Docebo
  """
  name: String

  """
  Promoted courses a listed higher than others
  """
  promoted: Boolean

  """
  Course slug
  """
  slug: String

  """
  technology
  """
  technology: String

  """
  Some text from Docebo indicating whether it is a webinar, classroom etc
  """
  trainingType: String
  updatedAt: Datetime
}

"""
Represents an update to a `Course`. Fields that are set will be updated.
"""
input CoursePatch {
  """
  Docebo CourseId
  """
  courseId: Int
  createdAt: Datetime

  """
  Text description from Docebo
  """
  description: String

  """
  Primary key
  """
  id: Int

  """
  A reference to the image
  """
  image: String

  """
  A short name for the Course taken from Docebo
  """
  name: String

  """
  Promoted courses a listed higher than others
  """
  promoted: Boolean

  """
  Course slug
  """
  slug: String

  """
  technology
  """
  technology: String

  """
  Some text from Docebo indicating whether it is a webinar, classroom etc
  """
  trainingType: String
  updatedAt: Datetime
}

"""
Course Sync Configuration
"""
type CourseSyncConfiguration {
  """
  account
  """
  configName: String

  """
  course
  """
  configValue: String
  createdAt: Datetime!

  """
  Primary key
  """
  id: Int!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  updatedAt: Datetime!
}

"""
A condition to be used against `CourseSyncConfiguration` object types. All
fields are tested for equality and combined with a logical ‘and.’
"""
input CourseSyncConfigurationCondition {
  """
  Checks for equality with the object’s `configName` field.
  """
  configName: String

  """
  Checks for equality with the object’s `id` field.
  """
  id: Int
}

"""
An input for mutations affecting `CourseSyncConfiguration`
"""
input CourseSyncConfigurationInput {
  """
  account
  """
  configName: String

  """
  course
  """
  configValue: String
  createdAt: Datetime

  """
  Primary key
  """
  id: Int
  updatedAt: Datetime
}

"""
Represents an update to a `CourseSyncConfiguration`. Fields that are set will be updated.
"""
input CourseSyncConfigurationPatch {
  """
  account
  """
  configName: String

  """
  course
  """
  configValue: String
  createdAt: Datetime

  """
  Primary key
  """
  id: Int
  updatedAt: Datetime
}

"""
A connection to a list of `CourseSyncConfiguration` values.
"""
type CourseSyncConfigurationsConnection {
  """
  A list of edges which contains the `CourseSyncConfiguration` and cursor to aid in pagination.
  """
  edges: [CourseSyncConfigurationsEdge!]!

  """
  A list of `CourseSyncConfiguration` objects.
  """
  nodes: [CourseSyncConfiguration!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `CourseSyncConfiguration` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `CourseSyncConfiguration` edge in the connection.
"""
type CourseSyncConfigurationsEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `CourseSyncConfiguration` at the end of the edge.
  """
  node: CourseSyncConfiguration!
}

"""
Methods to use when ordering `CourseSyncConfiguration`.
"""
enum CourseSyncConfigurationsOrderBy {
  CONFIG_NAME_ASC
  CONFIG_NAME_DESC
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A temporary training course that BMI offers in Docebo. Courses are brought from Docebo into this table before being merged into the course table.
"""
type CourseTemp {
  """
  Docebo CourseId
  """
  courseId: Int
  createdAt: Datetime!

  """
  Text description from Docebo
  """
  description: String

  """
  Primary key
  """
  id: Int!

  """
  A reference to the image
  """
  image: String

  """
  A short name for the Course taken from Docebo
  """
  name: String

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Promoted courses are intended to be listed higher than others. At time of writing, this data could not practically be acquired from the Docebo API
  """
  promoted: Boolean

  """
  Course slug
  """
  slug: String

  """
  technology
  """
  technology: String

  """
  Some text from Docebo indicating whether it is a webinar, classroom etc
  """
  trainingType: String
  updatedAt: Datetime!
}

"""
A condition to be used against `CourseTemp` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input CourseTempCondition {
  """
  Checks for equality with the object’s `id` field.
  """
  id: Int
}

"""
An input for mutations affecting `CourseTemp`
"""
input CourseTempInput {
  """
  Docebo CourseId
  """
  courseId: Int
  createdAt: Datetime

  """
  Text description from Docebo
  """
  description: String

  """
  Primary key
  """
  id: Int

  """
  A reference to the image
  """
  image: String

  """
  A short name for the Course taken from Docebo
  """
  name: String

  """
  Promoted courses are intended to be listed higher than others. At time of writing, this data could not practically be acquired from the Docebo API
  """
  promoted: Boolean

  """
  Course slug
  """
  slug: String

  """
  technology
  """
  technology: String

  """
  Some text from Docebo indicating whether it is a webinar, classroom etc
  """
  trainingType: String
  updatedAt: Datetime
}

"""
Represents an update to a `CourseTemp`. Fields that are set will be updated.
"""
input CourseTempPatch {
  """
  Docebo CourseId
  """
  courseId: Int
  createdAt: Datetime

  """
  Text description from Docebo
  """
  description: String

  """
  Primary key
  """
  id: Int

  """
  A reference to the image
  """
  image: String

  """
  A short name for the Course taken from Docebo
  """
  name: String

  """
  Promoted courses are intended to be listed higher than others. At time of writing, this data could not practically be acquired from the Docebo API
  """
  promoted: Boolean

  """
  Course slug
  """
  slug: String

  """
  technology
  """
  technology: String

  """
  Some text from Docebo indicating whether it is a webinar, classroom etc
  """
  trainingType: String
  updatedAt: Datetime
}

"""
A connection to a list of `CourseTemp` values.
"""
type CourseTempsConnection {
  """
  A list of edges which contains the `CourseTemp` and cursor to aid in pagination.
  """
  edges: [CourseTempsEdge!]!

  """
  A list of `CourseTemp` objects.
  """
  nodes: [CourseTemp!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `CourseTemp` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `CourseTemp` edge in the connection.
"""
type CourseTempsEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `CourseTemp` at the end of the edge.
  """
  node: CourseTemp!
}

"""
Methods to use when ordering `CourseTemp`.
"""
enum CourseTempsOrderBy {
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
All input for the `courseUpdateByTemp` mutation.
"""
input CourseUpdateByTempInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""
The output of our `courseUpdateByTemp` mutation.
"""
type CourseUpdateByTempPayload {
  bigInt: BigInt

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `courseUpdate` mutation.
"""
input CourseUpdateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  courses: [CourseInput]
}

"""
The output of our `courseUpdate` mutation.
"""
type CourseUpdatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
A connection to a list of `Course` values.
"""
type CoursesConnection {
  """
  A list of edges which contains the `Course` and cursor to aid in pagination.
  """
  edges: [CoursesEdge!]!

  """
  A list of `Course` objects.
  """
  nodes: [Course!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Course` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `Course` edge in the connection.
"""
type CoursesEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Course` at the end of the edge.
  """
  node: Course!
}

"""
Methods to use when ordering `Course`.
"""
enum CoursesOrderBy {
  COURSE_ID_ASC
  COURSE_ID_DESC
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
All input for the `createAccount` mutation.
"""
input CreateAccountInput {
  account: AccountInput

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  marketCode: String
}

"""
The output of our `createAccount` mutation.
"""
type CreateAccountPayload {
  account: Account

  """
  An edge for our `Account`. May be used by Relay 1.
  """
  accountEdge(
    """
    The method to use when ordering `Account`.
    """
    orderBy: [AccountsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AccountsEdge

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Market` that is related to this `Account`.
  """
  market: Market

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the create `Address` mutation.
"""
input CreateAddressInput {
  """
  The `Address` to be created by this mutation.
  """
  address: AddressInput!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""
The output of our create `Address` mutation.
"""
type CreateAddressPayload {
  """
  The `Address` that was created by this mutation.
  """
  address: Address

  """
  An edge for our `Address`. May be used by Relay 1.
  """
  addressEdge(
    """
    The method to use when ordering `Address`.
    """
    orderBy: [AddressesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AddressesEdge

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the create `Certification` mutation.
"""
input CreateCertificationInput {
  """
  The `Certification` to be created by this mutation.
  """
  certification: CertificationInput!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""
The output of our create `Certification` mutation.
"""
type CreateCertificationPayload {
  """
  The `Certification` that was created by this mutation.
  """
  certification: Certification

  """
  An edge for our `Certification`. May be used by Relay 1.
  """
  certificationEdge(
    """
    The method to use when ordering `Certification`.
    """
    orderBy: [CertificationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CertificationsEdge

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Account` that is related to this `Certification`.
  """
  doceboUser: Account

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the create `CompanyDocument` mutation.
"""
input CreateCompanyDocumentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `CompanyDocument` to be created by this mutation.
  """
  companyDocument: CompanyDocumentInput!
}

"""
The output of our create `CompanyDocument` mutation.
"""
type CreateCompanyDocumentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Company` that is related to this `CompanyDocument`.
  """
  company: Company

  """
  The `CompanyDocument` that was created by this mutation.
  """
  companyDocument: CompanyDocument

  """
  An edge for our `CompanyDocument`. May be used by Relay 1.
  """
  companyDocumentEdge(
    """
    The method to use when ordering `CompanyDocument`.
    """
    orderBy: [CompanyDocumentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompanyDocumentsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `createCompanyDocuments` mutation.
"""
input CreateCompanyDocumentsInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  documents: [CompanyDocumentInput]!
}

"""
The output of our `createCompanyDocuments` mutation.
"""
type CreateCompanyDocumentsPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  companyDocuments: [CompanyDocument!]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `createCompany` mutation.
"""
input CreateCompanyInput {
  aboutUs: String
  businessType: BusinessType

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  facebook: String
  linkedIn: String
  name: String
  ownerEmail: String
  ownerFullname: String
  ownerPhone: String
  phone: String
  publicEmail: String
  status: CompanyStatus
  taxNumber: String
  tier: Tier
  website: String
}

"""
All input for the create `CompanyMember` mutation.
"""
input CreateCompanyMemberInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `CompanyMember` to be created by this mutation.
  """
  companyMember: CompanyMemberInput!
}

"""
The output of our create `CompanyMember` mutation.
"""
type CreateCompanyMemberPayload {
  """
  Reads a single `Account` that is related to this `CompanyMember`.
  """
  account: Account

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Company` that is related to this `CompanyMember`.
  """
  company: Company

  """
  The `CompanyMember` that was created by this mutation.
  """
  companyMember: CompanyMember

  """
  An edge for our `CompanyMember`. May be used by Relay 1.
  """
  companyMemberEdge(
    """
    The method to use when ordering `CompanyMember`.
    """
    orderBy: [CompanyMembersOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompanyMembersEdge

  """
  Reads a single `Market` that is related to this `CompanyMember`.
  """
  market: Market

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the create `CompanyOperation` mutation.
"""
input CreateCompanyOperationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `CompanyOperation` to be created by this mutation.
  """
  companyOperation: CompanyOperationInput!
}

"""
The output of our create `CompanyOperation` mutation.
"""
type CreateCompanyOperationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Company` that is related to this `CompanyOperation`.
  """
  companyByCompany: Company

  """
  The `CompanyOperation` that was created by this mutation.
  """
  companyOperation: CompanyOperation

  """
  An edge for our `CompanyOperation`. May be used by Relay 1.
  """
  companyOperationEdge(
    """
    The method to use when ordering `CompanyOperation`.
    """
    orderBy: [CompanyOperationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompanyOperationsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
The output of our `createCompany` mutation.
"""
type CreateCompanyPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  company: Company

  """
  An edge for our `Company`. May be used by Relay 1.
  """
  companyEdge(
    """
    The method to use when ordering `Company`.
    """
    orderBy: [CompaniesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompaniesEdge

  """
  Reads a single `Market` that is related to this `Company`.
  """
  market: Market

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Address` that is related to this `Company`.
  """
  registeredAddress: Address

  """
  Reads a single `Address` that is related to this `Company`.
  """
  tradingAddress: Address
}

"""
All input for the create `CourseCatalogue` mutation.
"""
input CreateCourseCatalogueInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `CourseCatalogue` to be created by this mutation.
  """
  courseCatalogue: CourseCatalogueInput!
}

"""
The output of our create `CourseCatalogue` mutation.
"""
type CreateCourseCataloguePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Course` that is related to this `CourseCatalogue`.
  """
  course: Course

  """
  The `CourseCatalogue` that was created by this mutation.
  """
  courseCatalogue: CourseCatalogue

  """
  An edge for our `CourseCatalogue`. May be used by Relay 1.
  """
  courseCatalogueEdge(
    """
    The method to use when ordering `CourseCatalogue`.
    """
    orderBy: [CourseCataloguesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CourseCataloguesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the create `CourseCatalogueTemp` mutation.
"""
input CreateCourseCatalogueTempInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `CourseCatalogueTemp` to be created by this mutation.
  """
  courseCatalogueTemp: CourseCatalogueTempInput!
}

"""
The output of our create `CourseCatalogueTemp` mutation.
"""
type CreateCourseCatalogueTempPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `CourseCatalogueTemp` that was created by this mutation.
  """
  courseCatalogueTemp: CourseCatalogueTemp

  """
  An edge for our `CourseCatalogueTemp`. May be used by Relay 1.
  """
  courseCatalogueTempEdge(
    """
    The method to use when ordering `CourseCatalogueTemp`.
    """
    orderBy: [CourseCatalogueTempsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CourseCatalogueTempsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the create `CourseEnrollment` mutation.
"""
input CreateCourseEnrollmentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `CourseEnrollment` to be created by this mutation.
  """
  courseEnrollment: CourseEnrollmentInput!
}

"""
The output of our create `CourseEnrollment` mutation.
"""
type CreateCourseEnrollmentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Course` that is related to this `CourseEnrollment`.
  """
  course: Course

  """
  The `CourseEnrollment` that was created by this mutation.
  """
  courseEnrollment: CourseEnrollment

  """
  An edge for our `CourseEnrollment`. May be used by Relay 1.
  """
  courseEnrollmentEdge(
    """
    The method to use when ordering `CourseEnrollment`.
    """
    orderBy: [CourseEnrollmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CourseEnrollmentsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the create `CourseEnrollmentTemp` mutation.
"""
input CreateCourseEnrollmentTempInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `CourseEnrollmentTemp` to be created by this mutation.
  """
  courseEnrollmentTemp: CourseEnrollmentTempInput!
}

"""
The output of our create `CourseEnrollmentTemp` mutation.
"""
type CreateCourseEnrollmentTempPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `CourseEnrollmentTemp` that was created by this mutation.
  """
  courseEnrollmentTemp: CourseEnrollmentTemp

  """
  An edge for our `CourseEnrollmentTemp`. May be used by Relay 1.
  """
  courseEnrollmentTempEdge(
    """
    The method to use when ordering `CourseEnrollmentTemp`.
    """
    orderBy: [CourseEnrollmentTempsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CourseEnrollmentTempsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the create `Course` mutation.
"""
input CreateCourseInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `Course` to be created by this mutation.
  """
  course: CourseInput!
}

"""
The output of our create `Course` mutation.
"""
type CreateCoursePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Course` that was created by this mutation.
  """
  course: Course

  """
  An edge for our `Course`. May be used by Relay 1.
  """
  courseEdge(
    """
    The method to use when ordering `Course`.
    """
    orderBy: [CoursesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CoursesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the create `CourseSyncConfiguration` mutation.
"""
input CreateCourseSyncConfigurationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `CourseSyncConfiguration` to be created by this mutation.
  """
  courseSyncConfiguration: CourseSyncConfigurationInput!
}

"""
The output of our create `CourseSyncConfiguration` mutation.
"""
type CreateCourseSyncConfigurationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `CourseSyncConfiguration` that was created by this mutation.
  """
  courseSyncConfiguration: CourseSyncConfiguration

  """
  An edge for our `CourseSyncConfiguration`. May be used by Relay 1.
  """
  courseSyncConfigurationEdge(
    """
    The method to use when ordering `CourseSyncConfiguration`.
    """
    orderBy: [CourseSyncConfigurationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CourseSyncConfigurationsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the create `CourseTemp` mutation.
"""
input CreateCourseTempInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `CourseTemp` to be created by this mutation.
  """
  courseTemp: CourseTempInput!
}

"""
The output of our create `CourseTemp` mutation.
"""
type CreateCourseTempPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `CourseTemp` that was created by this mutation.
  """
  courseTemp: CourseTemp

  """
  An edge for our `CourseTemp`. May be used by Relay 1.
  """
  courseTempEdge(
    """
    The method to use when ordering `CourseTemp`.
    """
    orderBy: [CourseTempsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CourseTempsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the create `DoceboTier` mutation.
"""
input CreateDoceboTierInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `DoceboTier` to be created by this mutation.
  """
  doceboTier: DoceboTierInput!
}

"""
The output of our create `DoceboTier` mutation.
"""
type CreateDoceboTierPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `DoceboTier` that was created by this mutation.
  """
  doceboTier: DoceboTier

  """
  An edge for our `DoceboTier`. May be used by Relay 1.
  """
  doceboTierEdge(
    """
    The method to use when ordering `DoceboTier`.
    """
    orderBy: [DoceboTiersOrderBy!] = [PRIMARY_KEY_ASC]
  ): DoceboTiersEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the create `EvidenceItem` mutation.
"""
input CreateEvidenceItemInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `EvidenceItem` to be created by this mutation.
  """
  evidenceItem: EvidenceItemInput!
}

"""
The output of our create `EvidenceItem` mutation.
"""
type CreateEvidenceItemPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `EvidenceItem` that was created by this mutation.
  """
  evidenceItem: EvidenceItem

  """
  An edge for our `EvidenceItem`. May be used by Relay 1.
  """
  evidenceItemEdge(
    """
    The method to use when ordering `EvidenceItem`.
    """
    orderBy: [EvidenceItemsOrderBy!] = [PRIMARY_KEY_ASC]
  ): EvidenceItemsEdge

  """
  Reads a single `Guarantee` that is related to this `EvidenceItem`.
  """
  guarantee: Guarantee

  """
  Reads a single `Project` that is related to this `EvidenceItem`.
  """
  project: Project

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Account` that is related to this `EvidenceItem`.
  """
  uploaderAccount: Account
}

"""
All input for the create `Guarantee` mutation.
"""
input CreateGuaranteeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `Guarantee` to be created by this mutation.
  """
  guarantee: GuaranteeInput!
}

"""
The output of our create `Guarantee` mutation.
"""
type CreateGuaranteePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Guarantee` that was created by this mutation.
  """
  guarantee: Guarantee

  """
  An edge for our `Guarantee`. May be used by Relay 1.
  """
  guaranteeEdge(
    """
    The method to use when ordering `Guarantee`.
    """
    orderBy: [GuaranteesOrderBy!] = [PRIMARY_KEY_ASC]
  ): GuaranteesEdge

  """
  Reads a single `Product` that is related to this `Guarantee`.
  """
  productByProductBmiRef: Product

  """
  Reads a single `Project` that is related to this `Guarantee`.
  """
  project: Project

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Account` that is related to this `Guarantee`.
  """
  requestorAccount: Account

  """
  Reads a single `Account` that is related to this `Guarantee`.
  """
  reviewerAccount: Account

  """
  Reads a single `System` that is related to this `Guarantee`.
  """
  systemBySystemBmiRef: System
}

"""
All input for the create `Market` mutation.
"""
input CreateMarketInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `Market` to be created by this mutation.
  """
  market: MarketInput!
}

"""
The output of our create `Market` mutation.
"""
type CreateMarketPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Market` that was created by this mutation.
  """
  market: Market

  """
  An edge for our `Market`. May be used by Relay 1.
  """
  marketEdge(
    """
    The method to use when ordering `Market`.
    """
    orderBy: [MarketsOrderBy!] = [PRIMARY_KEY_ASC]
  ): MarketsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the create `Note` mutation.
"""
input CreateNoteInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `Note` to be created by this mutation.
  """
  note: NoteInput!
}

"""
The output of our create `Note` mutation.
"""
type CreateNotePayload {
  """
  Reads a single `Account` that is related to this `Note`.
  """
  author: Account

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Note` that was created by this mutation.
  """
  note: Note

  """
  An edge for our `Note`. May be used by Relay 1.
  """
  noteEdge(
    """
    The method to use when ordering `Note`.
    """
    orderBy: [NotesOrderBy!] = [PRIMARY_KEY_ASC]
  ): NotesEdge

  """
  Reads a single `Project` that is related to this `Note`.
  """
  project: Project

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the create `Notification` mutation.
"""
input CreateNotificationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `Notification` to be created by this mutation.
  """
  notification: NotificationInput!
}

"""
The output of our create `Notification` mutation.
"""
type CreateNotificationPayload {
  """
  Reads a single `Account` that is related to this `Notification`.
  """
  account: Account

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Notification` that was created by this mutation.
  """
  notification: Notification

  """
  An edge for our `Notification`. May be used by Relay 1.
  """
  notificationEdge(
    """
    The method to use when ordering `Notification`.
    """
    orderBy: [NotificationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): NotificationsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the create `Product` mutation.
"""
input CreateProductInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `Product` to be created by this mutation.
  """
  product: ProductInput!
}

"""
The output of our create `Product` mutation.
"""
type CreateProductPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Market` that is related to this `Product`.
  """
  market: Market

  """
  The `Product` that was created by this mutation.
  """
  product: Product

  """
  An edge for our `Product`. May be used by Relay 1.
  """
  productEdge(
    """
    The method to use when ordering `Product`.
    """
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProductsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the create `Project` mutation.
"""
input CreateProjectInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `Project` to be created by this mutation.
  """
  project: ProjectInput!
}

"""
All input for the create `ProjectMember` mutation.
"""
input CreateProjectMemberInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `ProjectMember` to be created by this mutation.
  """
  projectMember: ProjectMemberInput!
}

"""
The output of our create `ProjectMember` mutation.
"""
type CreateProjectMemberPayload {
  """
  Reads a single `Account` that is related to this `ProjectMember`.
  """
  account: Account

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Project` that is related to this `ProjectMember`.
  """
  project: Project

  """
  The `ProjectMember` that was created by this mutation.
  """
  projectMember: ProjectMember

  """
  An edge for our `ProjectMember`. May be used by Relay 1.
  """
  projectMemberEdge(
    """
    The method to use when ordering `ProjectMember`.
    """
    orderBy: [ProjectMembersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectMembersEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
The output of our create `Project` mutation.
"""
type CreateProjectPayload {
  """
  Reads a single `Address` that is related to this `Project`.
  """
  buildingOwnerAddress: Address

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Company` that is related to this `Project`.
  """
  company: Company

  """
  The `Project` that was created by this mutation.
  """
  project: Project

  """
  An edge for our `Project`. May be used by Relay 1.
  """
  projectEdge(
    """
    The method to use when ordering `Project`.
    """
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Address` that is related to this `Project`.
  """
  siteAddress: Address
}

"""
All input for the create `System` mutation.
"""
input CreateSystemInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `System` to be created by this mutation.
  """
  system: SystemInput!
}

"""
All input for the create `SystemMember` mutation.
"""
input CreateSystemMemberInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `SystemMember` to be created by this mutation.
  """
  systemMember: SystemMemberInput!
}

"""
The output of our create `SystemMember` mutation.
"""
type CreateSystemMemberPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Market` that is related to this `SystemMember`.
  """
  market: Market

  """
  Reads a single `Product` that is related to this `SystemMember`.
  """
  productByProductBmiRef: Product

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `System` that is related to this `SystemMember`.
  """
  systemBySystemBmiRef: System

  """
  The `SystemMember` that was created by this mutation.
  """
  systemMember: SystemMember

  """
  An edge for our `SystemMember`. May be used by Relay 1.
  """
  systemMemberEdge(
    """
    The method to use when ordering `SystemMember`.
    """
    orderBy: [SystemMembersOrderBy!] = [PRIMARY_KEY_ASC]
  ): SystemMembersEdge
}

"""
The output of our create `System` mutation.
"""
type CreateSystemPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Market` that is related to this `System`.
  """
  market: Market

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  The `System` that was created by this mutation.
  """
  system: System

  """
  An edge for our `System`. May be used by Relay 1.
  """
  systemEdge(
    """
    The method to use when ordering `System`.
    """
    orderBy: [SystemsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SystemsEdge
}

"""
A location in a connection that can be used for resuming pagination.
"""
scalar Cursor

enum CustomEvidenceCategoryKey {
  FLAT_BASE
  FLAT_DETAILS
  FLAT_FIXINGS
  FLAT_INSULATION
  FLAT_LAYER
  FLAT_PENETRATIONS
  FLAT_PLAN
  FLAT_SAFETY
  FLAT_TOP
  FLAT_VENTILATION
  MISC_1
  MISC_2
  MISC_3
  MISC_4
  PITCHED_BASE
  PITCHED_DETAILS
  PITCHED_FIXINGS
  PITCHED_INSPECTION
  PITCHED_INSULATION
  PITCHED_PENETRATIONS
  PITCHED_PLAN
  PITCHED_SAFETY
  PITCHED_TILES
  PITCHED_UNDERLAY
  PITCHED_VENTILATION
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z,
    compliant with the 'date-time' format outlined in section 5.6 of
    the RFC 3339 profile of the ISO 8601 standard for representation
    of dates and times using the Gregorian calendar.
"""
scalar DateTime

"""
A point in time as described by the [ISO
8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
"""
scalar Datetime

"""
A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’
"""
input DatetimeFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Datetime

  """
  Equal to the specified value.
  """
  equalTo: Datetime

  """
  Greater than the specified value.
  """
  greaterThan: Datetime

  """
  Greater than or equal to the specified value.
  """
  greaterThanOrEqualTo: Datetime

  """
  Included in the specified list.
  """
  in: [Datetime!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """
  Less than the specified value.
  """
  lessThan: Datetime

  """
  Less than or equal to the specified value.
  """
  lessThanOrEqualTo: Datetime

  """
  Equal to the specified value, treating null like an ordinary value.
  """
  notDistinctFrom: Datetime

  """
  Not equal to the specified value.
  """
  notEqualTo: Datetime

  """
  Not included in the specified list.
  """
  notIn: [Datetime!]
}

"""
All input for the `deleteAccountByDoceboUserId` mutation.
"""
input DeleteAccountByDoceboUserIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  User account in Docebo
  """
  doceboUserId: Int!
}

"""
All input for the `deleteAccountByEmail` mutation.
"""
input DeleteAccountByEmailInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The email address associated with the account
  """
  email: String!
}

"""
All input for the `deleteAccountByNodeId` mutation.
"""
input DeleteAccountByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Account` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteAccount` mutation.
"""
input DeleteAccountInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
The output of our delete `Account` mutation.
"""
type DeleteAccountPayload {
  """
  The `Account` that was deleted by this mutation.
  """
  account: Account

  """
  An edge for our `Account`. May be used by Relay 1.
  """
  accountEdge(
    """
    The method to use when ordering `Account`.
    """
    orderBy: [AccountsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AccountsEdge

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedAccountNodeId: ID

  """
  Reads a single `Market` that is related to this `Account`.
  """
  market: Market

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `deleteAddressByNodeId` mutation.
"""
input DeleteAddressByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Address` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteAddress` mutation.
"""
input DeleteAddressInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
The output of our delete `Address` mutation.
"""
type DeleteAddressPayload {
  """
  The `Address` that was deleted by this mutation.
  """
  address: Address

  """
  An edge for our `Address`. May be used by Relay 1.
  """
  addressEdge(
    """
    The method to use when ordering `Address`.
    """
    orderBy: [AddressesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AddressesEdge

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedAddressNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `deleteCertificationByNodeId` mutation.
"""
input DeleteCertificationByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Certification` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteCertification` mutation.
"""
input DeleteCertificationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
The output of our delete `Certification` mutation.
"""
type DeleteCertificationPayload {
  """
  The `Certification` that was deleted by this mutation.
  """
  certification: Certification

  """
  An edge for our `Certification`. May be used by Relay 1.
  """
  certificationEdge(
    """
    The method to use when ordering `Certification`.
    """
    orderBy: [CertificationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CertificationsEdge

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedCertificationNodeId: ID

  """
  Reads a single `Account` that is related to this `Certification`.
  """
  doceboUser: Account

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `deleteCompanyByMarketIdAndName` mutation.
"""
input DeleteCompanyByMarketIdAndNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  fk
  """
  marketId: Int!

  """
  The registered name of the Company
  """
  name: String!
}

"""
All input for the `deleteCompanyByNodeId` mutation.
"""
input DeleteCompanyByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Company` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteCompanyByReferenceNumber` mutation.
"""
input DeleteCompanyByReferenceNumberInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: Int!
}

"""
All input for the `deleteCompanyDocumentByNodeId` mutation.
"""
input DeleteCompanyDocumentByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CompanyDocument` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteCompanyDocument` mutation.
"""
input DeleteCompanyDocumentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
The output of our delete `CompanyDocument` mutation.
"""
type DeleteCompanyDocumentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Company` that is related to this `CompanyDocument`.
  """
  company: Company

  """
  The `CompanyDocument` that was deleted by this mutation.
  """
  companyDocument: CompanyDocument

  """
  An edge for our `CompanyDocument`. May be used by Relay 1.
  """
  companyDocumentEdge(
    """
    The method to use when ordering `CompanyDocument`.
    """
    orderBy: [CompanyDocumentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompanyDocumentsEdge
  deletedCompanyDocumentNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `deleteCompany` mutation.
"""
input DeleteCompanyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
All input for the `deleteCompanyMemberByMarketIdAndAccountIdAndCompanyId` mutation.
"""
input DeleteCompanyMemberByMarketIdAndAccountIdAndCompanyIdInput {
  """
  fk
  """
  accountId: Int!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  fk
  """
  companyId: Int!

  """
  fk
  """
  marketId: Int!
}

"""
All input for the `deleteCompanyMemberByNodeId` mutation.
"""
input DeleteCompanyMemberByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CompanyMember` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteCompanyMember` mutation.
"""
input DeleteCompanyMemberInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
The output of our delete `CompanyMember` mutation.
"""
type DeleteCompanyMemberPayload {
  """
  Reads a single `Account` that is related to this `CompanyMember`.
  """
  account: Account

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Company` that is related to this `CompanyMember`.
  """
  company: Company

  """
  The `CompanyMember` that was deleted by this mutation.
  """
  companyMember: CompanyMember

  """
  An edge for our `CompanyMember`. May be used by Relay 1.
  """
  companyMemberEdge(
    """
    The method to use when ordering `CompanyMember`.
    """
    orderBy: [CompanyMembersOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompanyMembersEdge
  deletedCompanyMemberNodeId: ID

  """
  Reads a single `Market` that is related to this `CompanyMember`.
  """
  market: Market

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `deleteCompanyOperationByNodeId` mutation.
"""
input DeleteCompanyOperationByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CompanyOperation` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteCompanyOperation` mutation.
"""
input DeleteCompanyOperationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
The output of our delete `CompanyOperation` mutation.
"""
type DeleteCompanyOperationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Company` that is related to this `CompanyOperation`.
  """
  companyByCompany: Company

  """
  The `CompanyOperation` that was deleted by this mutation.
  """
  companyOperation: CompanyOperation

  """
  An edge for our `CompanyOperation`. May be used by Relay 1.
  """
  companyOperationEdge(
    """
    The method to use when ordering `CompanyOperation`.
    """
    orderBy: [CompanyOperationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompanyOperationsEdge
  deletedCompanyOperationNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
The output of our delete `Company` mutation.
"""
type DeleteCompanyPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Company` that was deleted by this mutation.
  """
  company: Company

  """
  An edge for our `Company`. May be used by Relay 1.
  """
  companyEdge(
    """
    The method to use when ordering `Company`.
    """
    orderBy: [CompaniesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompaniesEdge
  deletedCompanyNodeId: ID

  """
  Reads a single `Market` that is related to this `Company`.
  """
  market: Market

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Address` that is related to this `Company`.
  """
  registeredAddress: Address

  """
  Reads a single `Address` that is related to this `Company`.
  """
  tradingAddress: Address
}

"""
All input for the `deleteCourseByCourseId` mutation.
"""
input DeleteCourseByCourseIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Docebo CourseId
  """
  courseId: Int!
}

"""
All input for the `deleteCourseByNodeId` mutation.
"""
input DeleteCourseByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Course` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteCourseCatalogueByCatalogueIdAndCourseId` mutation.
"""
input DeleteCourseCatalogueByCatalogueIdAndCourseIdInput {
  """
  market
  """
  catalogueId: Int!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  fk
  """
  courseId: Int!
}

"""
All input for the `deleteCourseCatalogueByNodeId` mutation.
"""
input DeleteCourseCatalogueByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CourseCatalogue` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteCourseCatalogue` mutation.
"""
input DeleteCourseCatalogueInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
The output of our delete `CourseCatalogue` mutation.
"""
type DeleteCourseCataloguePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Course` that is related to this `CourseCatalogue`.
  """
  course: Course

  """
  The `CourseCatalogue` that was deleted by this mutation.
  """
  courseCatalogue: CourseCatalogue

  """
  An edge for our `CourseCatalogue`. May be used by Relay 1.
  """
  courseCatalogueEdge(
    """
    The method to use when ordering `CourseCatalogue`.
    """
    orderBy: [CourseCataloguesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CourseCataloguesEdge
  deletedCourseCatalogueNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `deleteCourseCatalogueTempByNodeId` mutation.
"""
input DeleteCourseCatalogueTempByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CourseCatalogueTemp` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteCourseCatalogueTemp` mutation.
"""
input DeleteCourseCatalogueTempInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
The output of our delete `CourseCatalogueTemp` mutation.
"""
type DeleteCourseCatalogueTempPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `CourseCatalogueTemp` that was deleted by this mutation.
  """
  courseCatalogueTemp: CourseCatalogueTemp

  """
  An edge for our `CourseCatalogueTemp`. May be used by Relay 1.
  """
  courseCatalogueTempEdge(
    """
    The method to use when ordering `CourseCatalogueTemp`.
    """
    orderBy: [CourseCatalogueTempsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CourseCatalogueTempsEdge
  deletedCourseCatalogueTempNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `deleteCourseEnrollmentByNodeId` mutation.
"""
input DeleteCourseEnrollmentByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CourseEnrollment` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteCourseEnrollmentByUserIdAndCourseId` mutation.
"""
input DeleteCourseEnrollmentByUserIdAndCourseIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  fk
  """
  courseId: Int!

  """
  account
  """
  userId: Int!
}

"""
All input for the `deleteCourseEnrollment` mutation.
"""
input DeleteCourseEnrollmentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
The output of our delete `CourseEnrollment` mutation.
"""
type DeleteCourseEnrollmentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Course` that is related to this `CourseEnrollment`.
  """
  course: Course

  """
  The `CourseEnrollment` that was deleted by this mutation.
  """
  courseEnrollment: CourseEnrollment

  """
  An edge for our `CourseEnrollment`. May be used by Relay 1.
  """
  courseEnrollmentEdge(
    """
    The method to use when ordering `CourseEnrollment`.
    """
    orderBy: [CourseEnrollmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CourseEnrollmentsEdge
  deletedCourseEnrollmentNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `deleteCourseEnrollmentTempByNodeId` mutation.
"""
input DeleteCourseEnrollmentTempByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CourseEnrollmentTemp` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteCourseEnrollmentTemp` mutation.
"""
input DeleteCourseEnrollmentTempInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
The output of our delete `CourseEnrollmentTemp` mutation.
"""
type DeleteCourseEnrollmentTempPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `CourseEnrollmentTemp` that was deleted by this mutation.
  """
  courseEnrollmentTemp: CourseEnrollmentTemp

  """
  An edge for our `CourseEnrollmentTemp`. May be used by Relay 1.
  """
  courseEnrollmentTempEdge(
    """
    The method to use when ordering `CourseEnrollmentTemp`.
    """
    orderBy: [CourseEnrollmentTempsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CourseEnrollmentTempsEdge
  deletedCourseEnrollmentTempNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `deleteCourse` mutation.
"""
input DeleteCourseInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
The output of our delete `Course` mutation.
"""
type DeleteCoursePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Course` that was deleted by this mutation.
  """
  course: Course

  """
  An edge for our `Course`. May be used by Relay 1.
  """
  courseEdge(
    """
    The method to use when ordering `Course`.
    """
    orderBy: [CoursesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CoursesEdge
  deletedCourseNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `deleteCourseSyncConfigurationByConfigName` mutation.
"""
input DeleteCourseSyncConfigurationByConfigNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  account
  """
  configName: String!
}

"""
All input for the `deleteCourseSyncConfigurationByNodeId` mutation.
"""
input DeleteCourseSyncConfigurationByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CourseSyncConfiguration` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteCourseSyncConfiguration` mutation.
"""
input DeleteCourseSyncConfigurationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
The output of our delete `CourseSyncConfiguration` mutation.
"""
type DeleteCourseSyncConfigurationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `CourseSyncConfiguration` that was deleted by this mutation.
  """
  courseSyncConfiguration: CourseSyncConfiguration

  """
  An edge for our `CourseSyncConfiguration`. May be used by Relay 1.
  """
  courseSyncConfigurationEdge(
    """
    The method to use when ordering `CourseSyncConfiguration`.
    """
    orderBy: [CourseSyncConfigurationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CourseSyncConfigurationsEdge
  deletedCourseSyncConfigurationNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `deleteCourseTempByNodeId` mutation.
"""
input DeleteCourseTempByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CourseTemp` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteCourseTemp` mutation.
"""
input DeleteCourseTempInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
The output of our delete `CourseTemp` mutation.
"""
type DeleteCourseTempPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `CourseTemp` that was deleted by this mutation.
  """
  courseTemp: CourseTemp

  """
  An edge for our `CourseTemp`. May be used by Relay 1.
  """
  courseTempEdge(
    """
    The method to use when ordering `CourseTemp`.
    """
    orderBy: [CourseTempsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CourseTempsEdge
  deletedCourseTempNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `deleteDoceboTierByMarketIdAndTierCode` mutation.
"""
input DeleteDoceboTierByMarketIdAndTierCodeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  marketId: Int!
  tierCode: Tier!
}

"""
All input for the `deleteDoceboTierByNodeId` mutation.
"""
input DeleteDoceboTierByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `DoceboTier` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteDoceboTier` mutation.
"""
input DeleteDoceboTierInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""
The output of our delete `DoceboTier` mutation.
"""
type DeleteDoceboTierPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedDoceboTierNodeId: ID

  """
  The `DoceboTier` that was deleted by this mutation.
  """
  doceboTier: DoceboTier

  """
  An edge for our `DoceboTier`. May be used by Relay 1.
  """
  doceboTierEdge(
    """
    The method to use when ordering `DoceboTier`.
    """
    orderBy: [DoceboTiersOrderBy!] = [PRIMARY_KEY_ASC]
  ): DoceboTiersEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `deleteEvidenceItemByNodeId` mutation.
"""
input DeleteEvidenceItemByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `EvidenceItem` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteEvidenceItem` mutation.
"""
input DeleteEvidenceItemInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
The output of our delete `EvidenceItem` mutation.
"""
type DeleteEvidenceItemPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedEvidenceItemNodeId: ID

  """
  The `EvidenceItem` that was deleted by this mutation.
  """
  evidenceItem: EvidenceItem

  """
  An edge for our `EvidenceItem`. May be used by Relay 1.
  """
  evidenceItemEdge(
    """
    The method to use when ordering `EvidenceItem`.
    """
    orderBy: [EvidenceItemsOrderBy!] = [PRIMARY_KEY_ASC]
  ): EvidenceItemsEdge

  """
  Reads a single `Guarantee` that is related to this `EvidenceItem`.
  """
  guarantee: Guarantee

  """
  Reads a single `Project` that is related to this `EvidenceItem`.
  """
  project: Project

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Account` that is related to this `EvidenceItem`.
  """
  uploaderAccount: Account
}

"""
All input for the `deleteGuaranteeByBmiReferenceId` mutation.
"""
input DeleteGuaranteeByBmiReferenceIdInput {
  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""
All input for the `deleteGuaranteeByNodeId` mutation.
"""
input DeleteGuaranteeByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Guarantee` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteGuarantee` mutation.
"""
input DeleteGuaranteeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key - starts at 6100
  """
  id: Int!
}

"""
The output of our delete `Guarantee` mutation.
"""
type DeleteGuaranteePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedGuaranteeNodeId: ID

  """
  The `Guarantee` that was deleted by this mutation.
  """
  guarantee: Guarantee

  """
  An edge for our `Guarantee`. May be used by Relay 1.
  """
  guaranteeEdge(
    """
    The method to use when ordering `Guarantee`.
    """
    orderBy: [GuaranteesOrderBy!] = [PRIMARY_KEY_ASC]
  ): GuaranteesEdge

  """
  Reads a single `Product` that is related to this `Guarantee`.
  """
  productByProductBmiRef: Product

  """
  Reads a single `Project` that is related to this `Guarantee`.
  """
  project: Project

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Account` that is related to this `Guarantee`.
  """
  requestorAccount: Account

  """
  Reads a single `Account` that is related to this `Guarantee`.
  """
  reviewerAccount: Account

  """
  Reads a single `System` that is related to this `Guarantee`.
  """
  systemBySystemBmiRef: System
}

"""
All input for the `deleteInvitationByNodeId` mutation.
"""
input DeleteInvitationByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Invitation` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteInvitation` mutation.
"""
input DeleteInvitationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
The output of our delete `Invitation` mutation.
"""
type DeleteInvitationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Company` that is related to this `Invitation`.
  """
  company: Company
  deletedInvitationNodeId: ID

  """
  The `Invitation` that was deleted by this mutation.
  """
  invitation: Invitation

  """
  An edge for our `Invitation`. May be used by Relay 1.
  """
  invitationEdge(
    """
    The method to use when ordering `Invitation`.
    """
    orderBy: [InvitationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): InvitationsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Account` that is related to this `Invitation`.
  """
  senderAccount: Account
}

"""
All input for the `deleteMarketByDoceboCatalogueId` mutation.
"""
input DeleteMarketByDoceboCatalogueIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The default catalogue for the Market.  All users in the Market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int!
}

"""
All input for the `deleteMarketByDomain` mutation.
"""
input DeleteMarketByDomainInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  the country code used for example as the subdomain
  """
  domain: String!
}

"""
All input for the `deleteMarketByNodeId` mutation.
"""
input DeleteMarketByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Market` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteMarket` mutation.
"""
input DeleteMarketInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
The output of our delete `Market` mutation.
"""
type DeleteMarketPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedMarketNodeId: ID

  """
  The `Market` that was deleted by this mutation.
  """
  market: Market

  """
  An edge for our `Market`. May be used by Relay 1.
  """
  marketEdge(
    """
    The method to use when ordering `Market`.
    """
    orderBy: [MarketsOrderBy!] = [PRIMARY_KEY_ASC]
  ): MarketsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `deleteNoteByNodeId` mutation.
"""
input DeleteNoteByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Note` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteNote` mutation.
"""
input DeleteNoteInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
The output of our delete `Note` mutation.
"""
type DeleteNotePayload {
  """
  Reads a single `Account` that is related to this `Note`.
  """
  author: Account

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedNoteNodeId: ID

  """
  The `Note` that was deleted by this mutation.
  """
  note: Note

  """
  An edge for our `Note`. May be used by Relay 1.
  """
  noteEdge(
    """
    The method to use when ordering `Note`.
    """
    orderBy: [NotesOrderBy!] = [PRIMARY_KEY_ASC]
  ): NotesEdge

  """
  Reads a single `Project` that is related to this `Note`.
  """
  project: Project

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `deleteNotificationByNodeId` mutation.
"""
input DeleteNotificationByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Notification` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteNotification` mutation.
"""
input DeleteNotificationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
The output of our delete `Notification` mutation.
"""
type DeleteNotificationPayload {
  """
  Reads a single `Account` that is related to this `Notification`.
  """
  account: Account

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedNotificationNodeId: ID

  """
  The `Notification` that was deleted by this mutation.
  """
  notification: Notification

  """
  An edge for our `Notification`. May be used by Relay 1.
  """
  notificationEdge(
    """
    The method to use when ordering `Notification`.
    """
    orderBy: [NotificationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): NotificationsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `deleteProductByBmiRef` mutation.
"""
input DeleteProductByBmiRefInput {
  """
  A unique reference for the product known to BMI
  """
  bmiRef: String!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""
All input for the `deleteProductByNodeId` mutation.
"""
input DeleteProductByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Product` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteProduct` mutation.
"""
input DeleteProductInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
The output of our delete `Product` mutation.
"""
type DeleteProductPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedProductNodeId: ID

  """
  Reads a single `Market` that is related to this `Product`.
  """
  market: Market

  """
  The `Product` that was deleted by this mutation.
  """
  product: Product

  """
  An edge for our `Product`. May be used by Relay 1.
  """
  productEdge(
    """
    The method to use when ordering `Product`.
    """
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProductsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `deleteProjectByNodeId` mutation.
"""
input DeleteProjectByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Project` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteProject` mutation.
"""
input DeleteProjectInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
All input for the `deleteProjectMemberByNodeId` mutation.
"""
input DeleteProjectMemberByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ProjectMember` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteProjectMember` mutation.
"""
input DeleteProjectMemberInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
The output of our delete `ProjectMember` mutation.
"""
type DeleteProjectMemberPayload {
  """
  Reads a single `Account` that is related to this `ProjectMember`.
  """
  account: Account

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedProjectMemberNodeId: ID

  """
  Reads a single `Project` that is related to this `ProjectMember`.
  """
  project: Project

  """
  The `ProjectMember` that was deleted by this mutation.
  """
  projectMember: ProjectMember

  """
  An edge for our `ProjectMember`. May be used by Relay 1.
  """
  projectMemberEdge(
    """
    The method to use when ordering `ProjectMember`.
    """
    orderBy: [ProjectMembersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectMembersEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
The output of our delete `Project` mutation.
"""
type DeleteProjectPayload {
  """
  Reads a single `Address` that is related to this `Project`.
  """
  buildingOwnerAddress: Address

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Company` that is related to this `Project`.
  """
  company: Company
  deletedProjectNodeId: ID

  """
  The `Project` that was deleted by this mutation.
  """
  project: Project

  """
  An edge for our `Project`. May be used by Relay 1.
  """
  projectEdge(
    """
    The method to use when ordering `Project`.
    """
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Address` that is related to this `Project`.
  """
  siteAddress: Address
}

"""
All input for the `deleteSystemByBmiRef` mutation.
"""
input DeleteSystemByBmiRefInput {
  """
  A unique reference for the system known to BMI
  """
  bmiRef: String!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""
All input for the `deleteSystemByNodeId` mutation.
"""
input DeleteSystemByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `System` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteSystem` mutation.
"""
input DeleteSystemInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
All input for the `deleteSystemMemberByNodeId` mutation.
"""
input DeleteSystemMemberByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `SystemMember` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteSystemMemberBySystemBmiRefAndProductBmiRefAndMarketId` mutation.
"""
input DeleteSystemMemberBySystemBmiRefAndProductBmiRefAndMarketIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  fk
  """
  marketId: Int!

  """
  fk
  """
  productBmiRef: String!

  """
  fk
  """
  systemBmiRef: String!
}

"""
All input for the `deleteSystemMember` mutation.
"""
input DeleteSystemMemberInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
The output of our delete `SystemMember` mutation.
"""
type DeleteSystemMemberPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedSystemMemberNodeId: ID

  """
  Reads a single `Market` that is related to this `SystemMember`.
  """
  market: Market

  """
  Reads a single `Product` that is related to this `SystemMember`.
  """
  productByProductBmiRef: Product

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `System` that is related to this `SystemMember`.
  """
  systemBySystemBmiRef: System

  """
  The `SystemMember` that was deleted by this mutation.
  """
  systemMember: SystemMember

  """
  An edge for our `SystemMember`. May be used by Relay 1.
  """
  systemMemberEdge(
    """
    The method to use when ordering `SystemMember`.
    """
    orderBy: [SystemMembersOrderBy!] = [PRIMARY_KEY_ASC]
  ): SystemMembersEdge
}

"""
The output of our delete `System` mutation.
"""
type DeleteSystemPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedSystemNodeId: ID

  """
  Reads a single `Market` that is related to this `System`.
  """
  market: Market

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  The `System` that was deleted by this mutation.
  """
  system: System

  """
  An edge for our `System`. May be used by Relay 1.
  """
  systemEdge(
    """
    The method to use when ordering `System`.
    """
    orderBy: [SystemsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SystemsEdge
}

"""
The 'Dimension' type represents dimensions as whole numeric values between `1` and `4000`.
"""
scalar Dimension

input DoceboCertification {
  code: String
  title: String
  toNewIn: String
  userId: String
}

type DoceboTier implements Node {
  doceboCatalogueId: Int
  id: Int!
  marketId: Int!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  tierCode: Tier!
}

"""
A condition to be used against `DoceboTier` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input DoceboTierCondition {
  """
  Checks for equality with the object’s `id` field.
  """
  id: Int

  """
  Checks for equality with the object’s `marketId` field.
  """
  marketId: Int
}

"""
A filter to be used against `DoceboTier` object types. All fields are combined with a logical ‘and.’
"""
input DoceboTierFilter {
  """
  Checks for all expressions in this list.
  """
  and: [DoceboTierFilter!]

  """
  Filter by the object’s `id` field.
  """
  id: IntFilter

  """
  Filter by the object’s `marketId` field.
  """
  marketId: IntFilter

  """
  Negates the expression.
  """
  not: DoceboTierFilter

  """
  Checks for any expressions in this list.
  """
  or: [DoceboTierFilter!]
}

"""
An input for mutations affecting `DoceboTier`
"""
input DoceboTierInput {
  doceboCatalogueId: Int
  id: Int
  marketId: Int!
  tierCode: Tier!
}

"""
Represents an update to a `DoceboTier`. Fields that are set will be updated.
"""
input DoceboTierPatch {
  doceboCatalogueId: Int
  id: Int
  marketId: Int
  tierCode: Tier
}

"""
A connection to a list of `DoceboTier` values.
"""
type DoceboTiersConnection {
  """
  A list of edges which contains the `DoceboTier` and cursor to aid in pagination.
  """
  edges: [DoceboTiersEdge!]!

  """
  A list of `DoceboTier` objects.
  """
  nodes: [DoceboTier!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `DoceboTier` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `DoceboTier` edge in the connection.
"""
type DoceboTiersEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `DoceboTier` at the end of the edge.
  """
  node: DoceboTier!
}

"""
Methods to use when ordering `DoceboTier`.
"""
enum DoceboTiersOrderBy {
  ID_ASC
  ID_DESC
  MARKET_ID_ASC
  MARKET_ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

interface Entry {
  contentfulMetadata: ContentfulMetadata!
  sys: Sys!
}

type EntryCollection {
  items: [Entry]!
  limit: Int!
  skip: Int!
  total: Int!
}

input EntryFilter {
  AND: [EntryFilter]
  OR: [EntryFilter]
  contentfulMetadata: ContentfulMetadataFilter
  sys: SysFilter
}

enum EntryOrder {
  sys_firstPublishedAt_ASC
  sys_firstPublishedAt_DESC
  sys_id_ASC
  sys_id_DESC
  sys_publishedAt_ASC
  sys_publishedAt_DESC
  sys_publishedVersion_ASC
  sys_publishedVersion_DESC
}

"""
A category of evidence required by a Market for guarantees to be issued [See type definition](https://app.contentful.com/spaces/j30snaps0u9c/content_types/evidenceCategory)
"""
type EvidenceCategory implements Entry {
  contentfulMetadata: ContentfulMetadata!
  description(locale: String): EvidenceCategoryDescription
  linkedFrom(allowedLocales: [String]): EvidenceCategoryLinkingCollections
  minimumUploads(locale: String): Int
  name(locale: String): String
  referenceCode(locale: String): String
  sys: Sys!
}

type EvidenceCategoryCollection {
  items: [EvidenceCategory]!
  limit: Int!
  skip: Int!
  total: Int!
}

type EvidenceCategoryDescription {
  json: JSON!
  links: EvidenceCategoryDescriptionLinks!
}

type EvidenceCategoryDescriptionAssets {
  block: [Asset]!
  hyperlink: [Asset]!
}

type EvidenceCategoryDescriptionEntries {
  block: [Entry]!
  hyperlink: [Entry]!
  inline: [Entry]!
}

type EvidenceCategoryDescriptionLinks {
  assets: EvidenceCategoryDescriptionAssets!
  entries: EvidenceCategoryDescriptionEntries!
}

input EvidenceCategoryFilter {
  AND: [EvidenceCategoryFilter]
  OR: [EvidenceCategoryFilter]
  contentfulMetadata: ContentfulMetadataFilter
  description_contains: String
  description_exists: Boolean
  description_not_contains: String
  minimumUploads: Int
  minimumUploads_exists: Boolean
  minimumUploads_gt: Int
  minimumUploads_gte: Int
  minimumUploads_in: [Int]
  minimumUploads_lt: Int
  minimumUploads_lte: Int
  minimumUploads_not: Int
  minimumUploads_not_in: [Int]
  name: String
  name_contains: String
  name_exists: Boolean
  name_in: [String]
  name_not: String
  name_not_contains: String
  name_not_in: [String]
  referenceCode: String
  referenceCode_contains: String
  referenceCode_exists: Boolean
  referenceCode_in: [String]
  referenceCode_not: String
  referenceCode_not_contains: String
  referenceCode_not_in: [String]
  sys: SysFilter
}

type EvidenceCategoryLinkingCollections {
  entryCollection(
    limit: Int = 100
    locale: String
    preview: Boolean
    skip: Int = 0
  ): EntryCollection
  guaranteeTypeCollection(
    limit: Int = 100
    locale: String
    preview: Boolean
    skip: Int = 0
  ): GuaranteeTypeCollection
}

enum EvidenceCategoryOrder {
  minimumUploads_ASC
  minimumUploads_DESC
  name_ASC
  name_DESC
  referenceCode_ASC
  referenceCode_DESC
  sys_firstPublishedAt_ASC
  sys_firstPublishedAt_DESC
  sys_id_ASC
  sys_id_DESC
  sys_publishedAt_ASC
  sys_publishedAt_DESC
  sys_publishedVersion_ASC
  sys_publishedVersion_DESC
}

enum EvidenceCategoryType {
  CUSTOM
  MISCELLANEOUS
  PROOF_OF_PURCHASE
}

"""
A file uploaded to a project, usually as evidence to support a guarantee
"""
type EvidenceItem implements Node {
  """
  File reference or the file itself. Photo of the evidence
  """
  attachment: String!
  createdAt: Datetime!
  customEvidenceCategory: ContentfulEvidenceCategory

  """
  ek
  """
  customEvidenceCategoryKey: CustomEvidenceCategoryKey

  """
  ek
  """
  evidenceCategoryType: EvidenceCategoryType

  """
  Reads a single `Guarantee` that is related to this `EvidenceItem`.
  """
  guarantee: Guarantee

  """
  fk
  """
  guaranteeId: Int

  """
  Primary key
  """
  id: Int!

  """
  Short name for the item of evidence
  """
  name: String!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Reads a single `Project` that is related to this `EvidenceItem`.
  """
  project: Project

  """
  fk
  """
  projectId: Int!
  signedUrl: String
  updatedAt: Datetime!

  """
  Reads a single `Account` that is related to this `EvidenceItem`.
  """
  uploaderAccount: Account
  uploaderAccountId: Int
}

"""
A condition to be used against `EvidenceItem` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input EvidenceItemCondition {
  """
  Checks for equality with the object’s `guaranteeId` field.
  """
  guaranteeId: Int

  """
  Checks for equality with the object’s `id` field.
  """
  id: Int

  """
  Checks for equality with the object’s `projectId` field.
  """
  projectId: Int

  """
  Checks for equality with the object’s `uploaderAccountId` field.
  """
  uploaderAccountId: Int
}

"""
The fields on `evidenceItem` to look up the row to connect.
"""
input EvidenceItemEvidenceItemPkeyConnect {
  """
  Primary key
  """
  id: Int!
}

"""
The fields on `evidenceItem` to look up the row to delete.
"""
input EvidenceItemEvidenceItemPkeyDelete {
  """
  Primary key
  """
  id: Int!
}

"""
A filter to be used against `EvidenceItem` object types. All fields are combined with a logical ‘and.’
"""
input EvidenceItemFilter {
  """
  Checks for all expressions in this list.
  """
  and: [EvidenceItemFilter!]

  """
  Filter by the object’s `guaranteeId` field.
  """
  guaranteeId: IntFilter

  """
  Filter by the object’s `id` field.
  """
  id: IntFilter

  """
  Negates the expression.
  """
  not: EvidenceItemFilter

  """
  Checks for any expressions in this list.
  """
  or: [EvidenceItemFilter!]

  """
  Filter by the object’s `projectId` field.
  """
  projectId: IntFilter

  """
  Filter by the object’s `uploaderAccountId` field.
  """
  uploaderAccountId: IntFilter
}

"""
The `evidenceItem` to be created by this mutation.
"""
input EvidenceItemGuaranteeIdFkeyEvidenceItemCreateInput {
  accountToUploaderAccountId: EvidenceItemUploaderAccountIdFkeyInput

  """
  File reference or the file itself. Photo of the evidence
  """
  attachment: String!
  attachmentUpload: Upload
  createdAt: Datetime

  """
  ek
  """
  customEvidenceCategoryKey: CustomEvidenceCategoryKey

  """
  ek
  """
  evidenceCategoryType: EvidenceCategoryType
  guaranteeToGuaranteeId: EvidenceItemGuaranteeIdFkeyInput

  """
  Primary key
  """
  id: Int

  """
  Short name for the item of evidence
  """
  name: String!

  """
  fk
  """
  projectId: Int
  projectToProjectId: EvidenceItemProjectIdFkeyInput
  updatedAt: Datetime
  uploaderAccountId: Int
}

"""
The `guarantee` to be created by this mutation.
"""
input EvidenceItemGuaranteeIdFkeyGuaranteeCreateInput {
  accountToRequestorAccountId: GuaranteeRequestorAccountIdFkeyInput
  accountToReviewerAccountId: GuaranteeReviewerAccountIdFkeyInput

  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String

  """
  ek
  """
  coverage: GuaranteeCoverage
  createdAt: Datetime
  evidenceItemsUsingId: EvidenceItemGuaranteeIdFkeyInverseInput

  """
  When the guarantee will expire.  This should be calculated when the request_status becomes APPROVED. dependent on the StartDate, the Validity of the Product or System and the ValidityOffset in this Tier.
  The date is stored in UTC.
  """
  expiryDate: Datetime

  """
  The pdf file that is emailed out, or a reference to it, or reference to the service that will generate it on demand
  """
  fileStorageId: String

  """
  ek
  """
  guaranteeReferenceCode: GuaranteeReferenceCode!

  """
  Primary key - starts at 6100
  """
  id: Int

  """
  ek
  """
  languageCode: Language

  """
  fk
  """
  productBmiRef: String
  productToProductBmiRef: GuaranteeProductBmiRefFkeyInput

  """
  fk
  """
  projectId: Int
  projectToProjectId: GuaranteeProjectIdFkeyInput

  """
  fk
  """
  requestorAccountId: Int

  """
  fk
  """
  reviewerAccountId: Int

  """
  The date that the Guarantee is approved either automatically or manually. The date is stored in UTC.
  """
  startDate: Datetime

  """
  ek
  """
  status: RequestStatus

  """
  fk
  """
  systemBmiRef: String
  systemToSystemBmiRef: GuaranteeSystemBmiRefFkeyInput
  updatedAt: Datetime
}

"""
Input for the nested mutation of `guarantee` in the `EvidenceItemInput` mutation.
"""
input EvidenceItemGuaranteeIdFkeyInput {
  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  connectByBmiReferenceId: GuaranteeGuaranteeBmiReferenceIdKeyConnect

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  connectById: GuaranteeGuaranteePkeyConnect

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  connectByNodeId: GuaranteeNodeIdConnect

  """
  A `GuaranteeInput` object that will be created and connected to this object.
  """
  create: EvidenceItemGuaranteeIdFkeyGuaranteeCreateInput

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  deleteByBmiReferenceId: GuaranteeGuaranteeBmiReferenceIdKeyDelete

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  deleteById: GuaranteeGuaranteePkeyDelete

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  deleteByNodeId: GuaranteeNodeIdDelete

  """
  The primary key(s) and patch data for `guarantee` for the far side of the relationship.
  """
  updateByBmiReferenceId: GuaranteeOnEvidenceItemForEvidenceItemGuaranteeIdFkeyUsingGuaranteeBmiReferenceIdKeyUpdate

  """
  The primary key(s) and patch data for `guarantee` for the far side of the relationship.
  """
  updateById: GuaranteeOnEvidenceItemForEvidenceItemGuaranteeIdFkeyUsingGuaranteePkeyUpdate

  """
  The primary key(s) and patch data for `guarantee` for the far side of the relationship.
  """
  updateByNodeId: EvidenceItemOnEvidenceItemForEvidenceItemGuaranteeIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `evidenceItem` in the `GuaranteeInput` mutation.
"""
input EvidenceItemGuaranteeIdFkeyInverseInput {
  """
  The primary key(s) for `evidenceItem` for the far side of the relationship.
  """
  connectById: [EvidenceItemEvidenceItemPkeyConnect!]

  """
  The primary key(s) for `evidenceItem` for the far side of the relationship.
  """
  connectByNodeId: [EvidenceItemNodeIdConnect!]

  """
  A `EvidenceItemInput` object that will be created and connected to this object.
  """
  create: [EvidenceItemGuaranteeIdFkeyEvidenceItemCreateInput!]

  """
  The primary key(s) for `evidenceItem` for the far side of the relationship.
  """
  deleteById: [EvidenceItemEvidenceItemPkeyDelete!]

  """
  The primary key(s) for `evidenceItem` for the far side of the relationship.
  """
  deleteByNodeId: [EvidenceItemNodeIdDelete!]

  """
  Flag indicating whether all other `evidenceItem` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `evidenceItem` for the far side of the relationship.
  """
  updateById: [EvidenceItemOnEvidenceItemForEvidenceItemGuaranteeIdFkeyUsingEvidenceItemPkeyUpdate!]

  """
  The primary key(s) and patch data for `evidenceItem` for the far side of the relationship.
  """
  updateByNodeId: [GuaranteeOnEvidenceItemForEvidenceItemGuaranteeIdFkeyNodeIdUpdate!]
}

"""
An input for mutations affecting `EvidenceItem`
"""
input EvidenceItemInput {
  accountToUploaderAccountId: EvidenceItemUploaderAccountIdFkeyInput

  """
  File reference or the file itself. Photo of the evidence
  """
  attachment: String!
  attachmentUpload: Upload
  createdAt: Datetime

  """
  ek
  """
  customEvidenceCategoryKey: CustomEvidenceCategoryKey

  """
  ek
  """
  evidenceCategoryType: EvidenceCategoryType

  """
  fk
  """
  guaranteeId: Int
  guaranteeToGuaranteeId: EvidenceItemGuaranteeIdFkeyInput

  """
  Primary key
  """
  id: Int

  """
  Short name for the item of evidence
  """
  name: String!

  """
  fk
  """
  projectId: Int
  projectToProjectId: EvidenceItemProjectIdFkeyInput
  updatedAt: Datetime
  uploaderAccountId: Int
}

"""
The globally unique `ID` look up for the row to connect.
"""
input EvidenceItemNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `evidenceItem` to be connected.
  """
  nodeId: ID!
}

"""
The globally unique `ID` look up for the row to delete.
"""
input EvidenceItemNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `evidenceItem` to be deleted.
  """
  nodeId: ID!
}

"""
The globally unique `ID` look up for the row to update.
"""
input EvidenceItemOnEvidenceItemForEvidenceItemGuaranteeIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `guarantee` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `guarantee` being updated.
  """
  patch: GuaranteePatch!
}

"""
The fields on `evidenceItem` to look up the row to update.
"""
input EvidenceItemOnEvidenceItemForEvidenceItemGuaranteeIdFkeyUsingEvidenceItemPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `evidenceItem` being updated.
  """
  patch: updateEvidenceItemOnEvidenceItemForEvidenceItemGuaranteeIdFkeyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input EvidenceItemOnEvidenceItemForEvidenceItemProjectIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `project` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `project` being updated.
  """
  patch: ProjectPatch!
}

"""
The fields on `evidenceItem` to look up the row to update.
"""
input EvidenceItemOnEvidenceItemForEvidenceItemProjectIdFkeyUsingEvidenceItemPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `evidenceItem` being updated.
  """
  patch: updateEvidenceItemOnEvidenceItemForEvidenceItemProjectIdFkeyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input EvidenceItemOnEvidenceItemForEvidenceItemUploaderAccountIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `account` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: AccountPatch!
}

"""
The fields on `evidenceItem` to look up the row to update.
"""
input EvidenceItemOnEvidenceItemForEvidenceItemUploaderAccountIdFkeyUsingEvidenceItemPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `evidenceItem` being updated.
  """
  patch: updateEvidenceItemOnEvidenceItemForEvidenceItemUploaderAccountIdFkeyPatch!
}

"""
Represents an update to a `EvidenceItem`. Fields that are set will be updated.
"""
input EvidenceItemPatch {
  accountToUploaderAccountId: EvidenceItemUploaderAccountIdFkeyInput

  """
  File reference or the file itself. Photo of the evidence
  """
  attachment: String
  createdAt: Datetime

  """
  ek
  """
  customEvidenceCategoryKey: CustomEvidenceCategoryKey

  """
  ek
  """
  evidenceCategoryType: EvidenceCategoryType

  """
  fk
  """
  guaranteeId: Int
  guaranteeToGuaranteeId: EvidenceItemGuaranteeIdFkeyInput

  """
  Primary key
  """
  id: Int

  """
  Short name for the item of evidence
  """
  name: String

  """
  fk
  """
  projectId: Int
  projectToProjectId: EvidenceItemProjectIdFkeyInput
  updatedAt: Datetime
  uploaderAccountId: Int
}

"""
The `evidenceItem` to be created by this mutation.
"""
input EvidenceItemProjectIdFkeyEvidenceItemCreateInput {
  accountToUploaderAccountId: EvidenceItemUploaderAccountIdFkeyInput

  """
  File reference or the file itself. Photo of the evidence
  """
  attachment: String!
  attachmentUpload: Upload
  createdAt: Datetime

  """
  ek
  """
  customEvidenceCategoryKey: CustomEvidenceCategoryKey

  """
  ek
  """
  evidenceCategoryType: EvidenceCategoryType

  """
  fk
  """
  guaranteeId: Int
  guaranteeToGuaranteeId: EvidenceItemGuaranteeIdFkeyInput

  """
  Primary key
  """
  id: Int

  """
  Short name for the item of evidence
  """
  name: String!
  projectToProjectId: EvidenceItemProjectIdFkeyInput
  updatedAt: Datetime
  uploaderAccountId: Int
}

"""
Input for the nested mutation of `project` in the `EvidenceItemInput` mutation.
"""
input EvidenceItemProjectIdFkeyInput {
  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  connectById: ProjectProjectPkeyConnect

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  connectByNodeId: ProjectNodeIdConnect

  """
  A `ProjectInput` object that will be created and connected to this object.
  """
  create: EvidenceItemProjectIdFkeyProjectCreateInput

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  deleteById: ProjectProjectPkeyDelete

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  deleteByNodeId: ProjectNodeIdDelete

  """
  The primary key(s) and patch data for `project` for the far side of the relationship.
  """
  updateById: ProjectOnEvidenceItemForEvidenceItemProjectIdFkeyUsingProjectPkeyUpdate

  """
  The primary key(s) and patch data for `project` for the far side of the relationship.
  """
  updateByNodeId: EvidenceItemOnEvidenceItemForEvidenceItemProjectIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `evidenceItem` in the `ProjectInput` mutation.
"""
input EvidenceItemProjectIdFkeyInverseInput {
  """
  The primary key(s) for `evidenceItem` for the far side of the relationship.
  """
  connectById: [EvidenceItemEvidenceItemPkeyConnect!]

  """
  The primary key(s) for `evidenceItem` for the far side of the relationship.
  """
  connectByNodeId: [EvidenceItemNodeIdConnect!]

  """
  A `EvidenceItemInput` object that will be created and connected to this object.
  """
  create: [EvidenceItemProjectIdFkeyEvidenceItemCreateInput!]

  """
  The primary key(s) for `evidenceItem` for the far side of the relationship.
  """
  deleteById: [EvidenceItemEvidenceItemPkeyDelete!]

  """
  The primary key(s) for `evidenceItem` for the far side of the relationship.
  """
  deleteByNodeId: [EvidenceItemNodeIdDelete!]

  """
  Flag indicating whether all other `evidenceItem` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `evidenceItem` for the far side of the relationship.
  """
  updateById: [EvidenceItemOnEvidenceItemForEvidenceItemProjectIdFkeyUsingEvidenceItemPkeyUpdate!]

  """
  The primary key(s) and patch data for `evidenceItem` for the far side of the relationship.
  """
  updateByNodeId: [ProjectOnEvidenceItemForEvidenceItemProjectIdFkeyNodeIdUpdate!]
}

"""
The `project` to be created by this mutation.
"""
input EvidenceItemProjectIdFkeyProjectCreateInput {
  addressToBuildingOwnerAddressId: ProjectBuildingOwnerAddressIdFkeyInput
  addressToSiteAddressId: ProjectSiteAddressIdFkeyInput

  """
  fk
  """
  buildingOwnerAddressId: Int

  """
  Name of the Building Owner company if there is such a thing.  Not the same as an InTouch Company.
  """
  buildingOwnerCompany: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerFirstname: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerLastname: String

  """
  Email address of the person who owns the building that the roof is going on.  Not mandatory for a Project, but mandatory when the Company applies for a Guarantee related to the project.
  """
  buildingOwnerMail: String

  """
  fk
  """
  companyId: Int
  companyToCompanyId: ProjectCompanyIdFkeyInput
  createdAt: Datetime

  """
  Short description of what the Project is about.  Sometimes useful to clarify some points to BMI
  """
  description: String

  """
  The date that the Project officially expects to end or ended
  """
  endDate: Datetime!
  evidenceItemsUsingId: EvidenceItemProjectIdFkeyInverseInput
  guaranteesUsingId: GuaranteeProjectIdFkeyInverseInput

  """
  If this is true then the Project should be hidden from End Users
  """
  hidden: Boolean

  """
  Primary key
  """
  id: Int
  migrationId: String

  """
  Short name for the Project
  """
  name: String!
  notesUsingId: NoteProjectIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberProjectIdFkeyInverseInput

  """
  The number of square meters of roof that this project covers
  """
  roofArea: Int!

  """
  fk
  """
  siteAddressId: Int

  """
  The date that the Project officially starts or started
  """
  startDate: Datetime!

  """
  ek
  """
  technology: Technology!
  updatedAt: Datetime
}

"""
The `evidenceItem` to be created by this mutation.
"""
input EvidenceItemUploaderAccountIdFkeyEvidenceItemCreateInput {
  accountToUploaderAccountId: EvidenceItemUploaderAccountIdFkeyInput

  """
  File reference or the file itself. Photo of the evidence
  """
  attachment: String!
  attachmentUpload: Upload
  createdAt: Datetime

  """
  ek
  """
  customEvidenceCategoryKey: CustomEvidenceCategoryKey

  """
  ek
  """
  evidenceCategoryType: EvidenceCategoryType

  """
  fk
  """
  guaranteeId: Int
  guaranteeToGuaranteeId: EvidenceItemGuaranteeIdFkeyInput

  """
  Primary key
  """
  id: Int

  """
  Short name for the item of evidence
  """
  name: String!

  """
  fk
  """
  projectId: Int
  projectToProjectId: EvidenceItemProjectIdFkeyInput
  updatedAt: Datetime
}

"""
Input for the nested mutation of `account` in the `EvidenceItemInput` mutation.
"""
input EvidenceItemUploaderAccountIdFkeyInput {
  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByDoceboUserId: AccountAccountDoceboUserIdKeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByEmail: AccountAccountEmailKeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectById: AccountAccountPkeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByNodeId: AccountNodeIdConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByDoceboUserId: AccountAccountDoceboUserIdKeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByEmail: AccountAccountEmailKeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteById: AccountAccountPkeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByNodeId: AccountNodeIdDelete

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByDoceboUserId: AccountOnEvidenceItemForEvidenceItemUploaderAccountIdFkeyUsingAccountDoceboUserIdKeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByEmail: AccountOnEvidenceItemForEvidenceItemUploaderAccountIdFkeyUsingAccountEmailKeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateById: AccountOnEvidenceItemForEvidenceItemUploaderAccountIdFkeyUsingAccountPkeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByNodeId: EvidenceItemOnEvidenceItemForEvidenceItemUploaderAccountIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `evidenceItem` in the `AccountInput` mutation.
"""
input EvidenceItemUploaderAccountIdFkeyInverseInput {
  """
  The primary key(s) for `evidenceItem` for the far side of the relationship.
  """
  connectById: [EvidenceItemEvidenceItemPkeyConnect!]

  """
  The primary key(s) for `evidenceItem` for the far side of the relationship.
  """
  connectByNodeId: [EvidenceItemNodeIdConnect!]

  """
  A `EvidenceItemInput` object that will be created and connected to this object.
  """
  create: [EvidenceItemUploaderAccountIdFkeyEvidenceItemCreateInput!]

  """
  The primary key(s) for `evidenceItem` for the far side of the relationship.
  """
  deleteById: [EvidenceItemEvidenceItemPkeyDelete!]

  """
  The primary key(s) for `evidenceItem` for the far side of the relationship.
  """
  deleteByNodeId: [EvidenceItemNodeIdDelete!]

  """
  Flag indicating whether all other `evidenceItem` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `evidenceItem` for the far side of the relationship.
  """
  updateById: [EvidenceItemOnEvidenceItemForEvidenceItemUploaderAccountIdFkeyUsingEvidenceItemPkeyUpdate!]

  """
  The primary key(s) and patch data for `evidenceItem` for the far side of the relationship.
  """
  updateByNodeId: [AccountOnEvidenceItemForEvidenceItemUploaderAccountIdFkeyNodeIdUpdate!]
}

"""
All input for the `evidenceItemsAdd` mutation.
"""
input EvidenceItemsAddInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  evidences: [EvidenceItemInput]!
}

"""
The output of our `evidenceItemsAdd` mutation.
"""
type EvidenceItemsAddPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  evidenceItems: [EvidenceItem!]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
A connection to a list of `EvidenceItem` values.
"""
type EvidenceItemsConnection {
  """
  A list of edges which contains the `EvidenceItem` and cursor to aid in pagination.
  """
  edges: [EvidenceItemsEdge!]!

  """
  A list of `EvidenceItem` objects.
  """
  nodes: [EvidenceItem!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `EvidenceItem` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `EvidenceItem` edge in the connection.
"""
type EvidenceItemsEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `EvidenceItem` at the end of the edge.
  """
  node: EvidenceItem!
}

"""
Methods to use when ordering `EvidenceItem`.
"""
enum EvidenceItemsOrderBy {
  GUARANTEE_ID_ASC
  GUARANTEE_ID_DESC
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  PROJECT_ID_ASC
  PROJECT_ID_DESC
  UPLOADER_ACCOUNT_ID_ASC
  UPLOADER_ACCOUNT_ID_DESC
}

type FindIncompleteCompanyProfile {
  email: String
  firstName: String
  id: Int
  lastName: String
  marketid: Int
}

"""
A connection to a list of `FindIncompleteCompanyProfile` values.
"""
type FindIncompleteCompanyProfilesConnection {
  """
  A list of edges which contains the `FindIncompleteCompanyProfile` and cursor to aid in pagination.
  """
  edges: [FindIncompleteCompanyProfilesEdge!]!

  """
  A list of `FindIncompleteCompanyProfile` objects.
  """
  nodes: [FindIncompleteCompanyProfile!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `FindIncompleteCompanyProfile` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `FindIncompleteCompanyProfile` edge in the connection.
"""
type FindIncompleteCompanyProfilesEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `FindIncompleteCompanyProfile` at the end of the edge.
  """
  node: FindIncompleteCompanyProfile!
}

"""
Methods to use when ordering `FindIncompleteCompanyProfile`.
"""
enum FindIncompleteCompanyProfilesOrderBy {
  NATURAL
}

type FindRoofer {
  aboutUs: String
  addressCoordinates: Point
  addressCountry: String
  addressFirstLine: String
  addressPostcode: String
  addressRegion: String
  addressSecondLine: String
  addressTown: String
  businessType: BusinessType
  certifications: [String]
  coordinates: Point
  createdAt: Datetime
  facebook: String
  id: Int
  linkedIn: String
  logo: String
  marketId: Int
  marketdomain: String
  migrationId: String
  name: String
  operations: [Operation]
  ownerEmail: String
  ownerFullname: String
  ownerPhone: String
  phone: String
  publicEmail: String
  referenceNumber: Int
  registeredAddressId: Int
  registeredAddressMigrationId: String
  registeredBy: String
  registeredDate: Datetime
  status: CompanyStatus
  taxNumber: String
  tier: Tier
  tradingAddressId: Int
  tradingAddressMigrationId: String
  updatedAt: Datetime
  website: String
}

"""
A connection to a list of `FindRoofer` values.
"""
type FindRoofersConnection {
  """
  A list of edges which contains the `FindRoofer` and cursor to aid in pagination.
  """
  edges: [FindRoofersEdge!]!

  """
  A list of `FindRoofer` objects.
  """
  nodes: [FindRoofer!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `FindRoofer` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `FindRoofer` edge in the connection.
"""
type FindRoofersEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `FindRoofer` at the end of the edge.
  """
  node: FindRoofer!
}

"""
Methods to use when ordering `FindRoofer`.
"""
enum FindRoofersOrderBy {
  NATURAL
}

"""
Starts life as request for a gurantee and becomes an actual issued guarantee
"""
type Guarantee implements Node {
  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String

  """
  ek
  """
  coverage: GuaranteeCoverage
  createdAt: Datetime!

  """
  Reads and enables pagination through a set of `EvidenceItem`.
  """
  evidenceItems(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EvidenceItemCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EvidenceItemFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `EvidenceItem`.
    """
    orderBy: [EvidenceItemsOrderBy!] = [PRIMARY_KEY_ASC]
  ): EvidenceItemsConnection!

  """
  When the guarantee will expire.  This should be calculated when the request_status becomes APPROVED. dependent on the StartDate, the Validity of the Product or System and the ValidityOffset in this Tier.
  The date is stored in UTC.
  """
  expiryDate: Datetime

  """
  The pdf file that is emailed out, or a reference to it, or reference to the service that will generate it on demand
  """
  fileStorageId: String

  """
  ek
  """
  guaranteeReferenceCode: GuaranteeReferenceCode!
  guaranteeType: ContentfulGuaranteeType
  guaranteeTypes: ContentfulGuaranteeTypeCollection

  """
  Primary key - starts at 6100
  """
  id: Int!

  """
  ek
  """
  languageCode: Language

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  fk
  """
  productBmiRef: String

  """
  Reads a single `Product` that is related to this `Guarantee`.
  """
  productByProductBmiRef: Product

  """
  Reads a single `Project` that is related to this `Guarantee`.
  """
  project: Project

  """
  fk
  """
  projectId: Int!

  """
  Reads a single `Account` that is related to this `Guarantee`.
  """
  requestorAccount: Account

  """
  fk
  """
  requestorAccountId: Int

  """
  Reads a single `Account` that is related to this `Guarantee`.
  """
  reviewerAccount: Account

  """
  fk
  """
  reviewerAccountId: Int
  signedFileStorageUrl: String

  """
  The date that the Guarantee is approved either automatically or manually. The date is stored in UTC.
  """
  startDate: Datetime

  """
  ek
  """
  status: RequestStatus

  """
  fk
  """
  systemBmiRef: String

  """
  Reads a single `System` that is related to this `Guarantee`.
  """
  systemBySystemBmiRef: System
  updatedAt: Datetime!
}

"""
A condition to be used against `Guarantee` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input GuaranteeCondition {
  """
  Checks for equality with the object’s `bmiReferenceId` field.
  """
  bmiReferenceId: String

  """
  Checks for equality with the object’s `id` field.
  """
  id: Int

  """
  Checks for equality with the object’s `productBmiRef` field.
  """
  productBmiRef: String

  """
  Checks for equality with the object’s `projectId` field.
  """
  projectId: Int

  """
  Checks for equality with the object’s `requestorAccountId` field.
  """
  requestorAccountId: Int

  """
  Checks for equality with the object’s `reviewerAccountId` field.
  """
  reviewerAccountId: Int

  """
  Checks for equality with the object’s `systemBmiRef` field.
  """
  systemBmiRef: String
}

enum GuaranteeCoverage {
  PRODUCT
  SOLUTION
  SYSTEM
}

enum GuaranteeEventType {
  APPROVE_SOLUTION
  ASSIGN_SOLUTION
  REASSIGN_SOLUTION
  REJECT_SOLUTION
  SUBMIT_SOLUTION
  UNASSIGN_SOLUTION
}

"""
A filter to be used against `Guarantee` object types. All fields are combined with a logical ‘and.’
"""
input GuaranteeFilter {
  """
  Checks for all expressions in this list.
  """
  and: [GuaranteeFilter!]

  """
  Filter by the object’s `bmiReferenceId` field.
  """
  bmiReferenceId: StringFilter

  """
  Filter by the object’s `id` field.
  """
  id: IntFilter

  """
  Negates the expression.
  """
  not: GuaranteeFilter

  """
  Checks for any expressions in this list.
  """
  or: [GuaranteeFilter!]

  """
  Filter by the object’s `productBmiRef` field.
  """
  productBmiRef: StringFilter

  """
  Filter by the object’s `projectId` field.
  """
  projectId: IntFilter

  """
  Filter by the object’s `requestorAccountId` field.
  """
  requestorAccountId: IntFilter

  """
  Filter by the object’s `reviewerAccountId` field.
  """
  reviewerAccountId: IntFilter

  """
  Filter by the object’s `systemBmiRef` field.
  """
  systemBmiRef: StringFilter
}

"""
The fields on `guarantee` to look up the row to connect.
"""
input GuaranteeGuaranteeBmiReferenceIdKeyConnect {
  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String!
}

"""
The fields on `guarantee` to look up the row to delete.
"""
input GuaranteeGuaranteeBmiReferenceIdKeyDelete {
  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String!
}

"""
The fields on `guarantee` to look up the row to connect.
"""
input GuaranteeGuaranteePkeyConnect {
  """
  Primary key - starts at 6100
  """
  id: Int!
}

"""
The fields on `guarantee` to look up the row to delete.
"""
input GuaranteeGuaranteePkeyDelete {
  """
  Primary key - starts at 6100
  """
  id: Int!
}

"""
An input for mutations affecting `Guarantee`
"""
input GuaranteeInput {
  accountToRequestorAccountId: GuaranteeRequestorAccountIdFkeyInput
  accountToReviewerAccountId: GuaranteeReviewerAccountIdFkeyInput

  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String

  """
  ek
  """
  coverage: GuaranteeCoverage
  createdAt: Datetime
  evidenceItemsUsingId: EvidenceItemGuaranteeIdFkeyInverseInput

  """
  When the guarantee will expire.  This should be calculated when the request_status becomes APPROVED. dependent on the StartDate, the Validity of the Product or System and the ValidityOffset in this Tier.
  The date is stored in UTC.
  """
  expiryDate: Datetime

  """
  The pdf file that is emailed out, or a reference to it, or reference to the service that will generate it on demand
  """
  fileStorageId: String

  """
  ek
  """
  guaranteeReferenceCode: GuaranteeReferenceCode!

  """
  Primary key - starts at 6100
  """
  id: Int

  """
  ek
  """
  languageCode: Language

  """
  fk
  """
  productBmiRef: String
  productToProductBmiRef: GuaranteeProductBmiRefFkeyInput

  """
  fk
  """
  projectId: Int
  projectToProjectId: GuaranteeProjectIdFkeyInput

  """
  fk
  """
  requestorAccountId: Int

  """
  fk
  """
  reviewerAccountId: Int

  """
  The date that the Guarantee is approved either automatically or manually. The date is stored in UTC.
  """
  startDate: Datetime

  """
  ek
  """
  status: RequestStatus

  """
  fk
  """
  systemBmiRef: String
  systemToSystemBmiRef: GuaranteeSystemBmiRefFkeyInput
  updatedAt: Datetime
}

"""
The globally unique `ID` look up for the row to connect.
"""
input GuaranteeNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `guarantee` to be connected.
  """
  nodeId: ID!
}

"""
The globally unique `ID` look up for the row to delete.
"""
input GuaranteeNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `guarantee` to be deleted.
  """
  nodeId: ID!
}

"""
The globally unique `ID` look up for the row to update.
"""
input GuaranteeOnEvidenceItemForEvidenceItemGuaranteeIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `evidenceItem` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `evidenceItem` being updated.
  """
  patch: EvidenceItemPatch!
}

"""
The fields on `guarantee` to look up the row to update.
"""
input GuaranteeOnEvidenceItemForEvidenceItemGuaranteeIdFkeyUsingGuaranteeBmiReferenceIdKeyUpdate {
  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String!

  """
  An object where the defined keys will be set on the `guarantee` being updated.
  """
  patch: updateGuaranteeOnEvidenceItemForEvidenceItemGuaranteeIdFkeyPatch!
}

"""
The fields on `guarantee` to look up the row to update.
"""
input GuaranteeOnEvidenceItemForEvidenceItemGuaranteeIdFkeyUsingGuaranteePkeyUpdate {
  """
  Primary key - starts at 6100
  """
  id: Int!

  """
  An object where the defined keys will be set on the `guarantee` being updated.
  """
  patch: updateGuaranteeOnEvidenceItemForEvidenceItemGuaranteeIdFkeyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input GuaranteeOnGuaranteeForGuaranteeProductBmiRefFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `product` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `product` being updated.
  """
  patch: ProductPatch!
}

"""
The fields on `guarantee` to look up the row to update.
"""
input GuaranteeOnGuaranteeForGuaranteeProductBmiRefFkeyUsingGuaranteeBmiReferenceIdKeyUpdate {
  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String!

  """
  An object where the defined keys will be set on the `guarantee` being updated.
  """
  patch: updateGuaranteeOnGuaranteeForGuaranteeProductBmiRefFkeyPatch!
}

"""
The fields on `guarantee` to look up the row to update.
"""
input GuaranteeOnGuaranteeForGuaranteeProductBmiRefFkeyUsingGuaranteePkeyUpdate {
  """
  Primary key - starts at 6100
  """
  id: Int!

  """
  An object where the defined keys will be set on the `guarantee` being updated.
  """
  patch: updateGuaranteeOnGuaranteeForGuaranteeProductBmiRefFkeyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input GuaranteeOnGuaranteeForGuaranteeProjectIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `project` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `project` being updated.
  """
  patch: ProjectPatch!
}

"""
The fields on `guarantee` to look up the row to update.
"""
input GuaranteeOnGuaranteeForGuaranteeProjectIdFkeyUsingGuaranteeBmiReferenceIdKeyUpdate {
  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String!

  """
  An object where the defined keys will be set on the `guarantee` being updated.
  """
  patch: updateGuaranteeOnGuaranteeForGuaranteeProjectIdFkeyPatch!
}

"""
The fields on `guarantee` to look up the row to update.
"""
input GuaranteeOnGuaranteeForGuaranteeProjectIdFkeyUsingGuaranteePkeyUpdate {
  """
  Primary key - starts at 6100
  """
  id: Int!

  """
  An object where the defined keys will be set on the `guarantee` being updated.
  """
  patch: updateGuaranteeOnGuaranteeForGuaranteeProjectIdFkeyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input GuaranteeOnGuaranteeForGuaranteeRequestorAccountIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `account` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: AccountPatch!
}

"""
The fields on `guarantee` to look up the row to update.
"""
input GuaranteeOnGuaranteeForGuaranteeRequestorAccountIdFkeyUsingGuaranteeBmiReferenceIdKeyUpdate {
  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String!

  """
  An object where the defined keys will be set on the `guarantee` being updated.
  """
  patch: updateGuaranteeOnGuaranteeForGuaranteeRequestorAccountIdFkeyPatch!
}

"""
The fields on `guarantee` to look up the row to update.
"""
input GuaranteeOnGuaranteeForGuaranteeRequestorAccountIdFkeyUsingGuaranteePkeyUpdate {
  """
  Primary key - starts at 6100
  """
  id: Int!

  """
  An object where the defined keys will be set on the `guarantee` being updated.
  """
  patch: updateGuaranteeOnGuaranteeForGuaranteeRequestorAccountIdFkeyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input GuaranteeOnGuaranteeForGuaranteeReviewerAccountIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `account` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: AccountPatch!
}

"""
The fields on `guarantee` to look up the row to update.
"""
input GuaranteeOnGuaranteeForGuaranteeReviewerAccountIdFkeyUsingGuaranteeBmiReferenceIdKeyUpdate {
  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String!

  """
  An object where the defined keys will be set on the `guarantee` being updated.
  """
  patch: updateGuaranteeOnGuaranteeForGuaranteeReviewerAccountIdFkeyPatch!
}

"""
The fields on `guarantee` to look up the row to update.
"""
input GuaranteeOnGuaranteeForGuaranteeReviewerAccountIdFkeyUsingGuaranteePkeyUpdate {
  """
  Primary key - starts at 6100
  """
  id: Int!

  """
  An object where the defined keys will be set on the `guarantee` being updated.
  """
  patch: updateGuaranteeOnGuaranteeForGuaranteeReviewerAccountIdFkeyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input GuaranteeOnGuaranteeForGuaranteeSystemBmiRefFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `system` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `system` being updated.
  """
  patch: SystemPatch!
}

"""
The fields on `guarantee` to look up the row to update.
"""
input GuaranteeOnGuaranteeForGuaranteeSystemBmiRefFkeyUsingGuaranteeBmiReferenceIdKeyUpdate {
  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String!

  """
  An object where the defined keys will be set on the `guarantee` being updated.
  """
  patch: updateGuaranteeOnGuaranteeForGuaranteeSystemBmiRefFkeyPatch!
}

"""
The fields on `guarantee` to look up the row to update.
"""
input GuaranteeOnGuaranteeForGuaranteeSystemBmiRefFkeyUsingGuaranteePkeyUpdate {
  """
  Primary key - starts at 6100
  """
  id: Int!

  """
  An object where the defined keys will be set on the `guarantee` being updated.
  """
  patch: updateGuaranteeOnGuaranteeForGuaranteeSystemBmiRefFkeyPatch!
}

"""
Represents an update to a `Guarantee`. Fields that are set will be updated.
"""
input GuaranteePatch {
  accountToRequestorAccountId: GuaranteeRequestorAccountIdFkeyInput
  accountToReviewerAccountId: GuaranteeReviewerAccountIdFkeyInput

  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String

  """
  ek
  """
  coverage: GuaranteeCoverage
  createdAt: Datetime
  evidenceItemsUsingId: EvidenceItemGuaranteeIdFkeyInverseInput

  """
  When the guarantee will expire.  This should be calculated when the request_status becomes APPROVED. dependent on the StartDate, the Validity of the Product or System and the ValidityOffset in this Tier.
  The date is stored in UTC.
  """
  expiryDate: Datetime

  """
  The pdf file that is emailed out, or a reference to it, or reference to the service that will generate it on demand
  """
  fileStorageId: String

  """
  ek
  """
  guaranteeReferenceCode: GuaranteeReferenceCode

  """
  Primary key - starts at 6100
  """
  id: Int

  """
  ek
  """
  languageCode: Language

  """
  fk
  """
  productBmiRef: String
  productToProductBmiRef: GuaranteeProductBmiRefFkeyInput

  """
  fk
  """
  projectId: Int
  projectToProjectId: GuaranteeProjectIdFkeyInput

  """
  fk
  """
  requestorAccountId: Int

  """
  fk
  """
  reviewerAccountId: Int

  """
  The date that the Guarantee is approved either automatically or manually. The date is stored in UTC.
  """
  startDate: Datetime

  """
  ek
  """
  status: RequestStatus

  """
  fk
  """
  systemBmiRef: String
  systemToSystemBmiRef: GuaranteeSystemBmiRefFkeyInput
  updatedAt: Datetime
}

"""
The `guarantee` to be created by this mutation.
"""
input GuaranteeProductBmiRefFkeyGuaranteeCreateInput {
  accountToRequestorAccountId: GuaranteeRequestorAccountIdFkeyInput
  accountToReviewerAccountId: GuaranteeReviewerAccountIdFkeyInput

  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String

  """
  ek
  """
  coverage: GuaranteeCoverage
  createdAt: Datetime
  evidenceItemsUsingId: EvidenceItemGuaranteeIdFkeyInverseInput

  """
  When the guarantee will expire.  This should be calculated when the request_status becomes APPROVED. dependent on the StartDate, the Validity of the Product or System and the ValidityOffset in this Tier.
  The date is stored in UTC.
  """
  expiryDate: Datetime

  """
  The pdf file that is emailed out, or a reference to it, or reference to the service that will generate it on demand
  """
  fileStorageId: String

  """
  ek
  """
  guaranteeReferenceCode: GuaranteeReferenceCode!

  """
  Primary key - starts at 6100
  """
  id: Int

  """
  ek
  """
  languageCode: Language
  productToProductBmiRef: GuaranteeProductBmiRefFkeyInput

  """
  fk
  """
  projectId: Int
  projectToProjectId: GuaranteeProjectIdFkeyInput

  """
  fk
  """
  requestorAccountId: Int

  """
  fk
  """
  reviewerAccountId: Int

  """
  The date that the Guarantee is approved either automatically or manually. The date is stored in UTC.
  """
  startDate: Datetime

  """
  ek
  """
  status: RequestStatus

  """
  fk
  """
  systemBmiRef: String
  systemToSystemBmiRef: GuaranteeSystemBmiRefFkeyInput
  updatedAt: Datetime
}

"""
Input for the nested mutation of `product` in the `GuaranteeInput` mutation.
"""
input GuaranteeProductBmiRefFkeyInput {
  """
  The primary key(s) for `product` for the far side of the relationship.
  """
  connectByBmiRef: ProductProductBmiRefKeyConnect

  """
  The primary key(s) for `product` for the far side of the relationship.
  """
  connectById: ProductProductPkeyConnect

  """
  The primary key(s) for `product` for the far side of the relationship.
  """
  connectByNodeId: ProductNodeIdConnect

  """
  A `ProductInput` object that will be created and connected to this object.
  """
  create: GuaranteeProductBmiRefFkeyProductCreateInput

  """
  The primary key(s) for `product` for the far side of the relationship.
  """
  deleteByBmiRef: ProductProductBmiRefKeyDelete

  """
  The primary key(s) for `product` for the far side of the relationship.
  """
  deleteById: ProductProductPkeyDelete

  """
  The primary key(s) for `product` for the far side of the relationship.
  """
  deleteByNodeId: ProductNodeIdDelete

  """
  The primary key(s) and patch data for `product` for the far side of the relationship.
  """
  updateByBmiRef: ProductOnGuaranteeForGuaranteeProductBmiRefFkeyUsingProductBmiRefKeyUpdate

  """
  The primary key(s) and patch data for `product` for the far side of the relationship.
  """
  updateById: ProductOnGuaranteeForGuaranteeProductBmiRefFkeyUsingProductPkeyUpdate

  """
  The primary key(s) and patch data for `product` for the far side of the relationship.
  """
  updateByNodeId: GuaranteeOnGuaranteeForGuaranteeProductBmiRefFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `guarantee` in the `ProductInput` mutation.
"""
input GuaranteeProductBmiRefFkeyInverseInput {
  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  connectByBmiReferenceId: [GuaranteeGuaranteeBmiReferenceIdKeyConnect!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  connectById: [GuaranteeGuaranteePkeyConnect!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  connectByNodeId: [GuaranteeNodeIdConnect!]

  """
  A `GuaranteeInput` object that will be created and connected to this object.
  """
  create: [GuaranteeProductBmiRefFkeyGuaranteeCreateInput!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  deleteByBmiReferenceId: [GuaranteeGuaranteeBmiReferenceIdKeyDelete!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  deleteById: [GuaranteeGuaranteePkeyDelete!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  deleteByNodeId: [GuaranteeNodeIdDelete!]

  """
  Flag indicating whether all other `guarantee` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `guarantee` for the far side of the relationship.
  """
  updateByBmiReferenceId: [GuaranteeOnGuaranteeForGuaranteeProductBmiRefFkeyUsingGuaranteeBmiReferenceIdKeyUpdate!]

  """
  The primary key(s) and patch data for `guarantee` for the far side of the relationship.
  """
  updateById: [GuaranteeOnGuaranteeForGuaranteeProductBmiRefFkeyUsingGuaranteePkeyUpdate!]

  """
  The primary key(s) and patch data for `guarantee` for the far side of the relationship.
  """
  updateByNodeId: [ProductOnGuaranteeForGuaranteeProductBmiRefFkeyNodeIdUpdate!]
}

"""
The `product` to be created by this mutation.
"""
input GuaranteeProductBmiRefFkeyProductCreateInput {
  """
  A unique reference for the product known to BMI
  """
  bmiRef: String!

  """
  The Products brand
  """
  brand: String!
  createdAt: Datetime

  """
  A description of the Product
  """
  description: String

  """
  The family of Products this Product is in
  """
  family: String!
  guaranteesUsingBmiRef: GuaranteeProductBmiRefFkeyInverseInput

  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int
  marketToMarketId: ProductMarketIdFkeyInput

  """
  The number of years that this product can be guaranteed for
  """
  maximumValidityYears: Int!

  """
  Short name for the Product
  """
  name: String!

  """
  Whether the Product is avialable for new guarantees
  """
  published: Boolean!
  systemMembersUsingBmiRef: SystemMemberProductBmiRefFkeyInverseInput

  """
  ek
  """
  technology: Technology!
  updatedAt: Datetime
}

"""
The `guarantee` to be created by this mutation.
"""
input GuaranteeProjectIdFkeyGuaranteeCreateInput {
  accountToRequestorAccountId: GuaranteeRequestorAccountIdFkeyInput
  accountToReviewerAccountId: GuaranteeReviewerAccountIdFkeyInput

  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String

  """
  ek
  """
  coverage: GuaranteeCoverage
  createdAt: Datetime
  evidenceItemsUsingId: EvidenceItemGuaranteeIdFkeyInverseInput

  """
  When the guarantee will expire.  This should be calculated when the request_status becomes APPROVED. dependent on the StartDate, the Validity of the Product or System and the ValidityOffset in this Tier.
  The date is stored in UTC.
  """
  expiryDate: Datetime

  """
  The pdf file that is emailed out, or a reference to it, or reference to the service that will generate it on demand
  """
  fileStorageId: String

  """
  ek
  """
  guaranteeReferenceCode: GuaranteeReferenceCode!

  """
  Primary key - starts at 6100
  """
  id: Int

  """
  ek
  """
  languageCode: Language

  """
  fk
  """
  productBmiRef: String
  productToProductBmiRef: GuaranteeProductBmiRefFkeyInput
  projectToProjectId: GuaranteeProjectIdFkeyInput

  """
  fk
  """
  requestorAccountId: Int

  """
  fk
  """
  reviewerAccountId: Int

  """
  The date that the Guarantee is approved either automatically or manually. The date is stored in UTC.
  """
  startDate: Datetime

  """
  ek
  """
  status: RequestStatus

  """
  fk
  """
  systemBmiRef: String
  systemToSystemBmiRef: GuaranteeSystemBmiRefFkeyInput
  updatedAt: Datetime
}

"""
Input for the nested mutation of `project` in the `GuaranteeInput` mutation.
"""
input GuaranteeProjectIdFkeyInput {
  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  connectById: ProjectProjectPkeyConnect

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  connectByNodeId: ProjectNodeIdConnect

  """
  A `ProjectInput` object that will be created and connected to this object.
  """
  create: GuaranteeProjectIdFkeyProjectCreateInput

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  deleteById: ProjectProjectPkeyDelete

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  deleteByNodeId: ProjectNodeIdDelete

  """
  The primary key(s) and patch data for `project` for the far side of the relationship.
  """
  updateById: ProjectOnGuaranteeForGuaranteeProjectIdFkeyUsingProjectPkeyUpdate

  """
  The primary key(s) and patch data for `project` for the far side of the relationship.
  """
  updateByNodeId: GuaranteeOnGuaranteeForGuaranteeProjectIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `guarantee` in the `ProjectInput` mutation.
"""
input GuaranteeProjectIdFkeyInverseInput {
  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  connectByBmiReferenceId: [GuaranteeGuaranteeBmiReferenceIdKeyConnect!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  connectById: [GuaranteeGuaranteePkeyConnect!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  connectByNodeId: [GuaranteeNodeIdConnect!]

  """
  A `GuaranteeInput` object that will be created and connected to this object.
  """
  create: [GuaranteeProjectIdFkeyGuaranteeCreateInput!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  deleteByBmiReferenceId: [GuaranteeGuaranteeBmiReferenceIdKeyDelete!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  deleteById: [GuaranteeGuaranteePkeyDelete!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  deleteByNodeId: [GuaranteeNodeIdDelete!]

  """
  Flag indicating whether all other `guarantee` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `guarantee` for the far side of the relationship.
  """
  updateByBmiReferenceId: [GuaranteeOnGuaranteeForGuaranteeProjectIdFkeyUsingGuaranteeBmiReferenceIdKeyUpdate!]

  """
  The primary key(s) and patch data for `guarantee` for the far side of the relationship.
  """
  updateById: [GuaranteeOnGuaranteeForGuaranteeProjectIdFkeyUsingGuaranteePkeyUpdate!]

  """
  The primary key(s) and patch data for `guarantee` for the far side of the relationship.
  """
  updateByNodeId: [ProjectOnGuaranteeForGuaranteeProjectIdFkeyNodeIdUpdate!]
}

"""
The `project` to be created by this mutation.
"""
input GuaranteeProjectIdFkeyProjectCreateInput {
  addressToBuildingOwnerAddressId: ProjectBuildingOwnerAddressIdFkeyInput
  addressToSiteAddressId: ProjectSiteAddressIdFkeyInput

  """
  fk
  """
  buildingOwnerAddressId: Int

  """
  Name of the Building Owner company if there is such a thing.  Not the same as an InTouch Company.
  """
  buildingOwnerCompany: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerFirstname: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerLastname: String

  """
  Email address of the person who owns the building that the roof is going on.  Not mandatory for a Project, but mandatory when the Company applies for a Guarantee related to the project.
  """
  buildingOwnerMail: String

  """
  fk
  """
  companyId: Int
  companyToCompanyId: ProjectCompanyIdFkeyInput
  createdAt: Datetime

  """
  Short description of what the Project is about.  Sometimes useful to clarify some points to BMI
  """
  description: String

  """
  The date that the Project officially expects to end or ended
  """
  endDate: Datetime!
  evidenceItemsUsingId: EvidenceItemProjectIdFkeyInverseInput
  guaranteesUsingId: GuaranteeProjectIdFkeyInverseInput

  """
  If this is true then the Project should be hidden from End Users
  """
  hidden: Boolean

  """
  Primary key
  """
  id: Int
  migrationId: String

  """
  Short name for the Project
  """
  name: String!
  notesUsingId: NoteProjectIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberProjectIdFkeyInverseInput

  """
  The number of square meters of roof that this project covers
  """
  roofArea: Int!

  """
  fk
  """
  siteAddressId: Int

  """
  The date that the Project officially starts or started
  """
  startDate: Datetime!

  """
  ek
  """
  technology: Technology!
  updatedAt: Datetime
}

enum GuaranteeReferenceCode {
  FLAT_PRODUCT
  FLAT_SOLUTION
  FLAT_SYSTEM
  PITCHED_PRODUCT
  PITCHED_SOLUTION
  PITCHED_SYSTEM
}

"""
The `guarantee` to be created by this mutation.
"""
input GuaranteeRequestorAccountIdFkeyGuaranteeCreateInput {
  accountToRequestorAccountId: GuaranteeRequestorAccountIdFkeyInput
  accountToReviewerAccountId: GuaranteeReviewerAccountIdFkeyInput

  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String

  """
  ek
  """
  coverage: GuaranteeCoverage
  createdAt: Datetime
  evidenceItemsUsingId: EvidenceItemGuaranteeIdFkeyInverseInput

  """
  When the guarantee will expire.  This should be calculated when the request_status becomes APPROVED. dependent on the StartDate, the Validity of the Product or System and the ValidityOffset in this Tier.
  The date is stored in UTC.
  """
  expiryDate: Datetime

  """
  The pdf file that is emailed out, or a reference to it, or reference to the service that will generate it on demand
  """
  fileStorageId: String

  """
  ek
  """
  guaranteeReferenceCode: GuaranteeReferenceCode!

  """
  Primary key - starts at 6100
  """
  id: Int

  """
  ek
  """
  languageCode: Language

  """
  fk
  """
  productBmiRef: String
  productToProductBmiRef: GuaranteeProductBmiRefFkeyInput

  """
  fk
  """
  projectId: Int
  projectToProjectId: GuaranteeProjectIdFkeyInput

  """
  fk
  """
  reviewerAccountId: Int

  """
  The date that the Guarantee is approved either automatically or manually. The date is stored in UTC.
  """
  startDate: Datetime

  """
  ek
  """
  status: RequestStatus

  """
  fk
  """
  systemBmiRef: String
  systemToSystemBmiRef: GuaranteeSystemBmiRefFkeyInput
  updatedAt: Datetime
}

"""
Input for the nested mutation of `account` in the `GuaranteeInput` mutation.
"""
input GuaranteeRequestorAccountIdFkeyInput {
  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByDoceboUserId: AccountAccountDoceboUserIdKeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByEmail: AccountAccountEmailKeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectById: AccountAccountPkeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByNodeId: AccountNodeIdConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByDoceboUserId: AccountAccountDoceboUserIdKeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByEmail: AccountAccountEmailKeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteById: AccountAccountPkeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByNodeId: AccountNodeIdDelete

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByDoceboUserId: AccountOnGuaranteeForGuaranteeRequestorAccountIdFkeyUsingAccountDoceboUserIdKeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByEmail: AccountOnGuaranteeForGuaranteeRequestorAccountIdFkeyUsingAccountEmailKeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateById: AccountOnGuaranteeForGuaranteeRequestorAccountIdFkeyUsingAccountPkeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByNodeId: GuaranteeOnGuaranteeForGuaranteeRequestorAccountIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `guarantee` in the `AccountInput` mutation.
"""
input GuaranteeRequestorAccountIdFkeyInverseInput {
  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  connectByBmiReferenceId: [GuaranteeGuaranteeBmiReferenceIdKeyConnect!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  connectById: [GuaranteeGuaranteePkeyConnect!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  connectByNodeId: [GuaranteeNodeIdConnect!]

  """
  A `GuaranteeInput` object that will be created and connected to this object.
  """
  create: [GuaranteeRequestorAccountIdFkeyGuaranteeCreateInput!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  deleteByBmiReferenceId: [GuaranteeGuaranteeBmiReferenceIdKeyDelete!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  deleteById: [GuaranteeGuaranteePkeyDelete!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  deleteByNodeId: [GuaranteeNodeIdDelete!]

  """
  Flag indicating whether all other `guarantee` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `guarantee` for the far side of the relationship.
  """
  updateByBmiReferenceId: [GuaranteeOnGuaranteeForGuaranteeRequestorAccountIdFkeyUsingGuaranteeBmiReferenceIdKeyUpdate!]

  """
  The primary key(s) and patch data for `guarantee` for the far side of the relationship.
  """
  updateById: [GuaranteeOnGuaranteeForGuaranteeRequestorAccountIdFkeyUsingGuaranteePkeyUpdate!]

  """
  The primary key(s) and patch data for `guarantee` for the far side of the relationship.
  """
  updateByNodeId: [AccountOnGuaranteeForGuaranteeRequestorAccountIdFkeyNodeIdUpdate!]
}

"""
The `guarantee` to be created by this mutation.
"""
input GuaranteeReviewerAccountIdFkeyGuaranteeCreateInput {
  accountToRequestorAccountId: GuaranteeRequestorAccountIdFkeyInput
  accountToReviewerAccountId: GuaranteeReviewerAccountIdFkeyInput

  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String

  """
  ek
  """
  coverage: GuaranteeCoverage
  createdAt: Datetime
  evidenceItemsUsingId: EvidenceItemGuaranteeIdFkeyInverseInput

  """
  When the guarantee will expire.  This should be calculated when the request_status becomes APPROVED. dependent on the StartDate, the Validity of the Product or System and the ValidityOffset in this Tier.
  The date is stored in UTC.
  """
  expiryDate: Datetime

  """
  The pdf file that is emailed out, or a reference to it, or reference to the service that will generate it on demand
  """
  fileStorageId: String

  """
  ek
  """
  guaranteeReferenceCode: GuaranteeReferenceCode!

  """
  Primary key - starts at 6100
  """
  id: Int

  """
  ek
  """
  languageCode: Language

  """
  fk
  """
  productBmiRef: String
  productToProductBmiRef: GuaranteeProductBmiRefFkeyInput

  """
  fk
  """
  projectId: Int
  projectToProjectId: GuaranteeProjectIdFkeyInput

  """
  fk
  """
  requestorAccountId: Int

  """
  The date that the Guarantee is approved either automatically or manually. The date is stored in UTC.
  """
  startDate: Datetime

  """
  ek
  """
  status: RequestStatus

  """
  fk
  """
  systemBmiRef: String
  systemToSystemBmiRef: GuaranteeSystemBmiRefFkeyInput
  updatedAt: Datetime
}

"""
Input for the nested mutation of `account` in the `GuaranteeInput` mutation.
"""
input GuaranteeReviewerAccountIdFkeyInput {
  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByDoceboUserId: AccountAccountDoceboUserIdKeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByEmail: AccountAccountEmailKeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectById: AccountAccountPkeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByNodeId: AccountNodeIdConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByDoceboUserId: AccountAccountDoceboUserIdKeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByEmail: AccountAccountEmailKeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteById: AccountAccountPkeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByNodeId: AccountNodeIdDelete

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByDoceboUserId: AccountOnGuaranteeForGuaranteeReviewerAccountIdFkeyUsingAccountDoceboUserIdKeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByEmail: AccountOnGuaranteeForGuaranteeReviewerAccountIdFkeyUsingAccountEmailKeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateById: AccountOnGuaranteeForGuaranteeReviewerAccountIdFkeyUsingAccountPkeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByNodeId: GuaranteeOnGuaranteeForGuaranteeReviewerAccountIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `guarantee` in the `AccountInput` mutation.
"""
input GuaranteeReviewerAccountIdFkeyInverseInput {
  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  connectByBmiReferenceId: [GuaranteeGuaranteeBmiReferenceIdKeyConnect!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  connectById: [GuaranteeGuaranteePkeyConnect!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  connectByNodeId: [GuaranteeNodeIdConnect!]

  """
  A `GuaranteeInput` object that will be created and connected to this object.
  """
  create: [GuaranteeReviewerAccountIdFkeyGuaranteeCreateInput!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  deleteByBmiReferenceId: [GuaranteeGuaranteeBmiReferenceIdKeyDelete!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  deleteById: [GuaranteeGuaranteePkeyDelete!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  deleteByNodeId: [GuaranteeNodeIdDelete!]

  """
  Flag indicating whether all other `guarantee` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `guarantee` for the far side of the relationship.
  """
  updateByBmiReferenceId: [GuaranteeOnGuaranteeForGuaranteeReviewerAccountIdFkeyUsingGuaranteeBmiReferenceIdKeyUpdate!]

  """
  The primary key(s) and patch data for `guarantee` for the far side of the relationship.
  """
  updateById: [GuaranteeOnGuaranteeForGuaranteeReviewerAccountIdFkeyUsingGuaranteePkeyUpdate!]

  """
  The primary key(s) and patch data for `guarantee` for the far side of the relationship.
  """
  updateByNodeId: [AccountOnGuaranteeForGuaranteeReviewerAccountIdFkeyNodeIdUpdate!]
}

"""
The `guarantee` to be created by this mutation.
"""
input GuaranteeSystemBmiRefFkeyGuaranteeCreateInput {
  accountToRequestorAccountId: GuaranteeRequestorAccountIdFkeyInput
  accountToReviewerAccountId: GuaranteeReviewerAccountIdFkeyInput

  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String

  """
  ek
  """
  coverage: GuaranteeCoverage
  createdAt: Datetime
  evidenceItemsUsingId: EvidenceItemGuaranteeIdFkeyInverseInput

  """
  When the guarantee will expire.  This should be calculated when the request_status becomes APPROVED. dependent on the StartDate, the Validity of the Product or System and the ValidityOffset in this Tier.
  The date is stored in UTC.
  """
  expiryDate: Datetime

  """
  The pdf file that is emailed out, or a reference to it, or reference to the service that will generate it on demand
  """
  fileStorageId: String

  """
  ek
  """
  guaranteeReferenceCode: GuaranteeReferenceCode!

  """
  Primary key - starts at 6100
  """
  id: Int

  """
  ek
  """
  languageCode: Language

  """
  fk
  """
  productBmiRef: String
  productToProductBmiRef: GuaranteeProductBmiRefFkeyInput

  """
  fk
  """
  projectId: Int
  projectToProjectId: GuaranteeProjectIdFkeyInput

  """
  fk
  """
  requestorAccountId: Int

  """
  fk
  """
  reviewerAccountId: Int

  """
  The date that the Guarantee is approved either automatically or manually. The date is stored in UTC.
  """
  startDate: Datetime

  """
  ek
  """
  status: RequestStatus
  systemToSystemBmiRef: GuaranteeSystemBmiRefFkeyInput
  updatedAt: Datetime
}

"""
Input for the nested mutation of `system` in the `GuaranteeInput` mutation.
"""
input GuaranteeSystemBmiRefFkeyInput {
  """
  The primary key(s) for `system` for the far side of the relationship.
  """
  connectByBmiRef: SystemSystemBmiRefKeyConnect

  """
  The primary key(s) for `system` for the far side of the relationship.
  """
  connectById: SystemSystemPkeyConnect

  """
  The primary key(s) for `system` for the far side of the relationship.
  """
  connectByNodeId: SystemNodeIdConnect

  """
  A `SystemInput` object that will be created and connected to this object.
  """
  create: GuaranteeSystemBmiRefFkeySystemCreateInput

  """
  The primary key(s) for `system` for the far side of the relationship.
  """
  deleteByBmiRef: SystemSystemBmiRefKeyDelete

  """
  The primary key(s) for `system` for the far side of the relationship.
  """
  deleteById: SystemSystemPkeyDelete

  """
  The primary key(s) for `system` for the far side of the relationship.
  """
  deleteByNodeId: SystemNodeIdDelete

  """
  The primary key(s) and patch data for `system` for the far side of the relationship.
  """
  updateByBmiRef: SystemOnGuaranteeForGuaranteeSystemBmiRefFkeyUsingSystemBmiRefKeyUpdate

  """
  The primary key(s) and patch data for `system` for the far side of the relationship.
  """
  updateById: SystemOnGuaranteeForGuaranteeSystemBmiRefFkeyUsingSystemPkeyUpdate

  """
  The primary key(s) and patch data for `system` for the far side of the relationship.
  """
  updateByNodeId: GuaranteeOnGuaranteeForGuaranteeSystemBmiRefFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `guarantee` in the `SystemInput` mutation.
"""
input GuaranteeSystemBmiRefFkeyInverseInput {
  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  connectByBmiReferenceId: [GuaranteeGuaranteeBmiReferenceIdKeyConnect!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  connectById: [GuaranteeGuaranteePkeyConnect!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  connectByNodeId: [GuaranteeNodeIdConnect!]

  """
  A `GuaranteeInput` object that will be created and connected to this object.
  """
  create: [GuaranteeSystemBmiRefFkeyGuaranteeCreateInput!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  deleteByBmiReferenceId: [GuaranteeGuaranteeBmiReferenceIdKeyDelete!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  deleteById: [GuaranteeGuaranteePkeyDelete!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  deleteByNodeId: [GuaranteeNodeIdDelete!]

  """
  Flag indicating whether all other `guarantee` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `guarantee` for the far side of the relationship.
  """
  updateByBmiReferenceId: [GuaranteeOnGuaranteeForGuaranteeSystemBmiRefFkeyUsingGuaranteeBmiReferenceIdKeyUpdate!]

  """
  The primary key(s) and patch data for `guarantee` for the far side of the relationship.
  """
  updateById: [GuaranteeOnGuaranteeForGuaranteeSystemBmiRefFkeyUsingGuaranteePkeyUpdate!]

  """
  The primary key(s) and patch data for `guarantee` for the far side of the relationship.
  """
  updateByNodeId: [SystemOnGuaranteeForGuaranteeSystemBmiRefFkeyNodeIdUpdate!]
}

"""
The `system` to be created by this mutation.
"""
input GuaranteeSystemBmiRefFkeySystemCreateInput {
  """
  A unique reference for the system known to BMI
  """
  bmiRef: String!
  createdAt: Datetime

  """
  A description for the System
  """
  description: String
  guaranteesUsingBmiRef: GuaranteeSystemBmiRefFkeyInverseInput

  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int
  marketToMarketId: SystemMarketIdFkeyInput

  """
  The maximum number of years that this system can be guaranteed for.  Must be greater than 10.
  """
  maximumValidityYears: Int!

  """
  Short name for the System
  """
  name: String!

  """
  If true this system is available for users to select when applying for a system or solution guarantee
  """
  published: Boolean!
  systemMembersUsingBmiRef: SystemMemberSystemBmiRefFkeyInverseInput

  """
  ek
  """
  technology: Technology!
  updatedAt: Datetime
}

"""
A template for a type of Guarantee [See type definition](https://app.contentful.com/spaces/j30snaps0u9c/content_types/guaranteeTemplate)
"""
type GuaranteeTemplate implements Entry {
  approvalMessage(locale: String, preview: Boolean): MessageTemplate
  contentfulMetadata: ContentfulMetadata!
  coverage(locale: String): String
  displayName(locale: String): String
  filenamePrefix(locale: String): String
  footer(locale: String): String
  guaranteeScope(locale: String): String
  headingBeneficiary(locale: String): String
  headingBuildingAddress(locale: String): String
  headingBuildingOwnerName(locale: String): String
  headingContractor(locale: String): String
  headingContractorId(locale: String): String
  headingContractorName(locale: String): String
  headingExpiry(locale: String): String
  headingGuarantee(locale: String): String
  headingGuaranteeId(locale: String): String
  headingProducts(locale: String): String
  headingRoofArea(locale: String): String
  headingRoofType(locale: String): String
  headingScope(locale: String): String
  headingStartDate(locale: String): String
  headingValidity(locale: String): String
  languageCode(locale: String): String
  languageDescriptor(locale: String): String
  linkedFrom(allowedLocales: [String]): GuaranteeTemplateLinkingCollections
  logo(locale: String, preview: Boolean): Asset
  mailBody(locale: String): String
  maintenanceTemplate(locale: String, preview: Boolean): Asset
  rejectionMessage(locale: String, preview: Boolean): MessageTemplate
  roofType(locale: String): String
  signatory(locale: String): String
  sys: Sys!
  technology(locale: String): String
  terms(locale: String, preview: Boolean): Asset
  titleLine1(locale: String): String
  titleLine2(locale: String): String
}

type GuaranteeTemplateCollection {
  items: [GuaranteeTemplate]!
  limit: Int!
  skip: Int!
  total: Int!
}

input GuaranteeTemplateFilter {
  AND: [GuaranteeTemplateFilter]
  OR: [GuaranteeTemplateFilter]
  approvalMessage: cfMessageTemplateNestedFilter
  approvalMessage_exists: Boolean
  contentfulMetadata: ContentfulMetadataFilter
  coverage: String
  coverage_contains: String
  coverage_exists: Boolean
  coverage_in: [String]
  coverage_not: String
  coverage_not_contains: String
  coverage_not_in: [String]
  displayName: String
  displayName_contains: String
  displayName_exists: Boolean
  displayName_in: [String]
  displayName_not: String
  displayName_not_contains: String
  displayName_not_in: [String]
  filenamePrefix: String
  filenamePrefix_contains: String
  filenamePrefix_exists: Boolean
  filenamePrefix_in: [String]
  filenamePrefix_not: String
  filenamePrefix_not_contains: String
  filenamePrefix_not_in: [String]
  footer: String
  footer_contains: String
  footer_exists: Boolean
  footer_in: [String]
  footer_not: String
  footer_not_contains: String
  footer_not_in: [String]
  guaranteeScope: String
  guaranteeScope_contains: String
  guaranteeScope_exists: Boolean
  guaranteeScope_in: [String]
  guaranteeScope_not: String
  guaranteeScope_not_contains: String
  guaranteeScope_not_in: [String]
  headingBeneficiary: String
  headingBeneficiary_contains: String
  headingBeneficiary_exists: Boolean
  headingBeneficiary_in: [String]
  headingBeneficiary_not: String
  headingBeneficiary_not_contains: String
  headingBeneficiary_not_in: [String]
  headingBuildingAddress: String
  headingBuildingAddress_contains: String
  headingBuildingAddress_exists: Boolean
  headingBuildingAddress_in: [String]
  headingBuildingAddress_not: String
  headingBuildingAddress_not_contains: String
  headingBuildingAddress_not_in: [String]
  headingBuildingOwnerName: String
  headingBuildingOwnerName_contains: String
  headingBuildingOwnerName_exists: Boolean
  headingBuildingOwnerName_in: [String]
  headingBuildingOwnerName_not: String
  headingBuildingOwnerName_not_contains: String
  headingBuildingOwnerName_not_in: [String]
  headingContractor: String
  headingContractorId: String
  headingContractorId_contains: String
  headingContractorId_exists: Boolean
  headingContractorId_in: [String]
  headingContractorId_not: String
  headingContractorId_not_contains: String
  headingContractorId_not_in: [String]
  headingContractorName: String
  headingContractorName_contains: String
  headingContractorName_exists: Boolean
  headingContractorName_in: [String]
  headingContractorName_not: String
  headingContractorName_not_contains: String
  headingContractorName_not_in: [String]
  headingContractor_contains: String
  headingContractor_exists: Boolean
  headingContractor_in: [String]
  headingContractor_not: String
  headingContractor_not_contains: String
  headingContractor_not_in: [String]
  headingExpiry: String
  headingExpiry_contains: String
  headingExpiry_exists: Boolean
  headingExpiry_in: [String]
  headingExpiry_not: String
  headingExpiry_not_contains: String
  headingExpiry_not_in: [String]
  headingGuarantee: String
  headingGuaranteeId: String
  headingGuaranteeId_contains: String
  headingGuaranteeId_exists: Boolean
  headingGuaranteeId_in: [String]
  headingGuaranteeId_not: String
  headingGuaranteeId_not_contains: String
  headingGuaranteeId_not_in: [String]
  headingGuarantee_contains: String
  headingGuarantee_exists: Boolean
  headingGuarantee_in: [String]
  headingGuarantee_not: String
  headingGuarantee_not_contains: String
  headingGuarantee_not_in: [String]
  headingProducts: String
  headingProducts_contains: String
  headingProducts_exists: Boolean
  headingProducts_in: [String]
  headingProducts_not: String
  headingProducts_not_contains: String
  headingProducts_not_in: [String]
  headingRoofArea: String
  headingRoofArea_contains: String
  headingRoofArea_exists: Boolean
  headingRoofArea_in: [String]
  headingRoofArea_not: String
  headingRoofArea_not_contains: String
  headingRoofArea_not_in: [String]
  headingRoofType: String
  headingRoofType_contains: String
  headingRoofType_exists: Boolean
  headingRoofType_in: [String]
  headingRoofType_not: String
  headingRoofType_not_contains: String
  headingRoofType_not_in: [String]
  headingScope: String
  headingScope_contains: String
  headingScope_exists: Boolean
  headingScope_in: [String]
  headingScope_not: String
  headingScope_not_contains: String
  headingScope_not_in: [String]
  headingStartDate: String
  headingStartDate_contains: String
  headingStartDate_exists: Boolean
  headingStartDate_in: [String]
  headingStartDate_not: String
  headingStartDate_not_contains: String
  headingStartDate_not_in: [String]
  headingValidity: String
  headingValidity_contains: String
  headingValidity_exists: Boolean
  headingValidity_in: [String]
  headingValidity_not: String
  headingValidity_not_contains: String
  headingValidity_not_in: [String]
  languageCode: String
  languageCode_contains: String
  languageCode_exists: Boolean
  languageCode_in: [String]
  languageCode_not: String
  languageCode_not_contains: String
  languageCode_not_in: [String]
  languageDescriptor: String
  languageDescriptor_contains: String
  languageDescriptor_exists: Boolean
  languageDescriptor_in: [String]
  languageDescriptor_not: String
  languageDescriptor_not_contains: String
  languageDescriptor_not_in: [String]
  logo_exists: Boolean
  mailBody: String
  mailBody_contains: String
  mailBody_exists: Boolean
  mailBody_in: [String]
  mailBody_not: String
  mailBody_not_contains: String
  mailBody_not_in: [String]
  maintenanceTemplate_exists: Boolean
  rejectionMessage: cfMessageTemplateNestedFilter
  rejectionMessage_exists: Boolean
  roofType: String
  roofType_contains: String
  roofType_exists: Boolean
  roofType_in: [String]
  roofType_not: String
  roofType_not_contains: String
  roofType_not_in: [String]
  signatory: String
  signatory_contains: String
  signatory_exists: Boolean
  signatory_in: [String]
  signatory_not: String
  signatory_not_contains: String
  signatory_not_in: [String]
  sys: SysFilter
  technology: String
  technology_contains: String
  technology_exists: Boolean
  technology_in: [String]
  technology_not: String
  technology_not_contains: String
  technology_not_in: [String]
  terms_exists: Boolean
  titleLine1: String
  titleLine1_contains: String
  titleLine1_exists: Boolean
  titleLine1_in: [String]
  titleLine1_not: String
  titleLine1_not_contains: String
  titleLine1_not_in: [String]
  titleLine2: String
  titleLine2_contains: String
  titleLine2_exists: Boolean
  titleLine2_in: [String]
  titleLine2_not: String
  titleLine2_not_contains: String
  titleLine2_not_in: [String]
}

type GuaranteeTemplateLinkingCollections {
  entryCollection(
    limit: Int = 100
    locale: String
    preview: Boolean
    skip: Int = 0
  ): EntryCollection
  guaranteeTypeCollection(
    limit: Int = 100
    locale: String
    preview: Boolean
    skip: Int = 0
  ): GuaranteeTypeCollection
}

enum GuaranteeTemplateOrder {
  coverage_ASC
  coverage_DESC
  displayName_ASC
  displayName_DESC
  filenamePrefix_ASC
  filenamePrefix_DESC
  guaranteeScope_ASC
  guaranteeScope_DESC
  headingBeneficiary_ASC
  headingBeneficiary_DESC
  headingBuildingAddress_ASC
  headingBuildingAddress_DESC
  headingBuildingOwnerName_ASC
  headingBuildingOwnerName_DESC
  headingContractorId_ASC
  headingContractorId_DESC
  headingContractorName_ASC
  headingContractorName_DESC
  headingContractor_ASC
  headingContractor_DESC
  headingExpiry_ASC
  headingExpiry_DESC
  headingGuaranteeId_ASC
  headingGuaranteeId_DESC
  headingGuarantee_ASC
  headingGuarantee_DESC
  headingProducts_ASC
  headingProducts_DESC
  headingRoofArea_ASC
  headingRoofArea_DESC
  headingRoofType_ASC
  headingRoofType_DESC
  headingScope_ASC
  headingScope_DESC
  headingStartDate_ASC
  headingStartDate_DESC
  headingValidity_ASC
  headingValidity_DESC
  languageCode_ASC
  languageCode_DESC
  languageDescriptor_ASC
  languageDescriptor_DESC
  roofType_ASC
  roofType_DESC
  signatory_ASC
  signatory_DESC
  sys_firstPublishedAt_ASC
  sys_firstPublishedAt_DESC
  sys_id_ASC
  sys_id_DESC
  sys_publishedAt_ASC
  sys_publishedAt_DESC
  sys_publishedVersion_ASC
  sys_publishedVersion_DESC
  technology_ASC
  technology_DESC
  titleLine1_ASC
  titleLine1_DESC
  titleLine2_ASC
  titleLine2_DESC
}

"""
A type of guarantee [See type definition](https://app.contentful.com/spaces/j30snaps0u9c/content_types/guaranteeType)
"""
type GuaranteeType implements Entry {
  contentfulMetadata: ContentfulMetadata!
  coverage(locale: String): String
  displayName(locale: String): String
  evidenceCategoriesCollection(
    limit: Int = 100
    locale: String
    preview: Boolean
    skip: Int = 0
  ): GuaranteeTypeEvidenceCategoriesCollection
  guaranteeReferenceCode(locale: String): String
  guaranteeTemplatesCollection(
    limit: Int = 100
    locale: String
    preview: Boolean
    skip: Int = 0
  ): GuaranteeTypeGuaranteeTemplatesCollection
  linkedFrom(allowedLocales: [String]): GuaranteeTypeLinkingCollections
  maximumValidityYears(locale: String): Int
  name(locale: String): String
  ranking(locale: String): Int
  signature(locale: String, preview: Boolean): Asset
  sys: Sys!
  technology(locale: String): String
  tiersAvailable(locale: String): [String]
}

type GuaranteeTypeCollection {
  items: [GuaranteeType]!
  limit: Int!
  skip: Int!
  total: Int!
}

type GuaranteeTypeEvidenceCategoriesCollection {
  items: [EvidenceCategory]!
  limit: Int!
  skip: Int!
  total: Int!
}

input GuaranteeTypeFilter {
  AND: [GuaranteeTypeFilter]
  OR: [GuaranteeTypeFilter]
  contentfulMetadata: ContentfulMetadataFilter
  coverage: String
  coverage_contains: String
  coverage_exists: Boolean
  coverage_in: [String]
  coverage_not: String
  coverage_not_contains: String
  coverage_not_in: [String]
  displayName: String
  displayName_contains: String
  displayName_exists: Boolean
  displayName_in: [String]
  displayName_not: String
  displayName_not_contains: String
  displayName_not_in: [String]
  evidenceCategoriesCollection_exists: Boolean
  guaranteeReferenceCode: String
  guaranteeReferenceCode_contains: String
  guaranteeReferenceCode_exists: Boolean
  guaranteeReferenceCode_in: [String]
  guaranteeReferenceCode_not: String
  guaranteeReferenceCode_not_contains: String
  guaranteeReferenceCode_not_in: [String]
  guaranteeTemplatesCollection_exists: Boolean
  maximumValidityYears: Int
  maximumValidityYears_exists: Boolean
  maximumValidityYears_gt: Int
  maximumValidityYears_gte: Int
  maximumValidityYears_in: [Int]
  maximumValidityYears_lt: Int
  maximumValidityYears_lte: Int
  maximumValidityYears_not: Int
  maximumValidityYears_not_in: [Int]
  name: String
  name_contains: String
  name_exists: Boolean
  name_in: [String]
  name_not: String
  name_not_contains: String
  name_not_in: [String]
  ranking: Int
  ranking_exists: Boolean
  ranking_gt: Int
  ranking_gte: Int
  ranking_in: [Int]
  ranking_lt: Int
  ranking_lte: Int
  ranking_not: Int
  ranking_not_in: [Int]
  signature_exists: Boolean
  sys: SysFilter
  technology: String
  technology_contains: String
  technology_exists: Boolean
  technology_in: [String]
  technology_not: String
  technology_not_contains: String
  technology_not_in: [String]
  tiersAvailable_contains_all: [String]
  tiersAvailable_contains_none: [String]
  tiersAvailable_contains_some: [String]
  tiersAvailable_exists: Boolean
}

type GuaranteeTypeGuaranteeTemplatesCollection {
  items: [GuaranteeTemplate]!
  limit: Int!
  skip: Int!
  total: Int!
}

type GuaranteeTypeLinkingCollections {
  entryCollection(
    limit: Int = 100
    locale: String
    preview: Boolean
    skip: Int = 0
  ): EntryCollection
}

enum GuaranteeTypeOrder {
  coverage_ASC
  coverage_DESC
  displayName_ASC
  displayName_DESC
  guaranteeReferenceCode_ASC
  guaranteeReferenceCode_DESC
  maximumValidityYears_ASC
  maximumValidityYears_DESC
  name_ASC
  name_DESC
  ranking_ASC
  ranking_DESC
  sys_firstPublishedAt_ASC
  sys_firstPublishedAt_DESC
  sys_id_ASC
  sys_id_DESC
  sys_publishedAt_ASC
  sys_publishedAt_DESC
  sys_publishedVersion_ASC
  sys_publishedVersion_DESC
  technology_ASC
  technology_DESC
}

"""
A connection to a list of `Guarantee` values.
"""
type GuaranteesConnection {
  """
  A list of edges which contains the `Guarantee` and cursor to aid in pagination.
  """
  edges: [GuaranteesEdge!]!

  """
  A list of `Guarantee` objects.
  """
  nodes: [Guarantee!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Guarantee` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `Guarantee` edge in the connection.
"""
type GuaranteesEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Guarantee` at the end of the edge.
  """
  node: Guarantee!
}

"""
Methods to use when ordering `Guarantee`.
"""
enum GuaranteesOrderBy {
  BMI_REFERENCE_ID_ASC
  BMI_REFERENCE_ID_DESC
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  PRODUCT_BMI_REF_ASC
  PRODUCT_BMI_REF_DESC
  PROJECT_ID_ASC
  PROJECT_ID_DESC
  REQUESTOR_ACCOUNT_ID_ASC
  REQUESTOR_ACCOUNT_ID_DESC
  REVIEWER_ACCOUNT_ID_ASC
  REVIEWER_ACCOUNT_ID_DESC
  SYSTEM_BMI_REF_ASC
  SYSTEM_BMI_REF_DESC
}

"""
The 'HexColor' type represents color in `rgb:ffffff` string format.
"""
scalar HexColor

enum ImageFormat {
  AVIF

  """
  JPG image format.
  """
  JPG

  """
  Progressive JPG format stores multiple passes of an image in progressively higher detail.
          When a progressive image is loading, the viewer will first see a lower quality pixelated version which
          will gradually improve in detail, until the image is fully downloaded. This is to display an image as
          early as possible to make the layout look as designed.
  """
  JPG_PROGRESSIVE

  """
  PNG image format
  """
  PNG

  """
  8-bit PNG images support up to 256 colors and weigh less than the standard 24-bit PNG equivalent.
          The 8-bit PNG format is mostly used for simple images, such as icons or logos.
  """
  PNG8

  """
  WebP image format.
  """
  WEBP
}

enum ImageResizeFocus {
  """
  Focus the resizing on the bottom.
  """
  BOTTOM

  """
  Focus the resizing on the bottom left.
  """
  BOTTOM_LEFT

  """
  Focus the resizing on the bottom right.
  """
  BOTTOM_RIGHT

  """
  Focus the resizing on the center.
  """
  CENTER

  """
  Focus the resizing on the largest face.
  """
  FACE

  """
  Focus the resizing on the area containing all the faces.
  """
  FACES

  """
  Focus the resizing on the left.
  """
  LEFT

  """
  Focus the resizing on the right.
  """
  RIGHT

  """
  Focus the resizing on the top.
  """
  TOP

  """
  Focus the resizing on the top left.
  """
  TOP_LEFT

  """
  Focus the resizing on the top right.
  """
  TOP_RIGHT
}

enum ImageResizeStrategy {
  """
  Crops a part of the original image to fit into the specified dimensions.
  """
  CROP

  """
  Resizes the image to the specified dimensions, cropping the image if needed.
  """
  FILL

  """
  Resizes the image to fit into the specified dimensions.
  """
  FIT

  """
  Resizes the image to the specified dimensions, padding the image if needed.
          Uses desired background color as padding color.
  """
  PAD

  """
  Resizes the image to the specified dimensions, changing the original aspect ratio if needed.
  """
  SCALE

  """
  Creates a thumbnail from the image.
  """
  THUMB
}

input ImageTransformOptions {
  """
  Desired background color, used with corner radius or `PAD` resize strategy.
          Defaults to transparent (for `PNG`, `PNG8` and `WEBP`) or white (for `JPG` and `JPG_PROGRESSIVE`).
  """
  backgroundColor: HexColor

  """
  Desired corner radius in pixels.
          Results in an image with rounded corners (pass `-1` for a full circle/ellipse).
          Defaults to `0`. Uses desired background color as padding color,
          unless the format is `JPG` or `JPG_PROGRESSIVE` and resize strategy is `PAD`, then defaults to white.
  """
  cornerRadius: Int

  """
  Desired image format. Defaults to the original image format.
  """
  format: ImageFormat

  """
  Desired height in pixels. Defaults to the original image height.
  """
  height: Dimension

  """
  Desired quality of the image in percents.
          Used for `PNG8`, `JPG`, `JPG_PROGRESSIVE` and `WEBP` formats.
  """
  quality: Quality

  """
  Desired resize focus area. Defaults to `CENTER`.
  """
  resizeFocus: ImageResizeFocus

  """
  Desired resize strategy. Defaults to `FIT`.
  """
  resizeStrategy: ImageResizeStrategy

  """
  Desired width in pixels. Defaults to the original image width.
  """
  width: Dimension
}

input ImportAccountsCompaniesFromCSVInput {
  dryRun: Boolean
  files: [Upload!]!
}

type ImportAccountsCompaniesFromCSVResult {
  accounts: [Account]
  auth0Job: Auth0ImportResult
  companies: [Company]
  dryRun: Boolean
}

type ImportError {
  message: String
  ref: String
}

type ImportOutput {
  errorProductsToInsert: [ImportError!]
  errorProductsToUpdate: [ImportError!]
  errorSystemMembersInsert: [ImportError!]
  errorSystemsToInsert: [ImportError!]
  errorSystemsToUpdate: [ImportError!]
  productsToInsert: [Product!]
  productsToUpdate: [Product!]
  systemsToInsert: [System!]
  systemsToUpdate: [System!]
}

"""
A filter to be used against Int fields. All fields are combined with a logical ‘and.’
"""
input IntFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Int

  """
  Equal to the specified value.
  """
  equalTo: Int

  """
  Greater than the specified value.
  """
  greaterThan: Int

  """
  Greater than or equal to the specified value.
  """
  greaterThanOrEqualTo: Int

  """
  Included in the specified list.
  """
  in: [Int!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """
  Less than the specified value.
  """
  lessThan: Int

  """
  Less than or equal to the specified value.
  """
  lessThanOrEqualTo: Int

  """
  Equal to the specified value, treating null like an ordinary value.
  """
  notDistinctFrom: Int

  """
  Not equal to the specified value.
  """
  notEqualTo: Int

  """
  Not included in the specified list.
  """
  notIn: [Int!]
}

"""
An invitation to join InTouch
"""
type Invitation implements Node {
  """
  Reads a single `Company` that is related to this `Invitation`.
  """
  company: Company

  """
  fk
  """
  companyId: Int!
  createdAt: Datetime!

  """
  Primary key
  """
  id: Int!

  """
  An email address
  """
  invitee: String!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  An optional note that can be included in the invitation by the sender
  """
  personalNote: String

  """
  Reads a single `Account` that is related to this `Invitation`.
  """
  senderAccount: Account

  """
  fk
  """
  senderAccountId: Int

  """
  ek
  """
  status: InvitationStatus!
  updatedAt: Datetime!
}

"""
Input for the nested mutation of `company` in the `InvitationInput` mutation.
"""
input InvitationCompanyIdFkeyInput {
  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectById: CompanyCompanyPkeyConnect

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByMarketIdAndName: CompanyCompanyMarketIdNameKeyConnect

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByNodeId: CompanyNodeIdConnect

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByReferenceNumber: CompanyCompanyReferenceNumberKeyConnect

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteById: CompanyCompanyPkeyDelete

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByMarketIdAndName: CompanyCompanyMarketIdNameKeyDelete

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByNodeId: CompanyNodeIdDelete

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByReferenceNumber: CompanyCompanyReferenceNumberKeyDelete

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateById: CompanyOnInvitationForInvitationCompanyIdFkeyUsingCompanyPkeyUpdate

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByMarketIdAndName: CompanyOnInvitationForInvitationCompanyIdFkeyUsingCompanyMarketIdNameKeyUpdate

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByNodeId: InvitationOnInvitationForInvitationCompanyIdFkeyNodeIdUpdate

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByReferenceNumber: CompanyOnInvitationForInvitationCompanyIdFkeyUsingCompanyReferenceNumberKeyUpdate
}

"""
Input for the nested mutation of `invitation` in the `CompanyInput` mutation.
"""
input InvitationCompanyIdFkeyInverseInput {
  """
  The primary key(s) for `invitation` for the far side of the relationship.
  """
  connectById: [InvitationInvitationPkeyConnect!]

  """
  The primary key(s) for `invitation` for the far side of the relationship.
  """
  connectByNodeId: [InvitationNodeIdConnect!]

  """
  The primary key(s) for `invitation` for the far side of the relationship.
  """
  deleteById: [InvitationInvitationPkeyDelete!]

  """
  The primary key(s) for `invitation` for the far side of the relationship.
  """
  deleteByNodeId: [InvitationNodeIdDelete!]

  """
  Flag indicating whether all other `invitation` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `invitation` for the far side of the relationship.
  """
  updateById: [InvitationOnInvitationForInvitationCompanyIdFkeyUsingInvitationPkeyUpdate!]

  """
  The primary key(s) and patch data for `invitation` for the far side of the relationship.
  """
  updateByNodeId: [CompanyOnInvitationForInvitationCompanyIdFkeyNodeIdUpdate!]
}

"""
A condition to be used against `Invitation` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input InvitationCondition {
  """
  Checks for equality with the object’s `companyId` field.
  """
  companyId: Int

  """
  Checks for equality with the object’s `id` field.
  """
  id: Int

  """
  Checks for equality with the object’s `invitee` field.
  """
  invitee: String

  """
  Checks for equality with the object’s `senderAccountId` field.
  """
  senderAccountId: Int

  """
  Checks for equality with the object’s `status` field.
  """
  status: InvitationStatus
}

"""
A filter to be used against `Invitation` object types. All fields are combined with a logical ‘and.’
"""
input InvitationFilter {
  """
  Checks for all expressions in this list.
  """
  and: [InvitationFilter!]

  """
  Filter by the object’s `companyId` field.
  """
  companyId: IntFilter

  """
  Filter by the object’s `id` field.
  """
  id: IntFilter

  """
  Filter by the object’s `invitee` field.
  """
  invitee: StringFilter

  """
  Negates the expression.
  """
  not: InvitationFilter

  """
  Checks for any expressions in this list.
  """
  or: [InvitationFilter!]

  """
  Filter by the object’s `senderAccountId` field.
  """
  senderAccountId: IntFilter

  """
  Filter by the object’s `status` field.
  """
  status: InvitationStatusFilter
}

"""
The fields on `invitation` to look up the row to connect.
"""
input InvitationInvitationPkeyConnect {
  """
  Primary key
  """
  id: Int!
}

"""
The fields on `invitation` to look up the row to delete.
"""
input InvitationInvitationPkeyDelete {
  """
  Primary key
  """
  id: Int!
}

"""
The globally unique `ID` look up for the row to connect.
"""
input InvitationNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `invitation` to be connected.
  """
  nodeId: ID!
}

"""
The globally unique `ID` look up for the row to delete.
"""
input InvitationNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `invitation` to be deleted.
  """
  nodeId: ID!
}

"""
The globally unique `ID` look up for the row to update.
"""
input InvitationOnInvitationForInvitationCompanyIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `company` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: CompanyPatch!
}

"""
The fields on `invitation` to look up the row to update.
"""
input InvitationOnInvitationForInvitationCompanyIdFkeyUsingInvitationPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `invitation` being updated.
  """
  patch: updateInvitationOnInvitationForInvitationCompanyIdFkeyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input InvitationOnInvitationForInvitationSenderAccountIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `account` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: AccountPatch!
}

"""
The fields on `invitation` to look up the row to update.
"""
input InvitationOnInvitationForInvitationSenderAccountIdFkeyUsingInvitationPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `invitation` being updated.
  """
  patch: updateInvitationOnInvitationForInvitationSenderAccountIdFkeyPatch!
}

"""
Represents an update to a `Invitation`. Fields that are set will be updated.
"""
input InvitationPatch {
  accountToSenderAccountId: InvitationSenderAccountIdFkeyInput

  """
  fk
  """
  companyId: Int
  companyToCompanyId: InvitationCompanyIdFkeyInput
  createdAt: Datetime

  """
  Primary key
  """
  id: Int

  """
  An email address
  """
  invitee: String

  """
  An optional note that can be included in the invitation by the sender
  """
  personalNote: String

  """
  fk
  """
  senderAccountId: Int

  """
  ek
  """
  status: InvitationStatus
  updatedAt: Datetime
}

"""
Input for the nested mutation of `account` in the `InvitationInput` mutation.
"""
input InvitationSenderAccountIdFkeyInput {
  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByDoceboUserId: AccountAccountDoceboUserIdKeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByEmail: AccountAccountEmailKeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectById: AccountAccountPkeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByNodeId: AccountNodeIdConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByDoceboUserId: AccountAccountDoceboUserIdKeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByEmail: AccountAccountEmailKeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteById: AccountAccountPkeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByNodeId: AccountNodeIdDelete

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByDoceboUserId: AccountOnInvitationForInvitationSenderAccountIdFkeyUsingAccountDoceboUserIdKeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByEmail: AccountOnInvitationForInvitationSenderAccountIdFkeyUsingAccountEmailKeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateById: AccountOnInvitationForInvitationSenderAccountIdFkeyUsingAccountPkeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByNodeId: InvitationOnInvitationForInvitationSenderAccountIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `invitation` in the `AccountInput` mutation.
"""
input InvitationSenderAccountIdFkeyInverseInput {
  """
  The primary key(s) for `invitation` for the far side of the relationship.
  """
  connectById: [InvitationInvitationPkeyConnect!]

  """
  The primary key(s) for `invitation` for the far side of the relationship.
  """
  connectByNodeId: [InvitationNodeIdConnect!]

  """
  The primary key(s) for `invitation` for the far side of the relationship.
  """
  deleteById: [InvitationInvitationPkeyDelete!]

  """
  The primary key(s) for `invitation` for the far side of the relationship.
  """
  deleteByNodeId: [InvitationNodeIdDelete!]

  """
  Flag indicating whether all other `invitation` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `invitation` for the far side of the relationship.
  """
  updateById: [InvitationOnInvitationForInvitationSenderAccountIdFkeyUsingInvitationPkeyUpdate!]

  """
  The primary key(s) and patch data for `invitation` for the far side of the relationship.
  """
  updateByNodeId: [AccountOnInvitationForInvitationSenderAccountIdFkeyNodeIdUpdate!]
}

enum InvitationStatus {
  ACCEPTED
  CANCELLED
  NEW
}

"""
A filter to be used against InvitationStatus fields. All fields are combined with a logical ‘and.’
"""
input InvitationStatusFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: InvitationStatus

  """
  Equal to the specified value.
  """
  equalTo: InvitationStatus

  """
  Greater than the specified value.
  """
  greaterThan: InvitationStatus

  """
  Greater than or equal to the specified value.
  """
  greaterThanOrEqualTo: InvitationStatus

  """
  Included in the specified list.
  """
  in: [InvitationStatus!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """
  Less than the specified value.
  """
  lessThan: InvitationStatus

  """
  Less than or equal to the specified value.
  """
  lessThanOrEqualTo: InvitationStatus

  """
  Equal to the specified value, treating null like an ordinary value.
  """
  notDistinctFrom: InvitationStatus

  """
  Not equal to the specified value.
  """
  notEqualTo: InvitationStatus

  """
  Not included in the specified list.
  """
  notIn: [InvitationStatus!]
}

"""
A connection to a list of `Invitation` values.
"""
type InvitationsConnection {
  """
  A list of edges which contains the `Invitation` and cursor to aid in pagination.
  """
  edges: [InvitationsEdge!]!

  """
  A list of `Invitation` objects.
  """
  nodes: [Invitation!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Invitation` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `Invitation` edge in the connection.
"""
type InvitationsEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Invitation` at the end of the edge.
  """
  node: Invitation!
}

"""
Methods to use when ordering `Invitation`.
"""
enum InvitationsOrderBy {
  COMPANY_ID_ASC
  COMPANY_ID_DESC
  ID_ASC
  ID_DESC
  INVITEE_ASC
  INVITEE_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  SENDER_ACCOUNT_ID_ASC
  SENDER_ACCOUNT_ID_DESC
  STATUS_ASC
  STATUS_DESC
}

input InviteInput {
  emails: [String!]!
  firstName: String
  lastName: String
  personalNote: String
}

"""
A connection to a list of `Int` values.
"""
type InvitedByCompaniesConnection {
  """
  A list of edges which contains the `Int` and cursor to aid in pagination.
  """
  edges: [InvitedByCompanyEdge!]!

  """
  A list of `Int` objects.
  """
  nodes: [Int]!

  """
  The count of *all* `Int` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `Int` edge in the connection.
"""
type InvitedByCompanyEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Int` at the end of the edge.
  """
  node: Int
}

"""
A connection to a list of `Int` values.
"""
type IsPartOfProjectConnection {
  """
  A list of edges which contains the `Int` and cursor to aid in pagination.
  """
  edges: [IsPartOfProjectEdge!]!

  """
  A list of `Int` objects.
  """
  nodes: [Int]!

  """
  The count of *all* `Int` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `Int` edge in the connection.
"""
type IsPartOfProjectEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Int` at the end of the edge.
  """
  node: Int
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

enum Language {
  DA
  DE
  EN
  ES
  FI
  FR
  IT
  NL
  NO
  PL
  PT
  SK
  SV
}

"""
All input for the `linkAccountToCompany` mutation.
"""
input LinkAccountToCompanyInput {
  accountId: Int

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  companyId: Int
}

"""
The output of our `linkAccountToCompany` mutation.
"""
type LinkAccountToCompanyPayload {
  """
  Reads a single `Account` that is related to this `CompanyMember`.
  """
  account: Account

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Company` that is related to this `CompanyMember`.
  """
  company: Company
  companyMember: CompanyMember

  """
  An edge for our `CompanyMember`. May be used by Relay 1.
  """
  companyMemberEdge(
    """
    The method to use when ordering `CompanyMember`.
    """
    orderBy: [CompanyMembersOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompanyMembersEdge

  """
  Reads a single `Market` that is related to this `CompanyMember`.
  """
  market: Market

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `markAllNotificationsAsRead` mutation.
"""
input MarkAllNotificationsAsReadInput {
  accountToUpdateId: Int

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""
The output of our `markAllNotificationsAsRead` mutation.
"""
type MarkAllNotificationsAsReadPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  notifications: [Notification!]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
A country that BMI operates in
"""
type Market implements Node {
  """
  Reads and enables pagination through a set of `Account`.
  """
  accounts(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AccountCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AccountFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Account`.
    """
    orderBy: [AccountsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AccountsConnection!

  """
  The space in Contenful
  """
  cmsSpaceId: String

  """
  Reads and enables pagination through a set of `Company`.
  """
  companies(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CompanyCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CompanyFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Company`.
    """
    orderBy: [CompaniesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompaniesConnection!

  """
  Reads and enables pagination through a set of `CompanyMember`.
  """
  companyMembers(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CompanyMemberCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CompanyMemberFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `CompanyMember`.
    """
    orderBy: [CompanyMembersOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompanyMembersConnection!
  createdAt: Datetime!

  """
  The default catalogue for the Market.  All users in the Market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int
  doceboCatalogueIdT2: Int
  doceboCatalogueIdT3: Int
  doceboCatalogueIdT4: Int

  """
  The Docebo branch that new user are inserted into if they register as a Company Admin. Note that this never gets updated by InTouch. Originally there was going to be a distinction between installer branches and admin branches in Docebo, but this is no longer the preferred approach.
  """
  doceboCompanyAdminBranchId: String

  """
  The Docebo branch that new user are inserted into if they register as an installer.  Note that this never gets updated by InTouch.  Originally there was going to be a distinction between installer branches and admin branches in Docebo, but this is no longer the preferred approach.
  """
  doceboInstallersBranchId: String

  """
  the country code used for example as the subdomain
  """
  domain: String!

  """
  The coordinates of the middle of the Market on a map
  """
  geoMiddle: Point

  """
  Reference to the Google Analytics tracking ID that is used for the Country GA reports
  """
  gtag: String
  gtagMarketMedia: String

  """
  Primary key
  """
  id: Int!

  """
  ek
  """
  language: Language!

  """
  The length of the radius in km (from the geo_middle lat/lng), for which the Google Places API biases the search results for address autocomplete. Locations outside of the radius will not be excluded.
  """
  locationBiasRadiusKm: Int

  """
  The address of the merchandising site for the market.  CTAs of the MERCHANDISING type will link to this address
  """
  merchandisingUrl: String

  """
  A short name for the market, e.g. Italy, Norway, Netherlands
  """
  name: String

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Reads and enables pagination through a set of `Product`.
  """
  products(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProductCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProductFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Product`.
    """
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProductsConnection!

  """
  Whether the market supports Projects.  If so then the Projects link should be available in th left hand navigation.
  """
  projectsEnabled: Boolean

  """
  The mailbox on intouch.bmigroup.com that emails will be sent from for this Market
  """
  sendMailbox: String

  """
  The From name used when sending an email
  """
  sendName: String

  """
  Reads and enables pagination through a set of `SystemMember`.
  """
  systemMembers(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SystemMemberCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SystemMemberFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `SystemMember`.
    """
    orderBy: [SystemMembersOrderBy!] = [PRIMARY_KEY_ASC]
  ): SystemMembersConnection!

  """
  Reads and enables pagination through a set of `System`.
  """
  systems(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SystemCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SystemFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `System`.
    """
    orderBy: [SystemsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SystemsConnection!
  updatedAt: Datetime!
}

"""
A condition to be used against `Market` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input MarketCondition {
  """
  Checks for equality with the object’s `doceboCatalogueId` field.
  """
  doceboCatalogueId: Int

  """
  Checks for equality with the object’s `domain` field.
  """
  domain: String

  """
  Checks for equality with the object’s `id` field.
  """
  id: Int
}

"""
[See type definition](https://app.contentful.com/spaces/j30snaps0u9c/content_types/marketContent)
"""
type MarketContent implements Entry {
  contactUsPage(locale: String, preview: Boolean): ContentArticle
  contactsCollection(
    limit: Int = 100
    locale: String
    preview: Boolean
    skip: Int = 0
  ): MarketContentContactsCollection
  contentfulMetadata: ContentfulMetadata!
  externalLinkLabel(locale: String): String
  externalLinkUrl(locale: String): String
  footerLinksCollection(
    limit: Int = 100
    locale: String
    preview: Boolean
    skip: Int = 0
  ): MarketContentFooterLinksCollection
  linkedFrom(allowedLocales: [String]): MarketContentLinkingCollections
  live(locale: String): String
  mediaLibraryRootCollection(
    limit: Int = 100
    locale: String
    preview: Boolean
    skip: Int = 0
  ): MarketContentMediaLibraryRootCollection
  name(locale: String): String
  newsItemCta(locale: String): String
  newsItemHeading(locale: String): String
  newsItemUrl(locale: String): String
  partnerBrandsCollection(
    limit: Int = 100
    locale: String
    preview: Boolean
    skip: Int = 0
  ): MarketContentPartnerBrandsCollection
  sys: Sys!
}

type MarketContentCollection {
  items: [MarketContent]!
  limit: Int!
  skip: Int!
  total: Int!
}

type MarketContentContactsCollection {
  items: [ContactDetails]!
  limit: Int!
  skip: Int!
  total: Int!
}

input MarketContentFilter {
  AND: [MarketContentFilter]
  OR: [MarketContentFilter]
  contactUsPage: cfContentArticleNestedFilter
  contactUsPage_exists: Boolean
  contactsCollection_exists: Boolean
  contentfulMetadata: ContentfulMetadataFilter
  externalLinkLabel: String
  externalLinkLabel_contains: String
  externalLinkLabel_exists: Boolean
  externalLinkLabel_in: [String]
  externalLinkLabel_not: String
  externalLinkLabel_not_contains: String
  externalLinkLabel_not_in: [String]
  externalLinkUrl: String
  externalLinkUrl_contains: String
  externalLinkUrl_exists: Boolean
  externalLinkUrl_in: [String]
  externalLinkUrl_not: String
  externalLinkUrl_not_contains: String
  externalLinkUrl_not_in: [String]
  footerLinksCollection_exists: Boolean
  live: String
  live_contains: String
  live_exists: Boolean
  live_in: [String]
  live_not: String
  live_not_contains: String
  live_not_in: [String]
  mediaLibraryRootCollection_exists: Boolean
  name: String
  name_contains: String
  name_exists: Boolean
  name_in: [String]
  name_not: String
  name_not_contains: String
  name_not_in: [String]
  newsItemCta: String
  newsItemCta_contains: String
  newsItemCta_exists: Boolean
  newsItemCta_in: [String]
  newsItemCta_not: String
  newsItemCta_not_contains: String
  newsItemCta_not_in: [String]
  newsItemHeading: String
  newsItemHeading_contains: String
  newsItemHeading_exists: Boolean
  newsItemHeading_in: [String]
  newsItemHeading_not: String
  newsItemHeading_not_contains: String
  newsItemHeading_not_in: [String]
  newsItemUrl: String
  newsItemUrl_contains: String
  newsItemUrl_exists: Boolean
  newsItemUrl_in: [String]
  newsItemUrl_not: String
  newsItemUrl_not_contains: String
  newsItemUrl_not_in: [String]
  partnerBrandsCollection_exists: Boolean
  sys: SysFilter
}

type MarketContentFooterLinksCollection {
  items: [ContentArticle]!
  limit: Int!
  skip: Int!
  total: Int!
}

type MarketContentLinkingCollections {
  entryCollection(
    limit: Int = 100
    locale: String
    preview: Boolean
    skip: Int = 0
  ): EntryCollection
}

type MarketContentMediaLibraryRootCollection {
  items: [MediaFolder]!
  limit: Int!
  skip: Int!
  total: Int!
}

enum MarketContentOrder {
  externalLinkLabel_ASC
  externalLinkLabel_DESC
  externalLinkUrl_ASC
  externalLinkUrl_DESC
  live_ASC
  live_DESC
  name_ASC
  name_DESC
  newsItemCta_ASC
  newsItemCta_DESC
  newsItemHeading_ASC
  newsItemHeading_DESC
  newsItemUrl_ASC
  newsItemUrl_DESC
  sys_firstPublishedAt_ASC
  sys_firstPublishedAt_DESC
  sys_id_ASC
  sys_id_DESC
  sys_publishedAt_ASC
  sys_publishedAt_DESC
  sys_publishedVersion_ASC
  sys_publishedVersion_DESC
}

type MarketContentPartnerBrandsCollection {
  items: [PartnerBrand]!
  limit: Int!
  skip: Int!
  total: Int!
}

"""
A filter to be used against `Market` object types. All fields are combined with a logical ‘and.’
"""
input MarketFilter {
  """
  Checks for all expressions in this list.
  """
  and: [MarketFilter!]

  """
  Filter by the object’s `doceboCatalogueId` field.
  """
  doceboCatalogueId: IntFilter

  """
  Filter by the object’s `domain` field.
  """
  domain: StringFilter

  """
  Filter by the object’s `id` field.
  """
  id: IntFilter

  """
  Negates the expression.
  """
  not: MarketFilter

  """
  Checks for any expressions in this list.
  """
  or: [MarketFilter!]
}

"""
An input for mutations affecting `Market`
"""
input MarketInput {
  accountsUsingId: AccountMarketIdFkeyInverseInput

  """
  The space in Contenful
  """
  cmsSpaceId: String
  companiesUsingId: CompanyMarketIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberMarketIdFkeyInverseInput
  createdAt: Datetime

  """
  The default catalogue for the Market.  All users in the Market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int
  doceboCatalogueIdT2: Int
  doceboCatalogueIdT3: Int
  doceboCatalogueIdT4: Int

  """
  The Docebo branch that new user are inserted into if they register as a Company Admin. Note that this never gets updated by InTouch. Originally there was going to be a distinction between installer branches and admin branches in Docebo, but this is no longer the preferred approach.
  """
  doceboCompanyAdminBranchId: String

  """
  The Docebo branch that new user are inserted into if they register as an installer.  Note that this never gets updated by InTouch.  Originally there was going to be a distinction between installer branches and admin branches in Docebo, but this is no longer the preferred approach.
  """
  doceboInstallersBranchId: String

  """
  the country code used for example as the subdomain
  """
  domain: String!

  """
  The coordinates of the middle of the Market on a map
  """
  geoMiddle: PointInput

  """
  Reference to the Google Analytics tracking ID that is used for the Country GA reports
  """
  gtag: String
  gtagMarketMedia: String

  """
  Primary key
  """
  id: Int

  """
  ek
  """
  language: Language!

  """
  The length of the radius in km (from the geo_middle lat/lng), for which the Google Places API biases the search results for address autocomplete. Locations outside of the radius will not be excluded.
  """
  locationBiasRadiusKm: Int

  """
  The address of the merchandising site for the market.  CTAs of the MERCHANDISING type will link to this address
  """
  merchandisingUrl: String

  """
  A short name for the market, e.g. Italy, Norway, Netherlands
  """
  name: String
  productsUsingId: ProductMarketIdFkeyInverseInput

  """
  Whether the market supports Projects.  If so then the Projects link should be available in th left hand navigation.
  """
  projectsEnabled: Boolean

  """
  The mailbox on intouch.bmigroup.com that emails will be sent from for this Market
  """
  sendMailbox: String

  """
  The From name used when sending an email
  """
  sendName: String
  systemMembersUsingId: SystemMemberMarketIdFkeyInverseInput
  systemsUsingId: SystemMarketIdFkeyInverseInput
  updatedAt: Datetime
}

"""
The fields on `market` to look up the row to connect.
"""
input MarketMarketDoceboCatalogueIdKeyConnect {
  """
  The default catalogue for the Market.  All users in the Market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int!
}

"""
The fields on `market` to look up the row to delete.
"""
input MarketMarketDoceboCatalogueIdKeyDelete {
  """
  The default catalogue for the Market.  All users in the Market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int!
}

"""
The fields on `market` to look up the row to connect.
"""
input MarketMarketDomainKeyConnect {
  """
  the country code used for example as the subdomain
  """
  domain: String!
}

"""
The fields on `market` to look up the row to delete.
"""
input MarketMarketDomainKeyDelete {
  """
  the country code used for example as the subdomain
  """
  domain: String!
}

"""
The fields on `market` to look up the row to connect.
"""
input MarketMarketPkeyConnect {
  """
  Primary key
  """
  id: Int!
}

"""
The fields on `market` to look up the row to delete.
"""
input MarketMarketPkeyDelete {
  """
  Primary key
  """
  id: Int!
}

"""
The globally unique `ID` look up for the row to connect.
"""
input MarketNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `market` to be connected.
  """
  nodeId: ID!
}

"""
The globally unique `ID` look up for the row to delete.
"""
input MarketNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `market` to be deleted.
  """
  nodeId: ID!
}

"""
The globally unique `ID` look up for the row to update.
"""
input MarketOnAccountForAccountMarketIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `account` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: AccountPatch!
}

"""
The fields on `market` to look up the row to update.
"""
input MarketOnAccountForAccountMarketIdFkeyUsingMarketDoceboCatalogueIdKeyUpdate {
  """
  The default catalogue for the Market.  All users in the Market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int!

  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: updateMarketOnAccountForAccountMarketIdFkeyPatch!
}

"""
The fields on `market` to look up the row to update.
"""
input MarketOnAccountForAccountMarketIdFkeyUsingMarketDomainKeyUpdate {
  """
  the country code used for example as the subdomain
  """
  domain: String!

  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: updateMarketOnAccountForAccountMarketIdFkeyPatch!
}

"""
The fields on `market` to look up the row to update.
"""
input MarketOnAccountForAccountMarketIdFkeyUsingMarketPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: updateMarketOnAccountForAccountMarketIdFkeyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input MarketOnCompanyForCompanyMarketIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `company` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: CompanyPatch!
}

"""
The fields on `market` to look up the row to update.
"""
input MarketOnCompanyForCompanyMarketIdFkeyUsingMarketDoceboCatalogueIdKeyUpdate {
  """
  The default catalogue for the Market.  All users in the Market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int!

  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: updateMarketOnCompanyForCompanyMarketIdFkeyPatch!
}

"""
The fields on `market` to look up the row to update.
"""
input MarketOnCompanyForCompanyMarketIdFkeyUsingMarketDomainKeyUpdate {
  """
  the country code used for example as the subdomain
  """
  domain: String!

  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: updateMarketOnCompanyForCompanyMarketIdFkeyPatch!
}

"""
The fields on `market` to look up the row to update.
"""
input MarketOnCompanyForCompanyMarketIdFkeyUsingMarketPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: updateMarketOnCompanyForCompanyMarketIdFkeyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input MarketOnCompanyMemberForCompanyMemberMarketIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `companyMember` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `companyMember` being updated.
  """
  patch: CompanyMemberPatch!
}

"""
The fields on `market` to look up the row to update.
"""
input MarketOnCompanyMemberForCompanyMemberMarketIdFkeyUsingMarketDoceboCatalogueIdKeyUpdate {
  """
  The default catalogue for the Market.  All users in the Market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int!

  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: updateMarketOnCompanyMemberForCompanyMemberMarketIdFkeyPatch!
}

"""
The fields on `market` to look up the row to update.
"""
input MarketOnCompanyMemberForCompanyMemberMarketIdFkeyUsingMarketDomainKeyUpdate {
  """
  the country code used for example as the subdomain
  """
  domain: String!

  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: updateMarketOnCompanyMemberForCompanyMemberMarketIdFkeyPatch!
}

"""
The fields on `market` to look up the row to update.
"""
input MarketOnCompanyMemberForCompanyMemberMarketIdFkeyUsingMarketPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: updateMarketOnCompanyMemberForCompanyMemberMarketIdFkeyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input MarketOnProductForProductMarketIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `product` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `product` being updated.
  """
  patch: ProductPatch!
}

"""
The fields on `market` to look up the row to update.
"""
input MarketOnProductForProductMarketIdFkeyUsingMarketDoceboCatalogueIdKeyUpdate {
  """
  The default catalogue for the Market.  All users in the Market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int!

  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: updateMarketOnProductForProductMarketIdFkeyPatch!
}

"""
The fields on `market` to look up the row to update.
"""
input MarketOnProductForProductMarketIdFkeyUsingMarketDomainKeyUpdate {
  """
  the country code used for example as the subdomain
  """
  domain: String!

  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: updateMarketOnProductForProductMarketIdFkeyPatch!
}

"""
The fields on `market` to look up the row to update.
"""
input MarketOnProductForProductMarketIdFkeyUsingMarketPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: updateMarketOnProductForProductMarketIdFkeyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input MarketOnSystemForSystemMarketIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `system` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `system` being updated.
  """
  patch: SystemPatch!
}

"""
The fields on `market` to look up the row to update.
"""
input MarketOnSystemForSystemMarketIdFkeyUsingMarketDoceboCatalogueIdKeyUpdate {
  """
  The default catalogue for the Market.  All users in the Market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int!

  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: updateMarketOnSystemForSystemMarketIdFkeyPatch!
}

"""
The fields on `market` to look up the row to update.
"""
input MarketOnSystemForSystemMarketIdFkeyUsingMarketDomainKeyUpdate {
  """
  the country code used for example as the subdomain
  """
  domain: String!

  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: updateMarketOnSystemForSystemMarketIdFkeyPatch!
}

"""
The fields on `market` to look up the row to update.
"""
input MarketOnSystemForSystemMarketIdFkeyUsingMarketPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: updateMarketOnSystemForSystemMarketIdFkeyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input MarketOnSystemMemberForSystemMemberMarketIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `systemMember` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `systemMember` being updated.
  """
  patch: SystemMemberPatch!
}

"""
The fields on `market` to look up the row to update.
"""
input MarketOnSystemMemberForSystemMemberMarketIdFkeyUsingMarketDoceboCatalogueIdKeyUpdate {
  """
  The default catalogue for the Market.  All users in the Market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int!

  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: updateMarketOnSystemMemberForSystemMemberMarketIdFkeyPatch!
}

"""
The fields on `market` to look up the row to update.
"""
input MarketOnSystemMemberForSystemMemberMarketIdFkeyUsingMarketDomainKeyUpdate {
  """
  the country code used for example as the subdomain
  """
  domain: String!

  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: updateMarketOnSystemMemberForSystemMemberMarketIdFkeyPatch!
}

"""
The fields on `market` to look up the row to update.
"""
input MarketOnSystemMemberForSystemMemberMarketIdFkeyUsingMarketPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: updateMarketOnSystemMemberForSystemMemberMarketIdFkeyPatch!
}

"""
Represents an update to a `Market`. Fields that are set will be updated.
"""
input MarketPatch {
  accountsUsingId: AccountMarketIdFkeyInverseInput

  """
  The space in Contenful
  """
  cmsSpaceId: String
  companiesUsingId: CompanyMarketIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberMarketIdFkeyInverseInput
  createdAt: Datetime

  """
  The default catalogue for the Market.  All users in the Market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int
  doceboCatalogueIdT2: Int
  doceboCatalogueIdT3: Int
  doceboCatalogueIdT4: Int

  """
  The Docebo branch that new user are inserted into if they register as a Company Admin. Note that this never gets updated by InTouch. Originally there was going to be a distinction between installer branches and admin branches in Docebo, but this is no longer the preferred approach.
  """
  doceboCompanyAdminBranchId: String

  """
  The Docebo branch that new user are inserted into if they register as an installer.  Note that this never gets updated by InTouch.  Originally there was going to be a distinction between installer branches and admin branches in Docebo, but this is no longer the preferred approach.
  """
  doceboInstallersBranchId: String

  """
  the country code used for example as the subdomain
  """
  domain: String

  """
  The coordinates of the middle of the Market on a map
  """
  geoMiddle: PointInput

  """
  Reference to the Google Analytics tracking ID that is used for the Country GA reports
  """
  gtag: String
  gtagMarketMedia: String

  """
  Primary key
  """
  id: Int

  """
  ek
  """
  language: Language

  """
  The length of the radius in km (from the geo_middle lat/lng), for which the Google Places API biases the search results for address autocomplete. Locations outside of the radius will not be excluded.
  """
  locationBiasRadiusKm: Int

  """
  The address of the merchandising site for the market.  CTAs of the MERCHANDISING type will link to this address
  """
  merchandisingUrl: String

  """
  A short name for the market, e.g. Italy, Norway, Netherlands
  """
  name: String
  productsUsingId: ProductMarketIdFkeyInverseInput

  """
  Whether the market supports Projects.  If so then the Projects link should be available in th left hand navigation.
  """
  projectsEnabled: Boolean

  """
  The mailbox on intouch.bmigroup.com that emails will be sent from for this Market
  """
  sendMailbox: String

  """
  The From name used when sending an email
  """
  sendName: String
  systemMembersUsingId: SystemMemberMarketIdFkeyInverseInput
  systemsUsingId: SystemMarketIdFkeyInverseInput
  updatedAt: Datetime
}

"""
A connection to a list of `Market` values.
"""
type MarketsConnection {
  """
  A list of edges which contains the `Market` and cursor to aid in pagination.
  """
  edges: [MarketsEdge!]!

  """
  A list of `Market` objects.
  """
  nodes: [Market!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Market` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `Market` edge in the connection.
"""
type MarketsEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Market` at the end of the edge.
  """
  node: Market!
}

"""
Methods to use when ordering `Market`.
"""
enum MarketsOrderBy {
  DOCEBO_CATALOGUE_ID_ASC
  DOCEBO_CATALOGUE_ID_DESC
  DOMAIN_ASC
  DOMAIN_DESC
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A folder used for categorising the presentation in the Media Tools Library [See type definition](https://app.contentful.com/spaces/j30snaps0u9c/content_types/mediaFolder)
"""
type MediaFolder implements Entry {
  childrenCollection(
    limit: Int = 100
    locale: String
    preview: Boolean
    skip: Int = 0
  ): MediaFolderChildrenCollection
  contentfulMetadata: ContentfulMetadata!
  linkedFrom(allowedLocales: [String]): MediaFolderLinkingCollections
  name(locale: String): String
  sys: Sys!
}

type MediaFolderChildrenCollection {
  items: [MediaFolderChildrenItem]!
  limit: Int!
  skip: Int!
  total: Int!
}

union MediaFolderChildrenItem = MediaFolder | MediaTool

type MediaFolderCollection {
  items: [MediaFolder]!
  limit: Int!
  skip: Int!
  total: Int!
}

input MediaFolderFilter {
  AND: [MediaFolderFilter]
  OR: [MediaFolderFilter]
  childrenCollection_exists: Boolean
  contentfulMetadata: ContentfulMetadataFilter
  name: String
  name_contains: String
  name_exists: Boolean
  name_in: [String]
  name_not: String
  name_not_contains: String
  name_not_in: [String]
  sys: SysFilter
}

type MediaFolderLinkingCollections {
  entryCollection(
    limit: Int = 100
    locale: String
    preview: Boolean
    skip: Int = 0
  ): EntryCollection
  marketContentCollection(
    limit: Int = 100
    locale: String
    preview: Boolean
    skip: Int = 0
  ): MarketContentCollection
  mediaFolderCollection(
    limit: Int = 100
    locale: String
    preview: Boolean
    skip: Int = 0
  ): MediaFolderCollection
}

enum MediaFolderOrder {
  name_ASC
  name_DESC
  sys_firstPublishedAt_ASC
  sys_firstPublishedAt_DESC
  sys_id_ASC
  sys_id_DESC
  sys_publishedAt_ASC
  sys_publishedAt_DESC
  sys_publishedVersion_ASC
  sys_publishedVersion_DESC
}

"""
Media which is hosted on Contentful [See type definition](https://app.contentful.com/spaces/j30snaps0u9c/content_types/mediaTool)
"""
type MediaTool implements Entry {
  contentfulMetadata: ContentfulMetadata!
  linkedFrom(allowedLocales: [String]): MediaToolLinkingCollections
  media(locale: String, preview: Boolean): Asset
  name(locale: String): String
  sys: Sys!
  thumbnail(locale: String, preview: Boolean): Asset
  url(locale: String): String
}

type MediaToolCollection {
  items: [MediaTool]!
  limit: Int!
  skip: Int!
  total: Int!
}

input MediaToolFilter {
  AND: [MediaToolFilter]
  OR: [MediaToolFilter]
  contentfulMetadata: ContentfulMetadataFilter
  media_exists: Boolean
  name: String
  name_contains: String
  name_exists: Boolean
  name_in: [String]
  name_not: String
  name_not_contains: String
  name_not_in: [String]
  sys: SysFilter
  thumbnail_exists: Boolean
  url: String
  url_contains: String
  url_exists: Boolean
  url_in: [String]
  url_not: String
  url_not_contains: String
  url_not_in: [String]
}

type MediaToolLinkingCollections {
  entryCollection(
    limit: Int = 100
    locale: String
    preview: Boolean
    skip: Int = 0
  ): EntryCollection
  mediaFolderCollection(
    limit: Int = 100
    locale: String
    preview: Boolean
    skip: Int = 0
  ): MediaFolderCollection
}

enum MediaToolOrder {
  name_ASC
  name_DESC
  sys_firstPublishedAt_ASC
  sys_firstPublishedAt_DESC
  sys_id_ASC
  sys_id_DESC
  sys_publishedAt_ASC
  sys_publishedAt_DESC
  sys_publishedVersion_ASC
  sys_publishedVersion_DESC
  url_ASC
  url_DESC
}

"""
A template for email and/or notifications [See type definition](https://app.contentful.com/spaces/j30snaps0u9c/content_types/messageTemplate)
"""
type MessageTemplate implements Entry {
  contentfulMetadata: ContentfulMetadata!
  emailBody(locale: String): String
  event(locale: String): String
  format(locale: String): [String]
  linkedFrom(allowedLocales: [String]): MessageTemplateLinkingCollections
  notificationBody(locale: String): String
  subject(locale: String): String
  sys: Sys!
}

type MessageTemplateCollection {
  items: [MessageTemplate]!
  limit: Int!
  skip: Int!
  total: Int!
}

input MessageTemplateFilter {
  AND: [MessageTemplateFilter]
  OR: [MessageTemplateFilter]
  contentfulMetadata: ContentfulMetadataFilter
  emailBody: String
  emailBody_contains: String
  emailBody_exists: Boolean
  emailBody_in: [String]
  emailBody_not: String
  emailBody_not_contains: String
  emailBody_not_in: [String]
  event: String
  event_contains: String
  event_exists: Boolean
  event_in: [String]
  event_not: String
  event_not_contains: String
  event_not_in: [String]
  format_contains_all: [String]
  format_contains_none: [String]
  format_contains_some: [String]
  format_exists: Boolean
  notificationBody: String
  notificationBody_contains: String
  notificationBody_exists: Boolean
  notificationBody_in: [String]
  notificationBody_not: String
  notificationBody_not_contains: String
  notificationBody_not_in: [String]
  subject: String
  subject_contains: String
  subject_exists: Boolean
  subject_in: [String]
  subject_not: String
  subject_not_contains: String
  subject_not_in: [String]
  sys: SysFilter
}

type MessageTemplateLinkingCollections {
  entryCollection(
    limit: Int = 100
    locale: String
    preview: Boolean
    skip: Int = 0
  ): EntryCollection
  guaranteeTemplateCollection(
    limit: Int = 100
    locale: String
    preview: Boolean
    skip: Int = 0
  ): GuaranteeTemplateCollection
}

enum MessageTemplateOrder {
  event_ASC
  event_DESC
  notificationBody_ASC
  notificationBody_DESC
  subject_ASC
  subject_DESC
  sys_firstPublishedAt_ASC
  sys_firstPublishedAt_DESC
  sys_id_ASC
  sys_id_DESC
  sys_publishedAt_ASC
  sys_publishedAt_DESC
  sys_publishedVersion_ASC
  sys_publishedVersion_DESC
}

"""
Meta data to store the state of content model through migrations [See type definition](https://app.contentful.com/spaces/j30snaps0u9c/content_types/migration)
"""
type Migration implements Entry {
  contentTypeId(locale: String): String
  contentfulMetadata: ContentfulMetadata!
  linkedFrom(allowedLocales: [String]): MigrationLinkingCollections
  state(locale: String): JSON
  sys: Sys!
}

type MigrationCollection {
  items: [Migration]!
  limit: Int!
  skip: Int!
  total: Int!
}

input MigrationFilter {
  AND: [MigrationFilter]
  OR: [MigrationFilter]
  contentTypeId: String
  contentTypeId_contains: String
  contentTypeId_exists: Boolean
  contentTypeId_in: [String]
  contentTypeId_not: String
  contentTypeId_not_contains: String
  contentTypeId_not_in: [String]
  contentfulMetadata: ContentfulMetadataFilter
  sys: SysFilter
}

type MigrationLinkingCollections {
  entryCollection(
    limit: Int = 100
    locale: String
    preview: Boolean
    skip: Int = 0
  ): EntryCollection
}

enum MigrationOrder {
  contentTypeId_ASC
  contentTypeId_DESC
  sys_firstPublishedAt_ASC
  sys_firstPublishedAt_DESC
  sys_id_ASC
  sys_id_DESC
  sys_publishedAt_ASC
  sys_publishedAt_DESC
  sys_publishedVersion_ASC
  sys_publishedVersion_DESC
}

"""
The root mutation type which contains root level fields which mutate data.
"""
type Mutation {
  archiveProjects: String
  bulkImport(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: BulkImportInput!
  ): ImportOutput
  completeInvitation(companyId: Int!): Account
  courseCatalogueUpdate(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CourseCatalogueUpdateInput!
  ): CourseCatalogueUpdatePayload
  courseCatalogueUpdateByTemp(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CourseCatalogueUpdateByTempInput!
  ): CourseCatalogueUpdateByTempPayload
  courseEnrollmentUpdate(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CourseEnrollmentUpdateInput!
  ): CourseEnrollmentUpdatePayload
  courseEnrollmentUpdateByTemp(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CourseEnrollmentUpdateByTempInput!
  ): CourseEnrollmentUpdateByTempPayload
  courseUpdate(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CourseUpdateInput!
  ): CourseUpdatePayload
  courseUpdateByTemp(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CourseUpdateByTempInput!
  ): CourseUpdateByTempPayload
  createAccount(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateAccountInput!
  ): CreateAccountPayload

  """
  Creates a single `Address`.
  """
  createAddress(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateAddressInput!
  ): CreateAddressPayload

  """
  Creates a single `Certification`.
  """
  createCertification(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCertificationInput!
  ): CreateCertificationPayload
  createCompany(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCompanyInput!
  ): CreateCompanyPayload

  """
  Creates a single `CompanyDocument`.
  """
  createCompanyDocument(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCompanyDocumentInput!
  ): CreateCompanyDocumentPayload
  createCompanyDocuments(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCompanyDocumentsInput!
  ): CreateCompanyDocumentsPayload

  """
  Creates a single `CompanyMember`.
  """
  createCompanyMember(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCompanyMemberInput!
  ): CreateCompanyMemberPayload

  """
  Creates a single `CompanyOperation`.
  """
  createCompanyOperation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCompanyOperationInput!
  ): CreateCompanyOperationPayload

  """
  Creates a single `Course`.
  """
  createCourse(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCourseInput!
  ): CreateCoursePayload

  """
  Creates a single `CourseCatalogue`.
  """
  createCourseCatalogue(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCourseCatalogueInput!
  ): CreateCourseCataloguePayload

  """
  Creates a single `CourseCatalogueTemp`.
  """
  createCourseCatalogueTemp(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCourseCatalogueTempInput!
  ): CreateCourseCatalogueTempPayload

  """
  Creates a single `CourseEnrollment`.
  """
  createCourseEnrollment(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCourseEnrollmentInput!
  ): CreateCourseEnrollmentPayload

  """
  Creates a single `CourseEnrollmentTemp`.
  """
  createCourseEnrollmentTemp(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCourseEnrollmentTempInput!
  ): CreateCourseEnrollmentTempPayload

  """
  Creates a single `CourseSyncConfiguration`.
  """
  createCourseSyncConfiguration(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCourseSyncConfigurationInput!
  ): CreateCourseSyncConfigurationPayload

  """
  Creates a single `CourseTemp`.
  """
  createCourseTemp(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCourseTempInput!
  ): CreateCourseTempPayload

  """
  Creates a single `DoceboTier`.
  """
  createDoceboTier(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateDoceboTierInput!
  ): CreateDoceboTierPayload
  createDoceboUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UserCreateInput
  ): UserCreateResponse

  """
  Creates a single `EvidenceItem`.
  """
  createEvidenceItem(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateEvidenceItemInput!
  ): CreateEvidenceItemPayload

  """
  Creates a single `Guarantee`.
  """
  createGuarantee(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateGuaranteeInput!
  ): CreateGuaranteePayload
  createGuaranteePdf(id: Int!): PublishOutput

  """
  Creates a single `Market`.
  """
  createMarket(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateMarketInput!
  ): CreateMarketPayload

  """
  Creates a single `Note`.
  """
  createNote(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateNoteInput!
  ): CreateNotePayload

  """
  Creates a single `Notification`.
  """
  createNotification(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateNotificationInput!
  ): CreateNotificationPayload

  """
  Creates a single `Product`.
  """
  createProduct(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateProductInput!
  ): CreateProductPayload

  """
  Creates a single `Project`.
  """
  createProject(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateProjectInput!
  ): CreateProjectPayload

  """
  Creates a single `ProjectMember`.
  """
  createProjectMember(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateProjectMemberInput!
  ): CreateProjectMemberPayload
  createSSOUrl(path: String, username: String!): SSOUrlOutput

  """
  Creates a single `System`.
  """
  createSystem(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateSystemInput!
  ): CreateSystemPayload

  """
  Creates a single `SystemMember`.
  """
  createSystemMember(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateSystemMemberInput!
  ): CreateSystemMemberPayload

  """
  Deletes a single `Account` using a unique key.
  """
  deleteAccount(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAccountInput!
  ): DeleteAccountPayload

  """
  Deletes a single `Account` using a unique key.
  """
  deleteAccountByDoceboUserId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAccountByDoceboUserIdInput!
  ): DeleteAccountPayload

  """
  Deletes a single `Account` using a unique key.
  """
  deleteAccountByEmail(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAccountByEmailInput!
  ): DeleteAccountPayload

  """
  Deletes a single `Account` using its globally unique id.
  """
  deleteAccountByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAccountByNodeIdInput!
  ): DeleteAccountPayload

  """
  Deletes a single `Address` using a unique key.
  """
  deleteAddress(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAddressInput!
  ): DeleteAddressPayload

  """
  Deletes a single `Address` using its globally unique id.
  """
  deleteAddressByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAddressByNodeIdInput!
  ): DeleteAddressPayload

  """
  Deletes a single `Certification` using a unique key.
  """
  deleteCertification(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCertificationInput!
  ): DeleteCertificationPayload

  """
  Deletes a single `Certification` using its globally unique id.
  """
  deleteCertificationByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCertificationByNodeIdInput!
  ): DeleteCertificationPayload

  """
  Deletes a single `Company` using a unique key.
  """
  deleteCompany(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCompanyInput!
  ): DeleteCompanyPayload

  """
  Deletes a single `Company` using a unique key.
  """
  deleteCompanyByMarketIdAndName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCompanyByMarketIdAndNameInput!
  ): DeleteCompanyPayload

  """
  Deletes a single `Company` using its globally unique id.
  """
  deleteCompanyByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCompanyByNodeIdInput!
  ): DeleteCompanyPayload

  """
  Deletes a single `Company` using a unique key.
  """
  deleteCompanyByReferenceNumber(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCompanyByReferenceNumberInput!
  ): DeleteCompanyPayload

  """
  Deletes a single `CompanyDocument` using a unique key.
  """
  deleteCompanyDocument(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCompanyDocumentInput!
  ): DeleteCompanyDocumentPayload

  """
  Deletes a single `CompanyDocument` using its globally unique id.
  """
  deleteCompanyDocumentByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCompanyDocumentByNodeIdInput!
  ): DeleteCompanyDocumentPayload

  """
  Deletes a single `CompanyMember` using a unique key.
  """
  deleteCompanyMember(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCompanyMemberInput!
  ): DeleteCompanyMemberPayload

  """
  Deletes a single `CompanyMember` using a unique key.
  """
  deleteCompanyMemberByMarketIdAndAccountIdAndCompanyId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCompanyMemberByMarketIdAndAccountIdAndCompanyIdInput!
  ): DeleteCompanyMemberPayload

  """
  Deletes a single `CompanyMember` using its globally unique id.
  """
  deleteCompanyMemberByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCompanyMemberByNodeIdInput!
  ): DeleteCompanyMemberPayload

  """
  Deletes a single `CompanyOperation` using a unique key.
  """
  deleteCompanyOperation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCompanyOperationInput!
  ): DeleteCompanyOperationPayload

  """
  Deletes a single `CompanyOperation` using its globally unique id.
  """
  deleteCompanyOperationByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCompanyOperationByNodeIdInput!
  ): DeleteCompanyOperationPayload

  """
  Deletes a single `Course` using a unique key.
  """
  deleteCourse(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCourseInput!
  ): DeleteCoursePayload

  """
  Deletes a single `Course` using a unique key.
  """
  deleteCourseByCourseId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCourseByCourseIdInput!
  ): DeleteCoursePayload

  """
  Deletes a single `Course` using its globally unique id.
  """
  deleteCourseByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCourseByNodeIdInput!
  ): DeleteCoursePayload

  """
  Deletes a single `CourseCatalogue` using a unique key.
  """
  deleteCourseCatalogue(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCourseCatalogueInput!
  ): DeleteCourseCataloguePayload

  """
  Deletes a single `CourseCatalogue` using a unique key.
  """
  deleteCourseCatalogueByCatalogueIdAndCourseId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCourseCatalogueByCatalogueIdAndCourseIdInput!
  ): DeleteCourseCataloguePayload

  """
  Deletes a single `CourseCatalogue` using its globally unique id.
  """
  deleteCourseCatalogueByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCourseCatalogueByNodeIdInput!
  ): DeleteCourseCataloguePayload

  """
  Deletes a single `CourseCatalogueTemp` using a unique key.
  """
  deleteCourseCatalogueTemp(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCourseCatalogueTempInput!
  ): DeleteCourseCatalogueTempPayload

  """
  Deletes a single `CourseCatalogueTemp` using its globally unique id.
  """
  deleteCourseCatalogueTempByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCourseCatalogueTempByNodeIdInput!
  ): DeleteCourseCatalogueTempPayload

  """
  Deletes a single `CourseEnrollment` using a unique key.
  """
  deleteCourseEnrollment(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCourseEnrollmentInput!
  ): DeleteCourseEnrollmentPayload

  """
  Deletes a single `CourseEnrollment` using its globally unique id.
  """
  deleteCourseEnrollmentByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCourseEnrollmentByNodeIdInput!
  ): DeleteCourseEnrollmentPayload

  """
  Deletes a single `CourseEnrollment` using a unique key.
  """
  deleteCourseEnrollmentByUserIdAndCourseId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCourseEnrollmentByUserIdAndCourseIdInput!
  ): DeleteCourseEnrollmentPayload

  """
  Deletes a single `CourseEnrollmentTemp` using a unique key.
  """
  deleteCourseEnrollmentTemp(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCourseEnrollmentTempInput!
  ): DeleteCourseEnrollmentTempPayload

  """
  Deletes a single `CourseEnrollmentTemp` using its globally unique id.
  """
  deleteCourseEnrollmentTempByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCourseEnrollmentTempByNodeIdInput!
  ): DeleteCourseEnrollmentTempPayload

  """
  Deletes a single `CourseSyncConfiguration` using a unique key.
  """
  deleteCourseSyncConfiguration(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCourseSyncConfigurationInput!
  ): DeleteCourseSyncConfigurationPayload

  """
  Deletes a single `CourseSyncConfiguration` using a unique key.
  """
  deleteCourseSyncConfigurationByConfigName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCourseSyncConfigurationByConfigNameInput!
  ): DeleteCourseSyncConfigurationPayload

  """
  Deletes a single `CourseSyncConfiguration` using its globally unique id.
  """
  deleteCourseSyncConfigurationByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCourseSyncConfigurationByNodeIdInput!
  ): DeleteCourseSyncConfigurationPayload

  """
  Deletes a single `CourseTemp` using a unique key.
  """
  deleteCourseTemp(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCourseTempInput!
  ): DeleteCourseTempPayload

  """
  Deletes a single `CourseTemp` using its globally unique id.
  """
  deleteCourseTempByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCourseTempByNodeIdInput!
  ): DeleteCourseTempPayload

  """
  Deletes a single `DoceboTier` using a unique key.
  """
  deleteDoceboTier(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteDoceboTierInput!
  ): DeleteDoceboTierPayload

  """
  Deletes a single `DoceboTier` using a unique key.
  """
  deleteDoceboTierByMarketIdAndTierCode(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteDoceboTierByMarketIdAndTierCodeInput!
  ): DeleteDoceboTierPayload

  """
  Deletes a single `DoceboTier` using its globally unique id.
  """
  deleteDoceboTierByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteDoceboTierByNodeIdInput!
  ): DeleteDoceboTierPayload

  """
  Deletes a single `EvidenceItem` using a unique key.
  """
  deleteEvidenceItem(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteEvidenceItemInput!
  ): DeleteEvidenceItemPayload

  """
  Deletes a single `EvidenceItem` using its globally unique id.
  """
  deleteEvidenceItemByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteEvidenceItemByNodeIdInput!
  ): DeleteEvidenceItemPayload

  """
  Deletes a single `Guarantee` using a unique key.
  """
  deleteGuarantee(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteGuaranteeInput!
  ): DeleteGuaranteePayload

  """
  Deletes a single `Guarantee` using a unique key.
  """
  deleteGuaranteeByBmiReferenceId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteGuaranteeByBmiReferenceIdInput!
  ): DeleteGuaranteePayload

  """
  Deletes a single `Guarantee` using its globally unique id.
  """
  deleteGuaranteeByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteGuaranteeByNodeIdInput!
  ): DeleteGuaranteePayload

  """
  Deletes a single `Invitation` using a unique key.
  """
  deleteInvitation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteInvitationInput!
  ): DeleteInvitationPayload

  """
  Deletes a single `Invitation` using its globally unique id.
  """
  deleteInvitationByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteInvitationByNodeIdInput!
  ): DeleteInvitationPayload
  deleteInvitedUser(email: String!): String

  """
  Deletes a single `Market` using a unique key.
  """
  deleteMarket(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteMarketInput!
  ): DeleteMarketPayload

  """
  Deletes a single `Market` using a unique key.
  """
  deleteMarketByDoceboCatalogueId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteMarketByDoceboCatalogueIdInput!
  ): DeleteMarketPayload

  """
  Deletes a single `Market` using a unique key.
  """
  deleteMarketByDomain(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteMarketByDomainInput!
  ): DeleteMarketPayload

  """
  Deletes a single `Market` using its globally unique id.
  """
  deleteMarketByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteMarketByNodeIdInput!
  ): DeleteMarketPayload

  """
  Deletes a single `Note` using a unique key.
  """
  deleteNote(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteNoteInput!
  ): DeleteNotePayload

  """
  Deletes a single `Note` using its globally unique id.
  """
  deleteNoteByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteNoteByNodeIdInput!
  ): DeleteNotePayload

  """
  Deletes a single `Notification` using a unique key.
  """
  deleteNotification(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteNotificationInput!
  ): DeleteNotificationPayload

  """
  Deletes a single `Notification` using its globally unique id.
  """
  deleteNotificationByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteNotificationByNodeIdInput!
  ): DeleteNotificationPayload

  """
  Deletes a single `Product` using a unique key.
  """
  deleteProduct(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProductInput!
  ): DeleteProductPayload

  """
  Deletes a single `Product` using a unique key.
  """
  deleteProductByBmiRef(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProductByBmiRefInput!
  ): DeleteProductPayload

  """
  Deletes a single `Product` using its globally unique id.
  """
  deleteProductByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProductByNodeIdInput!
  ): DeleteProductPayload

  """
  Deletes a single `Project` using a unique key.
  """
  deleteProject(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProjectInput!
  ): DeleteProjectPayload

  """
  Deletes a single `Project` using its globally unique id.
  """
  deleteProjectByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProjectByNodeIdInput!
  ): DeleteProjectPayload

  """
  Deletes a single `ProjectMember` using a unique key.
  """
  deleteProjectMember(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProjectMemberInput!
  ): DeleteProjectMemberPayload

  """
  Deletes a single `ProjectMember` using its globally unique id.
  """
  deleteProjectMemberByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProjectMemberByNodeIdInput!
  ): DeleteProjectMemberPayload

  """
  Deletes a single `System` using a unique key.
  """
  deleteSystem(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSystemInput!
  ): DeleteSystemPayload

  """
  Deletes a single `System` using a unique key.
  """
  deleteSystemByBmiRef(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSystemByBmiRefInput!
  ): DeleteSystemPayload

  """
  Deletes a single `System` using its globally unique id.
  """
  deleteSystemByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSystemByNodeIdInput!
  ): DeleteSystemPayload

  """
  Deletes a single `SystemMember` using a unique key.
  """
  deleteSystemMember(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSystemMemberInput!
  ): DeleteSystemMemberPayload

  """
  Deletes a single `SystemMember` using its globally unique id.
  """
  deleteSystemMemberByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSystemMemberByNodeIdInput!
  ): DeleteSystemMemberPayload

  """
  Deletes a single `SystemMember` using a unique key.
  """
  deleteSystemMemberBySystemBmiRefAndProductBmiRefAndMarketId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSystemMemberBySystemBmiRefAndProductBmiRefAndMarketIdInput!
  ): DeleteSystemMemberPayload
  evidenceItemsAdd(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: EvidenceItemsAddInput!
  ): EvidenceItemsAddPayload
  importAccountsCompaniesFromCVS(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: ImportAccountsCompaniesFromCSVInput!
  ): ImportAccountsCompaniesFromCSVResult
  invite(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: InviteInput!
  ): [Invitation]
  linkAccountToCompany(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: LinkAccountToCompanyInput!
  ): LinkAccountToCompanyPayload
  markAllNotificationsAsRead(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: MarkAllNotificationsAsReadInput!
  ): MarkAllNotificationsAsReadPayload
  projectMembersAdd(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: ProjectMembersAddInput!
  ): ProjectMembersAddPayload
  publishMessage(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: PublishInput!
  ): Publish
  resetPassword: String
  resetPasswordImportedUsers(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: resetPasswordImportedUsersInput
  ): resetPasswordImportedUsersResult
  restartGuarantee(projectId: Int!): String
  sendReminderToIncompleteCompanyProfile: String
  truncateAndInsertCertification(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: TruncateAndInsertCertificationInput
  ): String

  """
  Updates a single `Account` using a unique key and a patch.
  """
  updateAccount(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAccountInput!
  ): UpdateAccountPayload

  """
  Updates a single `Account` using a unique key and a patch.
  """
  updateAccountByDoceboUserId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAccountByDoceboUserIdInput!
  ): UpdateAccountPayload

  """
  Updates a single `Account` using a unique key and a patch.
  """
  updateAccountByEmail(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAccountByEmailInput!
  ): UpdateAccountPayload

  """
  Updates a single `Account` using its globally unique id and a patch.
  """
  updateAccountByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAccountByNodeIdInput!
  ): UpdateAccountPayload

  """
  Updates a single `Address` using a unique key and a patch.
  """
  updateAddress(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAddressInput!
  ): UpdateAddressPayload

  """
  Updates a single `Address` using its globally unique id and a patch.
  """
  updateAddressByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAddressByNodeIdInput!
  ): UpdateAddressPayload

  """
  Updates a single `Certification` using a unique key and a patch.
  """
  updateCertification(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCertificationInput!
  ): UpdateCertificationPayload

  """
  Updates a single `Certification` using its globally unique id and a patch.
  """
  updateCertificationByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCertificationByNodeIdInput!
  ): UpdateCertificationPayload

  """
  Updates a single `Company` using a unique key and a patch.
  """
  updateCompany(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCompanyInput!
  ): UpdateCompanyPayload

  """
  Updates a single `Company` using a unique key and a patch.
  """
  updateCompanyByMarketIdAndName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCompanyByMarketIdAndNameInput!
  ): UpdateCompanyPayload

  """
  Updates a single `Company` using its globally unique id and a patch.
  """
  updateCompanyByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCompanyByNodeIdInput!
  ): UpdateCompanyPayload

  """
  Updates a single `Company` using a unique key and a patch.
  """
  updateCompanyByReferenceNumber(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCompanyByReferenceNumberInput!
  ): UpdateCompanyPayload

  """
  Updates a single `CompanyDocument` using a unique key and a patch.
  """
  updateCompanyDocument(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCompanyDocumentInput!
  ): UpdateCompanyDocumentPayload

  """
  Updates a single `CompanyDocument` using its globally unique id and a patch.
  """
  updateCompanyDocumentByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCompanyDocumentByNodeIdInput!
  ): UpdateCompanyDocumentPayload

  """
  Updates a single `CompanyMember` using a unique key and a patch.
  """
  updateCompanyMember(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCompanyMemberInput!
  ): UpdateCompanyMemberPayload

  """
  Updates a single `CompanyMember` using a unique key and a patch.
  """
  updateCompanyMemberByMarketIdAndAccountIdAndCompanyId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCompanyMemberByMarketIdAndAccountIdAndCompanyIdInput!
  ): UpdateCompanyMemberPayload

  """
  Updates a single `CompanyMember` using its globally unique id and a patch.
  """
  updateCompanyMemberByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCompanyMemberByNodeIdInput!
  ): UpdateCompanyMemberPayload

  """
  Updates a single `CompanyOperation` using a unique key and a patch.
  """
  updateCompanyOperation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCompanyOperationInput!
  ): UpdateCompanyOperationPayload

  """
  Updates a single `CompanyOperation` using its globally unique id and a patch.
  """
  updateCompanyOperationByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCompanyOperationByNodeIdInput!
  ): UpdateCompanyOperationPayload

  """
  Updates a single `Course` using a unique key and a patch.
  """
  updateCourse(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCourseInput!
  ): UpdateCoursePayload

  """
  Updates a single `Course` using a unique key and a patch.
  """
  updateCourseByCourseId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCourseByCourseIdInput!
  ): UpdateCoursePayload

  """
  Updates a single `Course` using its globally unique id and a patch.
  """
  updateCourseByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCourseByNodeIdInput!
  ): UpdateCoursePayload

  """
  Updates a single `CourseCatalogue` using a unique key and a patch.
  """
  updateCourseCatalogue(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCourseCatalogueInput!
  ): UpdateCourseCataloguePayload

  """
  Updates a single `CourseCatalogue` using a unique key and a patch.
  """
  updateCourseCatalogueByCatalogueIdAndCourseId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCourseCatalogueByCatalogueIdAndCourseIdInput!
  ): UpdateCourseCataloguePayload

  """
  Updates a single `CourseCatalogue` using its globally unique id and a patch.
  """
  updateCourseCatalogueByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCourseCatalogueByNodeIdInput!
  ): UpdateCourseCataloguePayload

  """
  Updates a single `CourseCatalogueTemp` using a unique key and a patch.
  """
  updateCourseCatalogueTemp(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCourseCatalogueTempInput!
  ): UpdateCourseCatalogueTempPayload

  """
  Updates a single `CourseCatalogueTemp` using its globally unique id and a patch.
  """
  updateCourseCatalogueTempByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCourseCatalogueTempByNodeIdInput!
  ): UpdateCourseCatalogueTempPayload

  """
  Updates a single `CourseEnrollment` using a unique key and a patch.
  """
  updateCourseEnrollment(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCourseEnrollmentInput!
  ): UpdateCourseEnrollmentPayload

  """
  Updates a single `CourseEnrollment` using its globally unique id and a patch.
  """
  updateCourseEnrollmentByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCourseEnrollmentByNodeIdInput!
  ): UpdateCourseEnrollmentPayload

  """
  Updates a single `CourseEnrollment` using a unique key and a patch.
  """
  updateCourseEnrollmentByUserIdAndCourseId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCourseEnrollmentByUserIdAndCourseIdInput!
  ): UpdateCourseEnrollmentPayload

  """
  Updates a single `CourseEnrollmentTemp` using a unique key and a patch.
  """
  updateCourseEnrollmentTemp(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCourseEnrollmentTempInput!
  ): UpdateCourseEnrollmentTempPayload

  """
  Updates a single `CourseEnrollmentTemp` using its globally unique id and a patch.
  """
  updateCourseEnrollmentTempByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCourseEnrollmentTempByNodeIdInput!
  ): UpdateCourseEnrollmentTempPayload

  """
  Updates a single `CourseSyncConfiguration` using a unique key and a patch.
  """
  updateCourseSyncConfiguration(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCourseSyncConfigurationInput!
  ): UpdateCourseSyncConfigurationPayload

  """
  Updates a single `CourseSyncConfiguration` using a unique key and a patch.
  """
  updateCourseSyncConfigurationByConfigName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCourseSyncConfigurationByConfigNameInput!
  ): UpdateCourseSyncConfigurationPayload

  """
  Updates a single `CourseSyncConfiguration` using its globally unique id and a patch.
  """
  updateCourseSyncConfigurationByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCourseSyncConfigurationByNodeIdInput!
  ): UpdateCourseSyncConfigurationPayload

  """
  Updates a single `CourseTemp` using a unique key and a patch.
  """
  updateCourseTemp(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCourseTempInput!
  ): UpdateCourseTempPayload

  """
  Updates a single `CourseTemp` using its globally unique id and a patch.
  """
  updateCourseTempByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCourseTempByNodeIdInput!
  ): UpdateCourseTempPayload

  """
  Updates a single `DoceboTier` using a unique key and a patch.
  """
  updateDoceboTier(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateDoceboTierInput!
  ): UpdateDoceboTierPayload

  """
  Updates a single `DoceboTier` using a unique key and a patch.
  """
  updateDoceboTierByMarketIdAndTierCode(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateDoceboTierByMarketIdAndTierCodeInput!
  ): UpdateDoceboTierPayload

  """
  Updates a single `DoceboTier` using its globally unique id and a patch.
  """
  updateDoceboTierByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateDoceboTierByNodeIdInput!
  ): UpdateDoceboTierPayload
  updateDoceboTiersByMarket(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateDoceboTiersByMarketInput
  ): [UpdateDoceboTiersByMarketResult]
  updateDoceboUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UserUpdateInput
  ): UserUpdateResponse

  """
  Updates a single `EvidenceItem` using a unique key and a patch.
  """
  updateEvidenceItem(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateEvidenceItemInput!
  ): UpdateEvidenceItemPayload

  """
  Updates a single `EvidenceItem` using its globally unique id and a patch.
  """
  updateEvidenceItemByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateEvidenceItemByNodeIdInput!
  ): UpdateEvidenceItemPayload

  """
  Updates a single `Guarantee` using a unique key and a patch.
  """
  updateGuarantee(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateGuaranteeInput!
  ): UpdateGuaranteePayload

  """
  Updates a single `Guarantee` using a unique key and a patch.
  """
  updateGuaranteeByBmiReferenceId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateGuaranteeByBmiReferenceIdInput!
  ): UpdateGuaranteePayload

  """
  Updates a single `Guarantee` using its globally unique id and a patch.
  """
  updateGuaranteeByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateGuaranteeByNodeIdInput!
  ): UpdateGuaranteePayload

  """
  Updates a single `Invitation` using a unique key and a patch.
  """
  updateInvitation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateInvitationInput!
  ): UpdateInvitationPayload

  """
  Updates a single `Invitation` using its globally unique id and a patch.
  """
  updateInvitationByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateInvitationByNodeIdInput!
  ): UpdateInvitationPayload

  """
  Updates a single `Market` using a unique key and a patch.
  """
  updateMarket(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateMarketInput!
  ): UpdateMarketPayload

  """
  Updates a single `Market` using a unique key and a patch.
  """
  updateMarketByDoceboCatalogueId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateMarketByDoceboCatalogueIdInput!
  ): UpdateMarketPayload

  """
  Updates a single `Market` using a unique key and a patch.
  """
  updateMarketByDomain(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateMarketByDomainInput!
  ): UpdateMarketPayload

  """
  Updates a single `Market` using its globally unique id and a patch.
  """
  updateMarketByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateMarketByNodeIdInput!
  ): UpdateMarketPayload

  """
  Updates a single `Note` using a unique key and a patch.
  """
  updateNote(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateNoteInput!
  ): UpdateNotePayload

  """
  Updates a single `Note` using its globally unique id and a patch.
  """
  updateNoteByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateNoteByNodeIdInput!
  ): UpdateNotePayload

  """
  Updates a single `Notification` using a unique key and a patch.
  """
  updateNotification(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateNotificationInput!
  ): UpdateNotificationPayload

  """
  Updates a single `Notification` using its globally unique id and a patch.
  """
  updateNotificationByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateNotificationByNodeIdInput!
  ): UpdateNotificationPayload

  """
  Updates a single `Product` using a unique key and a patch.
  """
  updateProduct(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProductInput!
  ): UpdateProductPayload

  """
  Updates a single `Product` using a unique key and a patch.
  """
  updateProductByBmiRef(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProductByBmiRefInput!
  ): UpdateProductPayload

  """
  Updates a single `Product` using its globally unique id and a patch.
  """
  updateProductByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProductByNodeIdInput!
  ): UpdateProductPayload

  """
  Updates a single `Project` using a unique key and a patch.
  """
  updateProject(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProjectInput!
  ): UpdateProjectPayload

  """
  Updates a single `Project` using its globally unique id and a patch.
  """
  updateProjectByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProjectByNodeIdInput!
  ): UpdateProjectPayload

  """
  Updates a single `ProjectMember` using a unique key and a patch.
  """
  updateProjectMember(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProjectMemberInput!
  ): UpdateProjectMemberPayload

  """
  Updates a single `ProjectMember` using its globally unique id and a patch.
  """
  updateProjectMemberByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProjectMemberByNodeIdInput!
  ): UpdateProjectMemberPayload

  """
  Updates a single `System` using a unique key and a patch.
  """
  updateSystem(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSystemInput!
  ): UpdateSystemPayload

  """
  Updates a single `System` using a unique key and a patch.
  """
  updateSystemByBmiRef(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSystemByBmiRefInput!
  ): UpdateSystemPayload

  """
  Updates a single `System` using its globally unique id and a patch.
  """
  updateSystemByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSystemByNodeIdInput!
  ): UpdateSystemPayload

  """
  Updates a single `SystemMember` using a unique key and a patch.
  """
  updateSystemMember(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSystemMemberInput!
  ): UpdateSystemMemberPayload

  """
  Updates a single `SystemMember` using its globally unique id and a patch.
  """
  updateSystemMemberByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSystemMemberByNodeIdInput!
  ): UpdateSystemMemberPayload

  """
  Updates a single `SystemMember` using a unique key and a patch.
  """
  updateSystemMemberBySystemBmiRefAndProductBmiRefAndMarketId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSystemMemberBySystemBmiRefAndProductBmiRefAndMarketIdInput!
  ): UpdateSystemMemberPayload
  updateTraining(lastUpdateDate: String): String
  validateSignupUser(email: String!): Boolean
}

"""
An object with a globally unique `ID`.
"""
interface Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

"""
A note added by a BMI admin. It is likely to be either a short note regarding approval, saying something like, Approved, or Good Job, or a note explaining a rejection, saying  something like, The photographs of the roof are not clear enough.
"""
type Note implements Node {
  """
  Reads a single `Account` that is related to this `Note`.
  """
  author: Account

  """
  fk
  """
  authorId: Int

  """
  The body of the Note
  """
  body: String
  createdAt: Datetime!

  """
  Primary key
  """
  id: Int!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Reads a single `Project` that is related to this `Note`.
  """
  project: Project

  """
  fk
  """
  projectId: Int!
  senderName: String
  updatedAt: Datetime!
}

"""
Input for the nested mutation of `account` in the `NoteInput` mutation.
"""
input NoteAuthorIdFkeyInput {
  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByDoceboUserId: AccountAccountDoceboUserIdKeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByEmail: AccountAccountEmailKeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectById: AccountAccountPkeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByNodeId: AccountNodeIdConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByDoceboUserId: AccountAccountDoceboUserIdKeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByEmail: AccountAccountEmailKeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteById: AccountAccountPkeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByNodeId: AccountNodeIdDelete

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByDoceboUserId: AccountOnNoteForNoteAuthorIdFkeyUsingAccountDoceboUserIdKeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByEmail: AccountOnNoteForNoteAuthorIdFkeyUsingAccountEmailKeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateById: AccountOnNoteForNoteAuthorIdFkeyUsingAccountPkeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByNodeId: NoteOnNoteForNoteAuthorIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `note` in the `AccountInput` mutation.
"""
input NoteAuthorIdFkeyInverseInput {
  """
  The primary key(s) for `note` for the far side of the relationship.
  """
  connectById: [NoteNotePkeyConnect!]

  """
  The primary key(s) for `note` for the far side of the relationship.
  """
  connectByNodeId: [NoteNodeIdConnect!]

  """
  A `NoteInput` object that will be created and connected to this object.
  """
  create: [NoteAuthorIdFkeyNoteCreateInput!]

  """
  The primary key(s) for `note` for the far side of the relationship.
  """
  deleteById: [NoteNotePkeyDelete!]

  """
  The primary key(s) for `note` for the far side of the relationship.
  """
  deleteByNodeId: [NoteNodeIdDelete!]

  """
  Flag indicating whether all other `note` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `note` for the far side of the relationship.
  """
  updateById: [NoteOnNoteForNoteAuthorIdFkeyUsingNotePkeyUpdate!]

  """
  The primary key(s) and patch data for `note` for the far side of the relationship.
  """
  updateByNodeId: [AccountOnNoteForNoteAuthorIdFkeyNodeIdUpdate!]
}

"""
The `note` to be created by this mutation.
"""
input NoteAuthorIdFkeyNoteCreateInput {
  accountToAuthorId: NoteAuthorIdFkeyInput

  """
  The body of the Note
  """
  body: String
  createdAt: Datetime

  """
  Primary key
  """
  id: Int

  """
  fk
  """
  projectId: Int
  projectToProjectId: NoteProjectIdFkeyInput
  updatedAt: Datetime
}

"""
A condition to be used against `Note` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input NoteCondition {
  """
  Checks for equality with the object’s `authorId` field.
  """
  authorId: Int

  """
  Checks for equality with the object’s `id` field.
  """
  id: Int

  """
  Checks for equality with the object’s `projectId` field.
  """
  projectId: Int
}

"""
A filter to be used against `Note` object types. All fields are combined with a logical ‘and.’
"""
input NoteFilter {
  """
  Checks for all expressions in this list.
  """
  and: [NoteFilter!]

  """
  Filter by the object’s `authorId` field.
  """
  authorId: IntFilter

  """
  Filter by the object’s `id` field.
  """
  id: IntFilter

  """
  Negates the expression.
  """
  not: NoteFilter

  """
  Checks for any expressions in this list.
  """
  or: [NoteFilter!]

  """
  Filter by the object’s `projectId` field.
  """
  projectId: IntFilter

  """
  Filter by the object’s `senderName` field.
  """
  senderName: StringFilter
}

"""
An input for mutations affecting `Note`
"""
input NoteInput {
  accountToAuthorId: NoteAuthorIdFkeyInput

  """
  fk
  """
  authorId: Int

  """
  The body of the Note
  """
  body: String
  createdAt: Datetime

  """
  Primary key
  """
  id: Int

  """
  fk
  """
  projectId: Int
  projectToProjectId: NoteProjectIdFkeyInput
  updatedAt: Datetime
}

"""
The globally unique `ID` look up for the row to connect.
"""
input NoteNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `note` to be connected.
  """
  nodeId: ID!
}

"""
The globally unique `ID` look up for the row to delete.
"""
input NoteNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `note` to be deleted.
  """
  nodeId: ID!
}

"""
The fields on `note` to look up the row to connect.
"""
input NoteNotePkeyConnect {
  """
  Primary key
  """
  id: Int!
}

"""
The fields on `note` to look up the row to delete.
"""
input NoteNotePkeyDelete {
  """
  Primary key
  """
  id: Int!
}

"""
The globally unique `ID` look up for the row to update.
"""
input NoteOnNoteForNoteAuthorIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `account` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: AccountPatch!
}

"""
The fields on `note` to look up the row to update.
"""
input NoteOnNoteForNoteAuthorIdFkeyUsingNotePkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `note` being updated.
  """
  patch: updateNoteOnNoteForNoteAuthorIdFkeyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input NoteOnNoteForNoteProjectIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `project` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `project` being updated.
  """
  patch: ProjectPatch!
}

"""
The fields on `note` to look up the row to update.
"""
input NoteOnNoteForNoteProjectIdFkeyUsingNotePkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `note` being updated.
  """
  patch: updateNoteOnNoteForNoteProjectIdFkeyPatch!
}

"""
Represents an update to a `Note`. Fields that are set will be updated.
"""
input NotePatch {
  accountToAuthorId: NoteAuthorIdFkeyInput

  """
  fk
  """
  authorId: Int

  """
  The body of the Note
  """
  body: String
  createdAt: Datetime

  """
  Primary key
  """
  id: Int

  """
  fk
  """
  projectId: Int
  projectToProjectId: NoteProjectIdFkeyInput
  updatedAt: Datetime
}

"""
Input for the nested mutation of `project` in the `NoteInput` mutation.
"""
input NoteProjectIdFkeyInput {
  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  connectById: ProjectProjectPkeyConnect

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  connectByNodeId: ProjectNodeIdConnect

  """
  A `ProjectInput` object that will be created and connected to this object.
  """
  create: NoteProjectIdFkeyProjectCreateInput

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  deleteById: ProjectProjectPkeyDelete

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  deleteByNodeId: ProjectNodeIdDelete

  """
  The primary key(s) and patch data for `project` for the far side of the relationship.
  """
  updateById: ProjectOnNoteForNoteProjectIdFkeyUsingProjectPkeyUpdate

  """
  The primary key(s) and patch data for `project` for the far side of the relationship.
  """
  updateByNodeId: NoteOnNoteForNoteProjectIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `note` in the `ProjectInput` mutation.
"""
input NoteProjectIdFkeyInverseInput {
  """
  The primary key(s) for `note` for the far side of the relationship.
  """
  connectById: [NoteNotePkeyConnect!]

  """
  The primary key(s) for `note` for the far side of the relationship.
  """
  connectByNodeId: [NoteNodeIdConnect!]

  """
  A `NoteInput` object that will be created and connected to this object.
  """
  create: [NoteProjectIdFkeyNoteCreateInput!]

  """
  The primary key(s) for `note` for the far side of the relationship.
  """
  deleteById: [NoteNotePkeyDelete!]

  """
  The primary key(s) for `note` for the far side of the relationship.
  """
  deleteByNodeId: [NoteNodeIdDelete!]

  """
  Flag indicating whether all other `note` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `note` for the far side of the relationship.
  """
  updateById: [NoteOnNoteForNoteProjectIdFkeyUsingNotePkeyUpdate!]

  """
  The primary key(s) and patch data for `note` for the far side of the relationship.
  """
  updateByNodeId: [ProjectOnNoteForNoteProjectIdFkeyNodeIdUpdate!]
}

"""
The `note` to be created by this mutation.
"""
input NoteProjectIdFkeyNoteCreateInput {
  accountToAuthorId: NoteAuthorIdFkeyInput

  """
  fk
  """
  authorId: Int

  """
  The body of the Note
  """
  body: String
  createdAt: Datetime

  """
  Primary key
  """
  id: Int
  projectToProjectId: NoteProjectIdFkeyInput
  updatedAt: Datetime
}

"""
The `project` to be created by this mutation.
"""
input NoteProjectIdFkeyProjectCreateInput {
  addressToBuildingOwnerAddressId: ProjectBuildingOwnerAddressIdFkeyInput
  addressToSiteAddressId: ProjectSiteAddressIdFkeyInput

  """
  fk
  """
  buildingOwnerAddressId: Int

  """
  Name of the Building Owner company if there is such a thing.  Not the same as an InTouch Company.
  """
  buildingOwnerCompany: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerFirstname: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerLastname: String

  """
  Email address of the person who owns the building that the roof is going on.  Not mandatory for a Project, but mandatory when the Company applies for a Guarantee related to the project.
  """
  buildingOwnerMail: String

  """
  fk
  """
  companyId: Int
  companyToCompanyId: ProjectCompanyIdFkeyInput
  createdAt: Datetime

  """
  Short description of what the Project is about.  Sometimes useful to clarify some points to BMI
  """
  description: String

  """
  The date that the Project officially expects to end or ended
  """
  endDate: Datetime!
  evidenceItemsUsingId: EvidenceItemProjectIdFkeyInverseInput
  guaranteesUsingId: GuaranteeProjectIdFkeyInverseInput

  """
  If this is true then the Project should be hidden from End Users
  """
  hidden: Boolean

  """
  Primary key
  """
  id: Int
  migrationId: String

  """
  Short name for the Project
  """
  name: String!
  notesUsingId: NoteProjectIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberProjectIdFkeyInverseInput

  """
  The number of square meters of roof that this project covers
  """
  roofArea: Int!

  """
  fk
  """
  siteAddressId: Int

  """
  The date that the Project officially starts or started
  """
  startDate: Datetime!

  """
  ek
  """
  technology: Technology!
  updatedAt: Datetime
}

"""
A connection to a list of `Note` values.
"""
type NotesConnection {
  """
  A list of edges which contains the `Note` and cursor to aid in pagination.
  """
  edges: [NotesEdge!]!

  """
  A list of `Note` objects.
  """
  nodes: [Note!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Note` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `Note` edge in the connection.
"""
type NotesEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Note` at the end of the edge.
  """
  node: Note!
}

"""
Methods to use when ordering `Note`.
"""
enum NotesOrderBy {
  AUTHOR_ID_ASC
  AUTHOR_ID_DESC
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  PROJECT_ID_ASC
  PROJECT_ID_DESC
}

"""
An internal notification available to an end user
"""
type Notification implements Node {
  """
  Reads a single `Account` that is related to this `Notification`.
  """
  account: Account

  """
  fk
  """
  accountId: Int

  """
  The body of the message
  """
  body: String
  createdAt: Datetime!

  """
  Primary key
  """
  id: Int!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Whether the message has been read
  """
  read: Boolean!

  """
  The datetime stamp for when the message was sent
  """
  sendDate: Datetime!
  updatedAt: Datetime!
}

"""
Input for the nested mutation of `account` in the `NotificationInput` mutation.
"""
input NotificationAccountIdFkeyInput {
  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByDoceboUserId: AccountAccountDoceboUserIdKeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByEmail: AccountAccountEmailKeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectById: AccountAccountPkeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByNodeId: AccountNodeIdConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByDoceboUserId: AccountAccountDoceboUserIdKeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByEmail: AccountAccountEmailKeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteById: AccountAccountPkeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByNodeId: AccountNodeIdDelete

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByDoceboUserId: AccountOnNotificationForNotificationAccountIdFkeyUsingAccountDoceboUserIdKeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByEmail: AccountOnNotificationForNotificationAccountIdFkeyUsingAccountEmailKeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateById: AccountOnNotificationForNotificationAccountIdFkeyUsingAccountPkeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByNodeId: NotificationOnNotificationForNotificationAccountIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `notification` in the `AccountInput` mutation.
"""
input NotificationAccountIdFkeyInverseInput {
  """
  The primary key(s) for `notification` for the far side of the relationship.
  """
  connectById: [NotificationNotificationPkeyConnect!]

  """
  The primary key(s) for `notification` for the far side of the relationship.
  """
  connectByNodeId: [NotificationNodeIdConnect!]

  """
  A `NotificationInput` object that will be created and connected to this object.
  """
  create: [NotificationAccountIdFkeyNotificationCreateInput!]

  """
  The primary key(s) for `notification` for the far side of the relationship.
  """
  deleteById: [NotificationNotificationPkeyDelete!]

  """
  The primary key(s) for `notification` for the far side of the relationship.
  """
  deleteByNodeId: [NotificationNodeIdDelete!]

  """
  Flag indicating whether all other `notification` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `notification` for the far side of the relationship.
  """
  updateById: [NotificationOnNotificationForNotificationAccountIdFkeyUsingNotificationPkeyUpdate!]

  """
  The primary key(s) and patch data for `notification` for the far side of the relationship.
  """
  updateByNodeId: [AccountOnNotificationForNotificationAccountIdFkeyNodeIdUpdate!]
}

"""
The `notification` to be created by this mutation.
"""
input NotificationAccountIdFkeyNotificationCreateInput {
  accountToAccountId: NotificationAccountIdFkeyInput

  """
  The body of the message
  """
  body: String
  createdAt: Datetime

  """
  Primary key
  """
  id: Int

  """
  Whether the message has been read
  """
  read: Boolean

  """
  The datetime stamp for when the message was sent
  """
  sendDate: Datetime!
  updatedAt: Datetime
}

"""
A condition to be used against `Notification` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input NotificationCondition {
  """
  Checks for equality with the object’s `accountId` field.
  """
  accountId: Int

  """
  Checks for equality with the object’s `id` field.
  """
  id: Int
}

"""
A filter to be used against `Notification` object types. All fields are combined with a logical ‘and.’
"""
input NotificationFilter {
  """
  Filter by the object’s `accountId` field.
  """
  accountId: IntFilter

  """
  Checks for all expressions in this list.
  """
  and: [NotificationFilter!]

  """
  Filter by the object’s `id` field.
  """
  id: IntFilter

  """
  Negates the expression.
  """
  not: NotificationFilter

  """
  Checks for any expressions in this list.
  """
  or: [NotificationFilter!]
}

"""
An input for mutations affecting `Notification`
"""
input NotificationInput {
  """
  fk
  """
  accountId: Int
  accountToAccountId: NotificationAccountIdFkeyInput

  """
  The body of the message
  """
  body: String
  createdAt: Datetime

  """
  Primary key
  """
  id: Int

  """
  Whether the message has been read
  """
  read: Boolean

  """
  The datetime stamp for when the message was sent
  """
  sendDate: Datetime!
  updatedAt: Datetime
}

"""
The globally unique `ID` look up for the row to connect.
"""
input NotificationNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `notification` to be connected.
  """
  nodeId: ID!
}

"""
The globally unique `ID` look up for the row to delete.
"""
input NotificationNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `notification` to be deleted.
  """
  nodeId: ID!
}

"""
The fields on `notification` to look up the row to connect.
"""
input NotificationNotificationPkeyConnect {
  """
  Primary key
  """
  id: Int!
}

"""
The fields on `notification` to look up the row to delete.
"""
input NotificationNotificationPkeyDelete {
  """
  Primary key
  """
  id: Int!
}

"""
The globally unique `ID` look up for the row to update.
"""
input NotificationOnNotificationForNotificationAccountIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `account` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: AccountPatch!
}

"""
The fields on `notification` to look up the row to update.
"""
input NotificationOnNotificationForNotificationAccountIdFkeyUsingNotificationPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `notification` being updated.
  """
  patch: updateNotificationOnNotificationForNotificationAccountIdFkeyPatch!
}

"""
Represents an update to a `Notification`. Fields that are set will be updated.
"""
input NotificationPatch {
  """
  fk
  """
  accountId: Int
  accountToAccountId: NotificationAccountIdFkeyInput

  """
  The body of the message
  """
  body: String
  createdAt: Datetime

  """
  Primary key
  """
  id: Int

  """
  Whether the message has been read
  """
  read: Boolean

  """
  The datetime stamp for when the message was sent
  """
  sendDate: Datetime
  updatedAt: Datetime
}

"""
A connection to a list of `Notification` values.
"""
type NotificationsConnection {
  """
  A list of edges which contains the `Notification` and cursor to aid in pagination.
  """
  edges: [NotificationsEdge!]!

  """
  A list of `Notification` objects.
  """
  nodes: [Notification!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Notification` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `Notification` edge in the connection.
"""
type NotificationsEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Notification` at the end of the edge.
  """
  node: Notification!
}

"""
Methods to use when ordering `Notification`.
"""
enum NotificationsOrderBy {
  ACCOUNT_ID_ASC
  ACCOUNT_ID_DESC
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

enum Operation {
  BITUMEN
  COATER
  FLAT
  GREEN
  PITCHED
  SOLAR
  TILE
}

"""
Information about pagination in a connection.
"""
type PageInfo {
  """
  When paginating forwards, the cursor to continue.
  """
  endCursor: Cursor

  """
  When paginating forwards, are there more items?
  """
  hasNextPage: Boolean!

  """
  When paginating backwards, are there more items?
  """
  hasPreviousPage: Boolean!

  """
  When paginating backwards, the cursor to continue.
  """
  startCursor: Cursor
}

"""
MarketAdmin could change these every 6 months [See type definition](https://app.contentful.com/spaces/j30snaps0u9c/content_types/partnerBrand)
"""
type PartnerBrand implements Entry {
  contentfulMetadata: ContentfulMetadata!
  description(locale: String): PartnerBrandDescription
  image(locale: String, preview: Boolean): Asset
  linkedFrom(allowedLocales: [String]): PartnerBrandLinkingCollections
  logo(locale: String, preview: Boolean): Asset
  name(locale: String): String
  shortDescription(locale: String): String
  sys: Sys!
  websiteUrl(locale: String): String
}

type PartnerBrandCollection {
  items: [PartnerBrand]!
  limit: Int!
  skip: Int!
  total: Int!
}

type PartnerBrandDescription {
  json: JSON!
  links: PartnerBrandDescriptionLinks!
}

type PartnerBrandDescriptionAssets {
  block: [Asset]!
  hyperlink: [Asset]!
}

type PartnerBrandDescriptionEntries {
  block: [Entry]!
  hyperlink: [Entry]!
  inline: [Entry]!
}

type PartnerBrandDescriptionLinks {
  assets: PartnerBrandDescriptionAssets!
  entries: PartnerBrandDescriptionEntries!
}

input PartnerBrandFilter {
  AND: [PartnerBrandFilter]
  OR: [PartnerBrandFilter]
  contentfulMetadata: ContentfulMetadataFilter
  description_contains: String
  description_exists: Boolean
  description_not_contains: String
  image_exists: Boolean
  logo_exists: Boolean
  name: String
  name_contains: String
  name_exists: Boolean
  name_in: [String]
  name_not: String
  name_not_contains: String
  name_not_in: [String]
  shortDescription: String
  shortDescription_contains: String
  shortDescription_exists: Boolean
  shortDescription_in: [String]
  shortDescription_not: String
  shortDescription_not_contains: String
  shortDescription_not_in: [String]
  sys: SysFilter
  websiteUrl: String
  websiteUrl_contains: String
  websiteUrl_exists: Boolean
  websiteUrl_in: [String]
  websiteUrl_not: String
  websiteUrl_not_contains: String
  websiteUrl_not_in: [String]
}

type PartnerBrandLinkingCollections {
  entryCollection(
    limit: Int = 100
    locale: String
    preview: Boolean
    skip: Int = 0
  ): EntryCollection
  marketContentCollection(
    limit: Int = 100
    locale: String
    preview: Boolean
    skip: Int = 0
  ): MarketContentCollection
}

enum PartnerBrandOrder {
  name_ASC
  name_DESC
  sys_firstPublishedAt_ASC
  sys_firstPublishedAt_DESC
  sys_id_ASC
  sys_id_DESC
  sys_publishedAt_ASC
  sys_publishedAt_DESC
  sys_publishedVersion_ASC
  sys_publishedVersion_DESC
  websiteUrl_ASC
  websiteUrl_DESC
}

type Point {
  x: Float!
  y: Float!
}

input PointInput {
  x: Float!
  y: Float!
}

"""
A product made by BMI
"""
type Product implements Node {
  """
  A unique reference for the product known to BMI
  """
  bmiRef: String!

  """
  The Products brand
  """
  brand: String!
  createdAt: Datetime!

  """
  A description of the Product
  """
  description: String

  """
  The family of Products this Product is in
  """
  family: String!

  """
  Reads and enables pagination through a set of `Guarantee`.
  """
  guaranteesByProductBmiRef(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GuaranteeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: GuaranteeFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Guarantee`.
    """
    orderBy: [GuaranteesOrderBy!] = [PRIMARY_KEY_ASC]
  ): GuaranteesConnection!

  """
  Primary key
  """
  id: Int!

  """
  Reads a single `Market` that is related to this `Product`.
  """
  market: Market

  """
  fk
  """
  marketId: Int!

  """
  The number of years that this product can be guaranteed for
  """
  maximumValidityYears: Int!

  """
  Short name for the Product
  """
  name: String!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Whether the Product is avialable for new guarantees
  """
  published: Boolean!

  """
  Reads and enables pagination through a set of `SystemMember`.
  """
  systemMembersByProductBmiRef(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SystemMemberCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SystemMemberFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `SystemMember`.
    """
    orderBy: [SystemMembersOrderBy!] = [PRIMARY_KEY_ASC]
  ): SystemMembersConnection!

  """
  ek
  """
  technology: Technology!
  updatedAt: Datetime!
}

"""
A condition to be used against `Product` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input ProductCondition {
  """
  Checks for equality with the object’s `bmiRef` field.
  """
  bmiRef: String

  """
  Checks for equality with the object’s `id` field.
  """
  id: Int

  """
  Checks for equality with the object’s `marketId` field.
  """
  marketId: Int

  """
  Checks for equality with the object’s `name` field.
  """
  name: String
}

"""
A filter to be used against `Product` object types. All fields are combined with a logical ‘and.’
"""
input ProductFilter {
  """
  Checks for all expressions in this list.
  """
  and: [ProductFilter!]

  """
  Filter by the object’s `bmiRef` field.
  """
  bmiRef: StringFilter

  """
  Filter by the object’s `id` field.
  """
  id: IntFilter

  """
  Filter by the object’s `marketId` field.
  """
  marketId: IntFilter

  """
  Filter by the object’s `name` field.
  """
  name: StringFilter

  """
  Negates the expression.
  """
  not: ProductFilter

  """
  Checks for any expressions in this list.
  """
  or: [ProductFilter!]
}

"""
An input for mutations affecting `Product`
"""
input ProductInput {
  """
  A unique reference for the product known to BMI
  """
  bmiRef: String!

  """
  The Products brand
  """
  brand: String!
  createdAt: Datetime

  """
  A description of the Product
  """
  description: String

  """
  The family of Products this Product is in
  """
  family: String!
  guaranteesUsingBmiRef: GuaranteeProductBmiRefFkeyInverseInput

  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int
  marketToMarketId: ProductMarketIdFkeyInput

  """
  The number of years that this product can be guaranteed for
  """
  maximumValidityYears: Int!

  """
  Short name for the Product
  """
  name: String!

  """
  Whether the Product is avialable for new guarantees
  """
  published: Boolean!
  systemMembersUsingBmiRef: SystemMemberProductBmiRefFkeyInverseInput

  """
  ek
  """
  technology: Technology!
  updatedAt: Datetime
}

"""
Input for the nested mutation of `market` in the `ProductInput` mutation.
"""
input ProductMarketIdFkeyInput {
  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectByDoceboCatalogueId: MarketMarketDoceboCatalogueIdKeyConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectByDomain: MarketMarketDomainKeyConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectById: MarketMarketPkeyConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectByNodeId: MarketNodeIdConnect

  """
  A `MarketInput` object that will be created and connected to this object.
  """
  create: ProductMarketIdFkeyMarketCreateInput

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteByDoceboCatalogueId: MarketMarketDoceboCatalogueIdKeyDelete

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteByDomain: MarketMarketDomainKeyDelete

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteById: MarketMarketPkeyDelete

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteByNodeId: MarketNodeIdDelete

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateByDoceboCatalogueId: MarketOnProductForProductMarketIdFkeyUsingMarketDoceboCatalogueIdKeyUpdate

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateByDomain: MarketOnProductForProductMarketIdFkeyUsingMarketDomainKeyUpdate

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateById: MarketOnProductForProductMarketIdFkeyUsingMarketPkeyUpdate

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateByNodeId: ProductOnProductForProductMarketIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `product` in the `MarketInput` mutation.
"""
input ProductMarketIdFkeyInverseInput {
  """
  The primary key(s) for `product` for the far side of the relationship.
  """
  connectByBmiRef: [ProductProductBmiRefKeyConnect!]

  """
  The primary key(s) for `product` for the far side of the relationship.
  """
  connectById: [ProductProductPkeyConnect!]

  """
  The primary key(s) for `product` for the far side of the relationship.
  """
  connectByNodeId: [ProductNodeIdConnect!]

  """
  A `ProductInput` object that will be created and connected to this object.
  """
  create: [ProductMarketIdFkeyProductCreateInput!]

  """
  The primary key(s) for `product` for the far side of the relationship.
  """
  deleteByBmiRef: [ProductProductBmiRefKeyDelete!]

  """
  The primary key(s) for `product` for the far side of the relationship.
  """
  deleteById: [ProductProductPkeyDelete!]

  """
  The primary key(s) for `product` for the far side of the relationship.
  """
  deleteByNodeId: [ProductNodeIdDelete!]

  """
  Flag indicating whether all other `product` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `product` for the far side of the relationship.
  """
  updateByBmiRef: [ProductOnProductForProductMarketIdFkeyUsingProductBmiRefKeyUpdate!]

  """
  The primary key(s) and patch data for `product` for the far side of the relationship.
  """
  updateById: [ProductOnProductForProductMarketIdFkeyUsingProductPkeyUpdate!]

  """
  The primary key(s) and patch data for `product` for the far side of the relationship.
  """
  updateByNodeId: [MarketOnProductForProductMarketIdFkeyNodeIdUpdate!]
}

"""
The `market` to be created by this mutation.
"""
input ProductMarketIdFkeyMarketCreateInput {
  accountsUsingId: AccountMarketIdFkeyInverseInput

  """
  The space in Contenful
  """
  cmsSpaceId: String
  companiesUsingId: CompanyMarketIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberMarketIdFkeyInverseInput
  createdAt: Datetime

  """
  The default catalogue for the Market.  All users in the Market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int
  doceboCatalogueIdT2: Int
  doceboCatalogueIdT3: Int
  doceboCatalogueIdT4: Int

  """
  The Docebo branch that new user are inserted into if they register as a Company Admin. Note that this never gets updated by InTouch. Originally there was going to be a distinction between installer branches and admin branches in Docebo, but this is no longer the preferred approach.
  """
  doceboCompanyAdminBranchId: String

  """
  The Docebo branch that new user are inserted into if they register as an installer.  Note that this never gets updated by InTouch.  Originally there was going to be a distinction between installer branches and admin branches in Docebo, but this is no longer the preferred approach.
  """
  doceboInstallersBranchId: String

  """
  the country code used for example as the subdomain
  """
  domain: String!

  """
  The coordinates of the middle of the Market on a map
  """
  geoMiddle: PointInput

  """
  Reference to the Google Analytics tracking ID that is used for the Country GA reports
  """
  gtag: String
  gtagMarketMedia: String

  """
  Primary key
  """
  id: Int

  """
  ek
  """
  language: Language!

  """
  The length of the radius in km (from the geo_middle lat/lng), for which the Google Places API biases the search results for address autocomplete. Locations outside of the radius will not be excluded.
  """
  locationBiasRadiusKm: Int

  """
  The address of the merchandising site for the market.  CTAs of the MERCHANDISING type will link to this address
  """
  merchandisingUrl: String

  """
  A short name for the market, e.g. Italy, Norway, Netherlands
  """
  name: String
  productsUsingId: ProductMarketIdFkeyInverseInput

  """
  Whether the market supports Projects.  If so then the Projects link should be available in th left hand navigation.
  """
  projectsEnabled: Boolean

  """
  The mailbox on intouch.bmigroup.com that emails will be sent from for this Market
  """
  sendMailbox: String

  """
  The From name used when sending an email
  """
  sendName: String
  systemMembersUsingId: SystemMemberMarketIdFkeyInverseInput
  systemsUsingId: SystemMarketIdFkeyInverseInput
  updatedAt: Datetime
}

"""
The `product` to be created by this mutation.
"""
input ProductMarketIdFkeyProductCreateInput {
  """
  A unique reference for the product known to BMI
  """
  bmiRef: String!

  """
  The Products brand
  """
  brand: String!
  createdAt: Datetime

  """
  A description of the Product
  """
  description: String

  """
  The family of Products this Product is in
  """
  family: String!
  guaranteesUsingBmiRef: GuaranteeProductBmiRefFkeyInverseInput

  """
  Primary key
  """
  id: Int
  marketToMarketId: ProductMarketIdFkeyInput

  """
  The number of years that this product can be guaranteed for
  """
  maximumValidityYears: Int!

  """
  Short name for the Product
  """
  name: String!

  """
  Whether the Product is avialable for new guarantees
  """
  published: Boolean!
  systemMembersUsingBmiRef: SystemMemberProductBmiRefFkeyInverseInput

  """
  ek
  """
  technology: Technology!
  updatedAt: Datetime
}

"""
The globally unique `ID` look up for the row to connect.
"""
input ProductNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `product` to be connected.
  """
  nodeId: ID!
}

"""
The globally unique `ID` look up for the row to delete.
"""
input ProductNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `product` to be deleted.
  """
  nodeId: ID!
}

"""
The globally unique `ID` look up for the row to update.
"""
input ProductOnGuaranteeForGuaranteeProductBmiRefFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `guarantee` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `guarantee` being updated.
  """
  patch: GuaranteePatch!
}

"""
The fields on `product` to look up the row to update.
"""
input ProductOnGuaranteeForGuaranteeProductBmiRefFkeyUsingProductBmiRefKeyUpdate {
  """
  A unique reference for the product known to BMI
  """
  bmiRef: String!

  """
  An object where the defined keys will be set on the `product` being updated.
  """
  patch: updateProductOnGuaranteeForGuaranteeProductBmiRefFkeyPatch!
}

"""
The fields on `product` to look up the row to update.
"""
input ProductOnGuaranteeForGuaranteeProductBmiRefFkeyUsingProductPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `product` being updated.
  """
  patch: updateProductOnGuaranteeForGuaranteeProductBmiRefFkeyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input ProductOnProductForProductMarketIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `market` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: MarketPatch!
}

"""
The fields on `product` to look up the row to update.
"""
input ProductOnProductForProductMarketIdFkeyUsingProductBmiRefKeyUpdate {
  """
  A unique reference for the product known to BMI
  """
  bmiRef: String!

  """
  An object where the defined keys will be set on the `product` being updated.
  """
  patch: updateProductOnProductForProductMarketIdFkeyPatch!
}

"""
The fields on `product` to look up the row to update.
"""
input ProductOnProductForProductMarketIdFkeyUsingProductPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `product` being updated.
  """
  patch: updateProductOnProductForProductMarketIdFkeyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input ProductOnSystemMemberForSystemMemberProductBmiRefFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `systemMember` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `systemMember` being updated.
  """
  patch: SystemMemberPatch!
}

"""
The fields on `product` to look up the row to update.
"""
input ProductOnSystemMemberForSystemMemberProductBmiRefFkeyUsingProductBmiRefKeyUpdate {
  """
  A unique reference for the product known to BMI
  """
  bmiRef: String!

  """
  An object where the defined keys will be set on the `product` being updated.
  """
  patch: updateProductOnSystemMemberForSystemMemberProductBmiRefFkeyPatch!
}

"""
The fields on `product` to look up the row to update.
"""
input ProductOnSystemMemberForSystemMemberProductBmiRefFkeyUsingProductPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `product` being updated.
  """
  patch: updateProductOnSystemMemberForSystemMemberProductBmiRefFkeyPatch!
}

"""
Represents an update to a `Product`. Fields that are set will be updated.
"""
input ProductPatch {
  """
  A unique reference for the product known to BMI
  """
  bmiRef: String

  """
  The Products brand
  """
  brand: String
  createdAt: Datetime

  """
  A description of the Product
  """
  description: String

  """
  The family of Products this Product is in
  """
  family: String
  guaranteesUsingBmiRef: GuaranteeProductBmiRefFkeyInverseInput

  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int
  marketToMarketId: ProductMarketIdFkeyInput

  """
  The number of years that this product can be guaranteed for
  """
  maximumValidityYears: Int

  """
  Short name for the Product
  """
  name: String

  """
  Whether the Product is avialable for new guarantees
  """
  published: Boolean
  systemMembersUsingBmiRef: SystemMemberProductBmiRefFkeyInverseInput

  """
  ek
  """
  technology: Technology
  updatedAt: Datetime
}

"""
The fields on `product` to look up the row to connect.
"""
input ProductProductBmiRefKeyConnect {
  """
  A unique reference for the product known to BMI
  """
  bmiRef: String!
}

"""
The fields on `product` to look up the row to delete.
"""
input ProductProductBmiRefKeyDelete {
  """
  A unique reference for the product known to BMI
  """
  bmiRef: String!
}

"""
The fields on `product` to look up the row to connect.
"""
input ProductProductPkeyConnect {
  """
  Primary key
  """
  id: Int!
}

"""
The fields on `product` to look up the row to delete.
"""
input ProductProductPkeyDelete {
  """
  Primary key
  """
  id: Int!
}

"""
A connection to a list of `Product` values.
"""
type ProductsConnection {
  """
  A list of edges which contains the `Product` and cursor to aid in pagination.
  """
  edges: [ProductsEdge!]!

  """
  A list of `Product` objects.
  """
  nodes: [Product!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Product` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `Product` edge in the connection.
"""
type ProductsEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Product` at the end of the edge.
  """
  node: Product!
}

"""
Methods to use when ordering `Product`.
"""
enum ProductsOrderBy {
  BMI_REF_ASC
  BMI_REF_DESC
  ID_ASC
  ID_DESC
  MARKET_ID_ASC
  MARKET_ID_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A project that has been put into InTouch by a Company Administrator to represent a project being done by that company
"""
type Project implements Node {
  """
  Reads a single `Address` that is related to this `Project`.
  """
  buildingOwnerAddress: Address

  """
  fk
  """
  buildingOwnerAddressId: Int

  """
  Name of the Building Owner company if there is such a thing.  Not the same as an InTouch Company.
  """
  buildingOwnerCompany: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerFirstname: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerLastname: String

  """
  Email address of the person who owns the building that the roof is going on.  Not mandatory for a Project, but mandatory when the Company applies for a Guarantee related to the project.
  """
  buildingOwnerMail: String

  """
  Reads a single `Company` that is related to this `Project`.
  """
  company: Company

  """
  fk
  """
  companyId: Int!
  createdAt: Datetime!

  """
  Short description of what the Project is about.  Sometimes useful to clarify some points to BMI
  """
  description: String

  """
  The date that the Project officially expects to end or ended
  """
  endDate: Datetime!

  """
  Reads and enables pagination through a set of `EvidenceItem`.
  """
  evidenceItems(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EvidenceItemCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EvidenceItemFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `EvidenceItem`.
    """
    orderBy: [EvidenceItemsOrderBy!] = [PRIMARY_KEY_ASC]
  ): EvidenceItemsConnection!

  """
  Reads and enables pagination through a set of `Guarantee`.
  """
  guarantees(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GuaranteeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: GuaranteeFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Guarantee`.
    """
    orderBy: [GuaranteesOrderBy!] = [PRIMARY_KEY_ASC]
  ): GuaranteesConnection!

  """
  If this is true then the Project should be hidden from End Users
  """
  hidden: Boolean

  """
  Primary key
  """
  id: Int!
  migrationId: String

  """
  Short name for the Project
  """
  name: String!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Reads and enables pagination through a set of `Note`.
  """
  notes(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: NoteCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: NoteFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Note`.
    """
    orderBy: [NotesOrderBy!] = [PRIMARY_KEY_ASC]
  ): NotesConnection!

  """
  Reads and enables pagination through a set of `ProjectMember`.
  """
  projectMembers(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectMemberCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProjectMemberFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `ProjectMember`.
    """
    orderBy: [ProjectMembersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectMembersConnection!

  """
  The number of square meters of roof that this project covers
  """
  roofArea: Int!

  """
  Reads a single `Address` that is related to this `Project`.
  """
  siteAddress: Address

  """
  fk
  """
  siteAddressId: Int

  """
  The date that the Project officially starts or started
  """
  startDate: Datetime!

  """
  ek
  """
  technology: Technology!
  updatedAt: Datetime!
}

"""
The `address` to be created by this mutation.
"""
input ProjectBuildingOwnerAddressIdFkeyAddressCreateInput {
  companiesToRegisteredAddressIdUsingId: CompanyRegisteredAddressIdFkeyInverseInput
  companiesToTradingAddressIdUsingId: CompanyTradingAddressIdFkeyInverseInput

  """
  The coordinates on a map of the world
  """
  coordinates: PointInput

  """
  The country for this address
  """
  country: String
  createdAt: Datetime

  """
  First line of this address
  """
  firstLine: String

  """
  Primary key
  """
  id: Int

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String

  """
  The postcode for this address
  """
  postcode: String
  projectsToBuildingOwnerAddressIdUsingId: ProjectBuildingOwnerAddressIdFkeyInverseInput
  projectsToSiteAddressIdUsingId: ProjectSiteAddressIdFkeyInverseInput

  """
  The region if relevant
  """
  region: String

  """
  Second line of this address
  """
  secondLine: String

  """
  The postal town
  """
  town: String
  updatedAt: Datetime
}

"""
Input for the nested mutation of `address` in the `ProjectInput` mutation.
"""
input ProjectBuildingOwnerAddressIdFkeyInput {
  """
  The primary key(s) for `address` for the far side of the relationship.
  """
  connectById: AddressAddressPkeyConnect

  """
  The primary key(s) for `address` for the far side of the relationship.
  """
  connectByNodeId: AddressNodeIdConnect

  """
  A `AddressInput` object that will be created and connected to this object.
  """
  create: ProjectBuildingOwnerAddressIdFkeyAddressCreateInput

  """
  The primary key(s) for `address` for the far side of the relationship.
  """
  deleteById: AddressAddressPkeyDelete

  """
  The primary key(s) for `address` for the far side of the relationship.
  """
  deleteByNodeId: AddressNodeIdDelete

  """
  The primary key(s) and patch data for `address` for the far side of the relationship.
  """
  updateById: AddressOnProjectForProjectBuildingOwnerAddressIdFkeyUsingAddressPkeyUpdate

  """
  The primary key(s) and patch data for `address` for the far side of the relationship.
  """
  updateByNodeId: ProjectOnProjectForProjectBuildingOwnerAddressIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `project` in the `AddressInput` mutation.
"""
input ProjectBuildingOwnerAddressIdFkeyInverseInput {
  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  connectById: [ProjectProjectPkeyConnect!]

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  connectByNodeId: [ProjectNodeIdConnect!]

  """
  A `ProjectInput` object that will be created and connected to this object.
  """
  create: [ProjectBuildingOwnerAddressIdFkeyProjectCreateInput!]

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  deleteById: [ProjectProjectPkeyDelete!]

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  deleteByNodeId: [ProjectNodeIdDelete!]

  """
  Flag indicating whether all other `project` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `project` for the far side of the relationship.
  """
  updateById: [ProjectOnProjectForProjectBuildingOwnerAddressIdFkeyUsingProjectPkeyUpdate!]

  """
  The primary key(s) and patch data for `project` for the far side of the relationship.
  """
  updateByNodeId: [AddressOnProjectForProjectBuildingOwnerAddressIdFkeyNodeIdUpdate!]
}

"""
The `project` to be created by this mutation.
"""
input ProjectBuildingOwnerAddressIdFkeyProjectCreateInput {
  addressToBuildingOwnerAddressId: ProjectBuildingOwnerAddressIdFkeyInput
  addressToSiteAddressId: ProjectSiteAddressIdFkeyInput

  """
  Name of the Building Owner company if there is such a thing.  Not the same as an InTouch Company.
  """
  buildingOwnerCompany: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerFirstname: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerLastname: String

  """
  Email address of the person who owns the building that the roof is going on.  Not mandatory for a Project, but mandatory when the Company applies for a Guarantee related to the project.
  """
  buildingOwnerMail: String

  """
  fk
  """
  companyId: Int
  companyToCompanyId: ProjectCompanyIdFkeyInput
  createdAt: Datetime

  """
  Short description of what the Project is about.  Sometimes useful to clarify some points to BMI
  """
  description: String

  """
  The date that the Project officially expects to end or ended
  """
  endDate: Datetime!
  evidenceItemsUsingId: EvidenceItemProjectIdFkeyInverseInput
  guaranteesUsingId: GuaranteeProjectIdFkeyInverseInput

  """
  If this is true then the Project should be hidden from End Users
  """
  hidden: Boolean

  """
  Primary key
  """
  id: Int
  migrationId: String

  """
  Short name for the Project
  """
  name: String!
  notesUsingId: NoteProjectIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberProjectIdFkeyInverseInput

  """
  The number of square meters of roof that this project covers
  """
  roofArea: Int!

  """
  fk
  """
  siteAddressId: Int

  """
  The date that the Project officially starts or started
  """
  startDate: Datetime!

  """
  ek
  """
  technology: Technology!
  updatedAt: Datetime
}

"""
Input for the nested mutation of `company` in the `ProjectInput` mutation.
"""
input ProjectCompanyIdFkeyInput {
  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectById: CompanyCompanyPkeyConnect

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByMarketIdAndName: CompanyCompanyMarketIdNameKeyConnect

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByNodeId: CompanyNodeIdConnect

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByReferenceNumber: CompanyCompanyReferenceNumberKeyConnect

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteById: CompanyCompanyPkeyDelete

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByMarketIdAndName: CompanyCompanyMarketIdNameKeyDelete

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByNodeId: CompanyNodeIdDelete

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByReferenceNumber: CompanyCompanyReferenceNumberKeyDelete

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateById: CompanyOnProjectForProjectCompanyIdFkeyUsingCompanyPkeyUpdate

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByMarketIdAndName: CompanyOnProjectForProjectCompanyIdFkeyUsingCompanyMarketIdNameKeyUpdate

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByNodeId: ProjectOnProjectForProjectCompanyIdFkeyNodeIdUpdate

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByReferenceNumber: CompanyOnProjectForProjectCompanyIdFkeyUsingCompanyReferenceNumberKeyUpdate
}

"""
Input for the nested mutation of `project` in the `CompanyInput` mutation.
"""
input ProjectCompanyIdFkeyInverseInput {
  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  connectById: [ProjectProjectPkeyConnect!]

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  connectByNodeId: [ProjectNodeIdConnect!]

  """
  A `ProjectInput` object that will be created and connected to this object.
  """
  create: [ProjectCompanyIdFkeyProjectCreateInput!]

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  deleteById: [ProjectProjectPkeyDelete!]

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  deleteByNodeId: [ProjectNodeIdDelete!]

  """
  Flag indicating whether all other `project` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `project` for the far side of the relationship.
  """
  updateById: [ProjectOnProjectForProjectCompanyIdFkeyUsingProjectPkeyUpdate!]

  """
  The primary key(s) and patch data for `project` for the far side of the relationship.
  """
  updateByNodeId: [CompanyOnProjectForProjectCompanyIdFkeyNodeIdUpdate!]
}

"""
The `project` to be created by this mutation.
"""
input ProjectCompanyIdFkeyProjectCreateInput {
  addressToBuildingOwnerAddressId: ProjectBuildingOwnerAddressIdFkeyInput
  addressToSiteAddressId: ProjectSiteAddressIdFkeyInput

  """
  fk
  """
  buildingOwnerAddressId: Int

  """
  Name of the Building Owner company if there is such a thing.  Not the same as an InTouch Company.
  """
  buildingOwnerCompany: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerFirstname: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerLastname: String

  """
  Email address of the person who owns the building that the roof is going on.  Not mandatory for a Project, but mandatory when the Company applies for a Guarantee related to the project.
  """
  buildingOwnerMail: String
  companyToCompanyId: ProjectCompanyIdFkeyInput
  createdAt: Datetime

  """
  Short description of what the Project is about.  Sometimes useful to clarify some points to BMI
  """
  description: String

  """
  The date that the Project officially expects to end or ended
  """
  endDate: Datetime!
  evidenceItemsUsingId: EvidenceItemProjectIdFkeyInverseInput
  guaranteesUsingId: GuaranteeProjectIdFkeyInverseInput

  """
  If this is true then the Project should be hidden from End Users
  """
  hidden: Boolean

  """
  Primary key
  """
  id: Int
  migrationId: String

  """
  Short name for the Project
  """
  name: String!
  notesUsingId: NoteProjectIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberProjectIdFkeyInverseInput

  """
  The number of square meters of roof that this project covers
  """
  roofArea: Int!

  """
  fk
  """
  siteAddressId: Int

  """
  The date that the Project officially starts or started
  """
  startDate: Datetime!

  """
  ek
  """
  technology: Technology!
  updatedAt: Datetime
}

"""
A condition to be used against `Project` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input ProjectCondition {
  """
  Checks for equality with the object’s `buildingOwnerAddressId` field.
  """
  buildingOwnerAddressId: Int

  """
  Checks for equality with the object’s `companyId` field.
  """
  companyId: Int

  """
  Checks for equality with the object’s `id` field.
  """
  id: Int

  """
  Checks for equality with the object’s `siteAddressId` field.
  """
  siteAddressId: Int
}

"""
A filter to be used against `Project` object types. All fields are combined with a logical ‘and.’
"""
input ProjectFilter {
  """
  Checks for all expressions in this list.
  """
  and: [ProjectFilter!]

  """
  Filter by the object’s `buildingOwnerAddressId` field.
  """
  buildingOwnerAddressId: IntFilter

  """
  Filter by the object’s `companyId` field.
  """
  companyId: IntFilter

  """
  Filter by the object’s `id` field.
  """
  id: IntFilter

  """
  Negates the expression.
  """
  not: ProjectFilter

  """
  Checks for any expressions in this list.
  """
  or: [ProjectFilter!]

  """
  Filter by the object’s `siteAddressId` field.
  """
  siteAddressId: IntFilter
}

"""
An input for mutations affecting `Project`
"""
input ProjectInput {
  addressToBuildingOwnerAddressId: ProjectBuildingOwnerAddressIdFkeyInput
  addressToSiteAddressId: ProjectSiteAddressIdFkeyInput

  """
  fk
  """
  buildingOwnerAddressId: Int

  """
  Name of the Building Owner company if there is such a thing.  Not the same as an InTouch Company.
  """
  buildingOwnerCompany: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerFirstname: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerLastname: String

  """
  Email address of the person who owns the building that the roof is going on.  Not mandatory for a Project, but mandatory when the Company applies for a Guarantee related to the project.
  """
  buildingOwnerMail: String

  """
  fk
  """
  companyId: Int
  companyToCompanyId: ProjectCompanyIdFkeyInput
  createdAt: Datetime

  """
  Short description of what the Project is about.  Sometimes useful to clarify some points to BMI
  """
  description: String

  """
  The date that the Project officially expects to end or ended
  """
  endDate: Datetime!
  evidenceItemsUsingId: EvidenceItemProjectIdFkeyInverseInput
  guaranteesUsingId: GuaranteeProjectIdFkeyInverseInput

  """
  If this is true then the Project should be hidden from End Users
  """
  hidden: Boolean

  """
  Primary key
  """
  id: Int
  migrationId: String

  """
  Short name for the Project
  """
  name: String!
  notesUsingId: NoteProjectIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberProjectIdFkeyInverseInput

  """
  The number of square meters of roof that this project covers
  """
  roofArea: Int!

  """
  fk
  """
  siteAddressId: Int

  """
  The date that the Project officially starts or started
  """
  startDate: Datetime!

  """
  ek
  """
  technology: Technology!
  updatedAt: Datetime
}

"""
People who are on a Project
"""
type ProjectMember implements Node {
  """
  Reads a single `Account` that is related to this `ProjectMember`.
  """
  account: Account

  """
  fk
  """
  accountId: Int
  createdAt: Datetime!

  """
  Primary key
  """
  id: Int!

  """
  The responsible installer
  """
  isResponsibleInstaller: Boolean

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Reads a single `Project` that is related to this `ProjectMember`.
  """
  project: Project

  """
  fk
  """
  projectId: Int!
  updatedAt: Datetime!
}

"""
Input for the nested mutation of `account` in the `ProjectMemberInput` mutation.
"""
input ProjectMemberAccountIdFkeyInput {
  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByDoceboUserId: AccountAccountDoceboUserIdKeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByEmail: AccountAccountEmailKeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectById: AccountAccountPkeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByNodeId: AccountNodeIdConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByDoceboUserId: AccountAccountDoceboUserIdKeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByEmail: AccountAccountEmailKeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteById: AccountAccountPkeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByNodeId: AccountNodeIdDelete

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByDoceboUserId: AccountOnProjectMemberForProjectMemberAccountIdFkeyUsingAccountDoceboUserIdKeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByEmail: AccountOnProjectMemberForProjectMemberAccountIdFkeyUsingAccountEmailKeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateById: AccountOnProjectMemberForProjectMemberAccountIdFkeyUsingAccountPkeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByNodeId: ProjectMemberOnProjectMemberForProjectMemberAccountIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `projectMember` in the `AccountInput` mutation.
"""
input ProjectMemberAccountIdFkeyInverseInput {
  """
  The primary key(s) for `projectMember` for the far side of the relationship.
  """
  connectById: [ProjectMemberProjectMemberPkeyConnect!]

  """
  The primary key(s) for `projectMember` for the far side of the relationship.
  """
  connectByNodeId: [ProjectMemberNodeIdConnect!]

  """
  A `ProjectMemberInput` object that will be created and connected to this object.
  """
  create: [ProjectMemberAccountIdFkeyProjectMemberCreateInput!]

  """
  The primary key(s) for `projectMember` for the far side of the relationship.
  """
  deleteById: [ProjectMemberProjectMemberPkeyDelete!]

  """
  The primary key(s) for `projectMember` for the far side of the relationship.
  """
  deleteByNodeId: [ProjectMemberNodeIdDelete!]

  """
  Flag indicating whether all other `projectMember` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `projectMember` for the far side of the relationship.
  """
  updateById: [ProjectMemberOnProjectMemberForProjectMemberAccountIdFkeyUsingProjectMemberPkeyUpdate!]

  """
  The primary key(s) and patch data for `projectMember` for the far side of the relationship.
  """
  updateByNodeId: [AccountOnProjectMemberForProjectMemberAccountIdFkeyNodeIdUpdate!]
}

"""
The `projectMember` to be created by this mutation.
"""
input ProjectMemberAccountIdFkeyProjectMemberCreateInput {
  accountToAccountId: ProjectMemberAccountIdFkeyInput
  createdAt: Datetime

  """
  Primary key
  """
  id: Int

  """
  The responsible installer
  """
  isResponsibleInstaller: Boolean

  """
  fk
  """
  projectId: Int
  projectToProjectId: ProjectMemberProjectIdFkeyInput
  updatedAt: Datetime
}

"""
A condition to be used against `ProjectMember` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input ProjectMemberCondition {
  """
  Checks for equality with the object’s `accountId` field.
  """
  accountId: Int

  """
  Checks for equality with the object’s `id` field.
  """
  id: Int

  """
  Checks for equality with the object’s `isResponsibleInstaller` field.
  """
  isResponsibleInstaller: Boolean

  """
  Checks for equality with the object’s `projectId` field.
  """
  projectId: Int
}

"""
A filter to be used against `ProjectMember` object types. All fields are combined with a logical ‘and.’
"""
input ProjectMemberFilter {
  """
  Filter by the object’s `accountId` field.
  """
  accountId: IntFilter

  """
  Checks for all expressions in this list.
  """
  and: [ProjectMemberFilter!]

  """
  Filter by the object’s `id` field.
  """
  id: IntFilter

  """
  Filter by the object’s `isResponsibleInstaller` field.
  """
  isResponsibleInstaller: BooleanFilter

  """
  Negates the expression.
  """
  not: ProjectMemberFilter

  """
  Checks for any expressions in this list.
  """
  or: [ProjectMemberFilter!]

  """
  Filter by the object’s `projectId` field.
  """
  projectId: IntFilter
}

"""
An input for mutations affecting `ProjectMember`
"""
input ProjectMemberInput {
  """
  fk
  """
  accountId: Int
  accountToAccountId: ProjectMemberAccountIdFkeyInput
  createdAt: Datetime

  """
  Primary key
  """
  id: Int

  """
  The responsible installer
  """
  isResponsibleInstaller: Boolean

  """
  fk
  """
  projectId: Int
  projectToProjectId: ProjectMemberProjectIdFkeyInput
  updatedAt: Datetime
}

"""
The globally unique `ID` look up for the row to connect.
"""
input ProjectMemberNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `projectMember` to be connected.
  """
  nodeId: ID!
}

"""
The globally unique `ID` look up for the row to delete.
"""
input ProjectMemberNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `projectMember` to be deleted.
  """
  nodeId: ID!
}

"""
The globally unique `ID` look up for the row to update.
"""
input ProjectMemberOnProjectMemberForProjectMemberAccountIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `account` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: AccountPatch!
}

"""
The fields on `projectMember` to look up the row to update.
"""
input ProjectMemberOnProjectMemberForProjectMemberAccountIdFkeyUsingProjectMemberPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `projectMember` being updated.
  """
  patch: updateProjectMemberOnProjectMemberForProjectMemberAccountIdFkeyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input ProjectMemberOnProjectMemberForProjectMemberProjectIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `project` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `project` being updated.
  """
  patch: ProjectPatch!
}

"""
The fields on `projectMember` to look up the row to update.
"""
input ProjectMemberOnProjectMemberForProjectMemberProjectIdFkeyUsingProjectMemberPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `projectMember` being updated.
  """
  patch: updateProjectMemberOnProjectMemberForProjectMemberProjectIdFkeyPatch!
}

"""
Represents an update to a `ProjectMember`. Fields that are set will be updated.
"""
input ProjectMemberPatch {
  """
  fk
  """
  accountId: Int
  accountToAccountId: ProjectMemberAccountIdFkeyInput
  createdAt: Datetime

  """
  Primary key
  """
  id: Int

  """
  The responsible installer
  """
  isResponsibleInstaller: Boolean

  """
  fk
  """
  projectId: Int
  projectToProjectId: ProjectMemberProjectIdFkeyInput
  updatedAt: Datetime
}

"""
Input for the nested mutation of `project` in the `ProjectMemberInput` mutation.
"""
input ProjectMemberProjectIdFkeyInput {
  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  connectById: ProjectProjectPkeyConnect

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  connectByNodeId: ProjectNodeIdConnect

  """
  A `ProjectInput` object that will be created and connected to this object.
  """
  create: ProjectMemberProjectIdFkeyProjectCreateInput

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  deleteById: ProjectProjectPkeyDelete

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  deleteByNodeId: ProjectNodeIdDelete

  """
  The primary key(s) and patch data for `project` for the far side of the relationship.
  """
  updateById: ProjectOnProjectMemberForProjectMemberProjectIdFkeyUsingProjectPkeyUpdate

  """
  The primary key(s) and patch data for `project` for the far side of the relationship.
  """
  updateByNodeId: ProjectMemberOnProjectMemberForProjectMemberProjectIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `projectMember` in the `ProjectInput` mutation.
"""
input ProjectMemberProjectIdFkeyInverseInput {
  """
  The primary key(s) for `projectMember` for the far side of the relationship.
  """
  connectById: [ProjectMemberProjectMemberPkeyConnect!]

  """
  The primary key(s) for `projectMember` for the far side of the relationship.
  """
  connectByNodeId: [ProjectMemberNodeIdConnect!]

  """
  A `ProjectMemberInput` object that will be created and connected to this object.
  """
  create: [ProjectMemberProjectIdFkeyProjectMemberCreateInput!]

  """
  The primary key(s) for `projectMember` for the far side of the relationship.
  """
  deleteById: [ProjectMemberProjectMemberPkeyDelete!]

  """
  The primary key(s) for `projectMember` for the far side of the relationship.
  """
  deleteByNodeId: [ProjectMemberNodeIdDelete!]

  """
  Flag indicating whether all other `projectMember` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `projectMember` for the far side of the relationship.
  """
  updateById: [ProjectMemberOnProjectMemberForProjectMemberProjectIdFkeyUsingProjectMemberPkeyUpdate!]

  """
  The primary key(s) and patch data for `projectMember` for the far side of the relationship.
  """
  updateByNodeId: [ProjectOnProjectMemberForProjectMemberProjectIdFkeyNodeIdUpdate!]
}

"""
The `project` to be created by this mutation.
"""
input ProjectMemberProjectIdFkeyProjectCreateInput {
  addressToBuildingOwnerAddressId: ProjectBuildingOwnerAddressIdFkeyInput
  addressToSiteAddressId: ProjectSiteAddressIdFkeyInput

  """
  fk
  """
  buildingOwnerAddressId: Int

  """
  Name of the Building Owner company if there is such a thing.  Not the same as an InTouch Company.
  """
  buildingOwnerCompany: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerFirstname: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerLastname: String

  """
  Email address of the person who owns the building that the roof is going on.  Not mandatory for a Project, but mandatory when the Company applies for a Guarantee related to the project.
  """
  buildingOwnerMail: String

  """
  fk
  """
  companyId: Int
  companyToCompanyId: ProjectCompanyIdFkeyInput
  createdAt: Datetime

  """
  Short description of what the Project is about.  Sometimes useful to clarify some points to BMI
  """
  description: String

  """
  The date that the Project officially expects to end or ended
  """
  endDate: Datetime!
  evidenceItemsUsingId: EvidenceItemProjectIdFkeyInverseInput
  guaranteesUsingId: GuaranteeProjectIdFkeyInverseInput

  """
  If this is true then the Project should be hidden from End Users
  """
  hidden: Boolean

  """
  Primary key
  """
  id: Int
  migrationId: String

  """
  Short name for the Project
  """
  name: String!
  notesUsingId: NoteProjectIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberProjectIdFkeyInverseInput

  """
  The number of square meters of roof that this project covers
  """
  roofArea: Int!

  """
  fk
  """
  siteAddressId: Int

  """
  The date that the Project officially starts or started
  """
  startDate: Datetime!

  """
  ek
  """
  technology: Technology!
  updatedAt: Datetime
}

"""
The `projectMember` to be created by this mutation.
"""
input ProjectMemberProjectIdFkeyProjectMemberCreateInput {
  """
  fk
  """
  accountId: Int
  accountToAccountId: ProjectMemberAccountIdFkeyInput
  createdAt: Datetime

  """
  Primary key
  """
  id: Int

  """
  The responsible installer
  """
  isResponsibleInstaller: Boolean
  projectToProjectId: ProjectMemberProjectIdFkeyInput
  updatedAt: Datetime
}

"""
The fields on `projectMember` to look up the row to connect.
"""
input ProjectMemberProjectMemberPkeyConnect {
  """
  Primary key
  """
  id: Int!
}

"""
The fields on `projectMember` to look up the row to delete.
"""
input ProjectMemberProjectMemberPkeyDelete {
  """
  Primary key
  """
  id: Int!
}

"""
All input for the `projectMembersAdd` mutation.
"""
input ProjectMembersAddInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  members: [ProjectMemberInput]!
}

"""
The output of our `projectMembersAdd` mutation.
"""
type ProjectMembersAddPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  projectMembers: [ProjectMember!]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
A connection to a list of `ProjectMember` values.
"""
type ProjectMembersConnection {
  """
  A list of edges which contains the `ProjectMember` and cursor to aid in pagination.
  """
  edges: [ProjectMembersEdge!]!

  """
  A list of `ProjectMember` objects.
  """
  nodes: [ProjectMember!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `ProjectMember` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `ProjectMember` edge in the connection.
"""
type ProjectMembersEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `ProjectMember` at the end of the edge.
  """
  node: ProjectMember!
}

"""
Methods to use when ordering `ProjectMember`.
"""
enum ProjectMembersOrderBy {
  ACCOUNT_ID_ASC
  ACCOUNT_ID_DESC
  ID_ASC
  ID_DESC
  IS_RESPONSIBLE_INSTALLER_ASC
  IS_RESPONSIBLE_INSTALLER_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  PROJECT_ID_ASC
  PROJECT_ID_DESC
}

"""
The globally unique `ID` look up for the row to connect.
"""
input ProjectNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `project` to be connected.
  """
  nodeId: ID!
}

"""
The globally unique `ID` look up for the row to delete.
"""
input ProjectNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `project` to be deleted.
  """
  nodeId: ID!
}

"""
The globally unique `ID` look up for the row to update.
"""
input ProjectOnEvidenceItemForEvidenceItemProjectIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `evidenceItem` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `evidenceItem` being updated.
  """
  patch: EvidenceItemPatch!
}

"""
The fields on `project` to look up the row to update.
"""
input ProjectOnEvidenceItemForEvidenceItemProjectIdFkeyUsingProjectPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `project` being updated.
  """
  patch: updateProjectOnEvidenceItemForEvidenceItemProjectIdFkeyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input ProjectOnGuaranteeForGuaranteeProjectIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `guarantee` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `guarantee` being updated.
  """
  patch: GuaranteePatch!
}

"""
The fields on `project` to look up the row to update.
"""
input ProjectOnGuaranteeForGuaranteeProjectIdFkeyUsingProjectPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `project` being updated.
  """
  patch: updateProjectOnGuaranteeForGuaranteeProjectIdFkeyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input ProjectOnNoteForNoteProjectIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `note` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `note` being updated.
  """
  patch: NotePatch!
}

"""
The fields on `project` to look up the row to update.
"""
input ProjectOnNoteForNoteProjectIdFkeyUsingProjectPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `project` being updated.
  """
  patch: updateProjectOnNoteForNoteProjectIdFkeyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input ProjectOnProjectForProjectBuildingOwnerAddressIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `address` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `address` being updated.
  """
  patch: AddressPatch!
}

"""
The fields on `project` to look up the row to update.
"""
input ProjectOnProjectForProjectBuildingOwnerAddressIdFkeyUsingProjectPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `project` being updated.
  """
  patch: updateProjectOnProjectForProjectBuildingOwnerAddressIdFkeyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input ProjectOnProjectForProjectCompanyIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `company` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: CompanyPatch!
}

"""
The fields on `project` to look up the row to update.
"""
input ProjectOnProjectForProjectCompanyIdFkeyUsingProjectPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `project` being updated.
  """
  patch: updateProjectOnProjectForProjectCompanyIdFkeyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input ProjectOnProjectForProjectSiteAddressIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `address` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `address` being updated.
  """
  patch: AddressPatch!
}

"""
The fields on `project` to look up the row to update.
"""
input ProjectOnProjectForProjectSiteAddressIdFkeyUsingProjectPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `project` being updated.
  """
  patch: updateProjectOnProjectForProjectSiteAddressIdFkeyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input ProjectOnProjectMemberForProjectMemberProjectIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `projectMember` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `projectMember` being updated.
  """
  patch: ProjectMemberPatch!
}

"""
The fields on `project` to look up the row to update.
"""
input ProjectOnProjectMemberForProjectMemberProjectIdFkeyUsingProjectPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `project` being updated.
  """
  patch: updateProjectOnProjectMemberForProjectMemberProjectIdFkeyPatch!
}

"""
Represents an update to a `Project`. Fields that are set will be updated.
"""
input ProjectPatch {
  addressToBuildingOwnerAddressId: ProjectBuildingOwnerAddressIdFkeyInput
  addressToSiteAddressId: ProjectSiteAddressIdFkeyInput

  """
  fk
  """
  buildingOwnerAddressId: Int

  """
  Name of the Building Owner company if there is such a thing.  Not the same as an InTouch Company.
  """
  buildingOwnerCompany: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerFirstname: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerLastname: String

  """
  Email address of the person who owns the building that the roof is going on.  Not mandatory for a Project, but mandatory when the Company applies for a Guarantee related to the project.
  """
  buildingOwnerMail: String

  """
  fk
  """
  companyId: Int
  companyToCompanyId: ProjectCompanyIdFkeyInput
  createdAt: Datetime

  """
  Short description of what the Project is about.  Sometimes useful to clarify some points to BMI
  """
  description: String

  """
  The date that the Project officially expects to end or ended
  """
  endDate: Datetime
  evidenceItemsUsingId: EvidenceItemProjectIdFkeyInverseInput
  guaranteesUsingId: GuaranteeProjectIdFkeyInverseInput

  """
  If this is true then the Project should be hidden from End Users
  """
  hidden: Boolean

  """
  Primary key
  """
  id: Int
  migrationId: String

  """
  Short name for the Project
  """
  name: String
  notesUsingId: NoteProjectIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberProjectIdFkeyInverseInput

  """
  The number of square meters of roof that this project covers
  """
  roofArea: Int

  """
  fk
  """
  siteAddressId: Int

  """
  The date that the Project officially starts or started
  """
  startDate: Datetime

  """
  ek
  """
  technology: Technology
  updatedAt: Datetime
}

"""
The fields on `project` to look up the row to connect.
"""
input ProjectProjectPkeyConnect {
  """
  Primary key
  """
  id: Int!
}

"""
The fields on `project` to look up the row to delete.
"""
input ProjectProjectPkeyDelete {
  """
  Primary key
  """
  id: Int!
}

"""
The `address` to be created by this mutation.
"""
input ProjectSiteAddressIdFkeyAddressCreateInput {
  companiesToRegisteredAddressIdUsingId: CompanyRegisteredAddressIdFkeyInverseInput
  companiesToTradingAddressIdUsingId: CompanyTradingAddressIdFkeyInverseInput

  """
  The coordinates on a map of the world
  """
  coordinates: PointInput

  """
  The country for this address
  """
  country: String
  createdAt: Datetime

  """
  First line of this address
  """
  firstLine: String

  """
  Primary key
  """
  id: Int

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String

  """
  The postcode for this address
  """
  postcode: String
  projectsToBuildingOwnerAddressIdUsingId: ProjectBuildingOwnerAddressIdFkeyInverseInput
  projectsToSiteAddressIdUsingId: ProjectSiteAddressIdFkeyInverseInput

  """
  The region if relevant
  """
  region: String

  """
  Second line of this address
  """
  secondLine: String

  """
  The postal town
  """
  town: String
  updatedAt: Datetime
}

"""
Input for the nested mutation of `address` in the `ProjectInput` mutation.
"""
input ProjectSiteAddressIdFkeyInput {
  """
  The primary key(s) for `address` for the far side of the relationship.
  """
  connectById: AddressAddressPkeyConnect

  """
  The primary key(s) for `address` for the far side of the relationship.
  """
  connectByNodeId: AddressNodeIdConnect

  """
  A `AddressInput` object that will be created and connected to this object.
  """
  create: ProjectSiteAddressIdFkeyAddressCreateInput

  """
  The primary key(s) for `address` for the far side of the relationship.
  """
  deleteById: AddressAddressPkeyDelete

  """
  The primary key(s) for `address` for the far side of the relationship.
  """
  deleteByNodeId: AddressNodeIdDelete

  """
  The primary key(s) and patch data for `address` for the far side of the relationship.
  """
  updateById: AddressOnProjectForProjectSiteAddressIdFkeyUsingAddressPkeyUpdate

  """
  The primary key(s) and patch data for `address` for the far side of the relationship.
  """
  updateByNodeId: ProjectOnProjectForProjectSiteAddressIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `project` in the `AddressInput` mutation.
"""
input ProjectSiteAddressIdFkeyInverseInput {
  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  connectById: [ProjectProjectPkeyConnect!]

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  connectByNodeId: [ProjectNodeIdConnect!]

  """
  A `ProjectInput` object that will be created and connected to this object.
  """
  create: [ProjectSiteAddressIdFkeyProjectCreateInput!]

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  deleteById: [ProjectProjectPkeyDelete!]

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  deleteByNodeId: [ProjectNodeIdDelete!]

  """
  Flag indicating whether all other `project` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `project` for the far side of the relationship.
  """
  updateById: [ProjectOnProjectForProjectSiteAddressIdFkeyUsingProjectPkeyUpdate!]

  """
  The primary key(s) and patch data for `project` for the far side of the relationship.
  """
  updateByNodeId: [AddressOnProjectForProjectSiteAddressIdFkeyNodeIdUpdate!]
}

"""
The `project` to be created by this mutation.
"""
input ProjectSiteAddressIdFkeyProjectCreateInput {
  addressToBuildingOwnerAddressId: ProjectBuildingOwnerAddressIdFkeyInput
  addressToSiteAddressId: ProjectSiteAddressIdFkeyInput

  """
  fk
  """
  buildingOwnerAddressId: Int

  """
  Name of the Building Owner company if there is such a thing.  Not the same as an InTouch Company.
  """
  buildingOwnerCompany: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerFirstname: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerLastname: String

  """
  Email address of the person who owns the building that the roof is going on.  Not mandatory for a Project, but mandatory when the Company applies for a Guarantee related to the project.
  """
  buildingOwnerMail: String

  """
  fk
  """
  companyId: Int
  companyToCompanyId: ProjectCompanyIdFkeyInput
  createdAt: Datetime

  """
  Short description of what the Project is about.  Sometimes useful to clarify some points to BMI
  """
  description: String

  """
  The date that the Project officially expects to end or ended
  """
  endDate: Datetime!
  evidenceItemsUsingId: EvidenceItemProjectIdFkeyInverseInput
  guaranteesUsingId: GuaranteeProjectIdFkeyInverseInput

  """
  If this is true then the Project should be hidden from End Users
  """
  hidden: Boolean

  """
  Primary key
  """
  id: Int
  migrationId: String

  """
  Short name for the Project
  """
  name: String!
  notesUsingId: NoteProjectIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberProjectIdFkeyInverseInput

  """
  The number of square meters of roof that this project covers
  """
  roofArea: Int!

  """
  The date that the Project officially starts or started
  """
  startDate: Datetime!

  """
  ek
  """
  technology: Technology!
  updatedAt: Datetime
}

"""
A connection to a list of `Project` values.
"""
type ProjectsConnection {
  """
  A list of edges which contains the `Project` and cursor to aid in pagination.
  """
  edges: [ProjectsEdge!]!

  """
  A list of `Project` objects.
  """
  nodes: [Project!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Project` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `Project` edge in the connection.
"""
type ProjectsEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Project` at the end of the edge.
  """
  node: Project!
}

"""
Methods to use when ordering `Project`.
"""
enum ProjectsOrderBy {
  BUILDING_OWNER_ADDRESS_ID_ASC
  BUILDING_OWNER_ADDRESS_ID_DESC
  COMPANY_ID_ASC
  COMPANY_ID_DESC
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  SITE_ADDRESS_ID_ASC
  SITE_ADDRESS_ID_DESC
}

type Publish {
  email: String
  html: String
  text: String
  title: String
}

input PublishInput {
  email: String
  html: String
  text: String
  title: String
}

type PublishOutput {
  messageId: String
}

"""
The 'Quality' type represents quality as whole numeric values between `1` and `100`.
"""
scalar Quality

"""
The root query type which gives access points into the data universe.
"""
type Query implements Node {
  """
  Fetches a list of entities using their representations; used for Apollo
  Federation.
  """
  _entities(representations: [_Any!]!): [_Entity]!
    @deprecated(reason: "Only Apollo Federation should use this")

  """
  Entrypoint for Apollo Federation to determine more information about
  this service.
  """
  _service: _Service!
    @deprecated(reason: "Only Apollo Federation should use this")
  account(id: Int!): Account
  accountByDoceboUserId(doceboUserId: Int!): Account
  accountByEmail(email: String!): Account

  """
  Reads a single `Account` using its globally unique `ID`.
  """
  accountByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Account`.
    """
    nodeId: ID!
  ): Account

  """
  Reads and enables pagination through a set of `Account`.
  """
  accounts(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AccountCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AccountFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Account`.
    """
    orderBy: [AccountsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AccountsConnection
  address(id: Int!): Address

  """
  Reads a single `Address` using its globally unique `ID`.
  """
  addressByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Address`.
    """
    nodeId: ID!
  ): Address

  """
  Reads and enables pagination through a set of `Address`.
  """
  addresses(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AddressCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AddressFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Address`.
    """
    orderBy: [AddressesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AddressesConnection
  asset(id: String!, locale: String, preview: Boolean): Asset
  assetCollection(
    limit: Int = 100
    locale: String
    order: [AssetOrder]
    preview: Boolean
    skip: Int = 0
    where: AssetFilter
  ): AssetCollection
  carousel(id: String!, locale: String, preview: Boolean): Carousel
  carouselCollection(
    limit: Int = 100
    locale: String
    order: [CarouselOrder]
    preview: Boolean
    skip: Int = 0
    where: CarouselFilter
  ): CarouselCollection
  carouselItem(id: String!, locale: String, preview: Boolean): CarouselItem
  carouselItemCollection(
    limit: Int = 100
    locale: String
    order: [CarouselItemOrder]
    preview: Boolean
    skip: Int = 0
    where: CarouselItemFilter
  ): CarouselItemCollection
  certification(id: Int!): Certification

  """
  Reads a single `Certification` using its globally unique `ID`.
  """
  certificationByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Certification`.
    """
    nodeId: ID!
  ): Certification

  """
  Reads and enables pagination through a set of `Certification`.
  """
  certifications(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CertificationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CertificationFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Certification`.
    """
    orderBy: [CertificationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CertificationsConnection
  checkUserValidatiy(email: String, username: String): CheckUserValidityPayload

  """
  Reads and enables pagination through a set of `Company`.
  """
  companies(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CompanyCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CompanyFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Company`.
    """
    orderBy: [CompaniesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompaniesConnection
  company(id: Int!): Company
  companyByMarketIdAndName(marketId: Int!, name: String!): Company

  """
  Reads a single `Company` using its globally unique `ID`.
  """
  companyByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Company`.
    """
    nodeId: ID!
  ): Company
  companyByReferenceNumber(referenceNumber: Int!): Company
  companyDocument(id: Int!): CompanyDocument

  """
  Reads a single `CompanyDocument` using its globally unique `ID`.
  """
  companyDocumentByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `CompanyDocument`.
    """
    nodeId: ID!
  ): CompanyDocument

  """
  Reads and enables pagination through a set of `CompanyDocument`.
  """
  companyDocuments(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CompanyDocumentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CompanyDocumentFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `CompanyDocument`.
    """
    orderBy: [CompanyDocumentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompanyDocumentsConnection
  companyMember(id: Int!): CompanyMember
  companyMemberByMarketIdAndAccountIdAndCompanyId(
    accountId: Int!
    companyId: Int!
    marketId: Int!
  ): CompanyMember

  """
  Reads a single `CompanyMember` using its globally unique `ID`.
  """
  companyMemberByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `CompanyMember`.
    """
    nodeId: ID!
  ): CompanyMember

  """
  Reads and enables pagination through a set of `CompanyMember`.
  """
  companyMembers(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CompanyMemberCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CompanyMemberFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `CompanyMember`.
    """
    orderBy: [CompanyMembersOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompanyMembersConnection
  companyOperation(id: Int!): CompanyOperation

  """
  Reads a single `CompanyOperation` using its globally unique `ID`.
  """
  companyOperationByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `CompanyOperation`.
    """
    nodeId: ID!
  ): CompanyOperation

  """
  Reads and enables pagination through a set of `CompanyOperation`.
  """
  companyOperations(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CompanyOperationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CompanyOperationFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `CompanyOperation`.
    """
    orderBy: [CompanyOperationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompanyOperationsConnection
  contactDetails(id: String!, locale: String, preview: Boolean): ContactDetails
  contactDetailsCollection(
    limit: Int = 100
    locale: String
    order: [ContactDetailsOrder]
    preview: Boolean
    skip: Int = 0
    where: ContactDetailsFilter
  ): ContactDetailsCollection
  contentArticle(id: String!, locale: String, preview: Boolean): ContentArticle
  contentArticleCollection(
    limit: Int = 100
    locale: String
    order: [ContentArticleOrder]
    preview: Boolean
    skip: Int = 0
    where: ContentArticleFilter
  ): ContentArticleCollection
  course(id: Int!): Course
  courseByCourseId(courseId: Int!): Course

  """
  Reads a single `Course` using its globally unique `ID`.
  """
  courseByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Course`.
    """
    nodeId: ID!
  ): Course
  courseCatalogue(id: Int!): CourseCatalogue
  courseCatalogueByCatalogueIdAndCourseId(
    catalogueId: Int!
    courseId: Int!
  ): CourseCatalogue

  """
  Reads a single `CourseCatalogue` using its globally unique `ID`.
  """
  courseCatalogueByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `CourseCatalogue`.
    """
    nodeId: ID!
  ): CourseCatalogue
  courseCatalogueTemp(id: Int!): CourseCatalogueTemp

  """
  Reads a single `CourseCatalogueTemp` using its globally unique `ID`.
  """
  courseCatalogueTempByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `CourseCatalogueTemp`.
    """
    nodeId: ID!
  ): CourseCatalogueTemp

  """
  Reads and enables pagination through a set of `CourseCatalogueTemp`.
  """
  courseCatalogueTemps(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CourseCatalogueTempCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `CourseCatalogueTemp`.
    """
    orderBy: [CourseCatalogueTempsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CourseCatalogueTempsConnection

  """
  Reads and enables pagination through a set of `CourseCatalogue`.
  """
  courseCatalogues(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CourseCatalogueCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `CourseCatalogue`.
    """
    orderBy: [CourseCataloguesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CourseCataloguesConnection
  courseEnrollment(id: Int!): CourseEnrollment

  """
  Reads a single `CourseEnrollment` using its globally unique `ID`.
  """
  courseEnrollmentByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `CourseEnrollment`.
    """
    nodeId: ID!
  ): CourseEnrollment
  courseEnrollmentByUserIdAndCourseId(
    courseId: Int!
    userId: Int!
  ): CourseEnrollment
  courseEnrollmentTemp(id: Int!): CourseEnrollmentTemp

  """
  Reads a single `CourseEnrollmentTemp` using its globally unique `ID`.
  """
  courseEnrollmentTempByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `CourseEnrollmentTemp`.
    """
    nodeId: ID!
  ): CourseEnrollmentTemp

  """
  Reads and enables pagination through a set of `CourseEnrollmentTemp`.
  """
  courseEnrollmentTemps(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CourseEnrollmentTempCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `CourseEnrollmentTemp`.
    """
    orderBy: [CourseEnrollmentTempsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CourseEnrollmentTempsConnection

  """
  Reads and enables pagination through a set of `CourseEnrollment`.
  """
  courseEnrollments(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CourseEnrollmentCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `CourseEnrollment`.
    """
    orderBy: [CourseEnrollmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CourseEnrollmentsConnection
  courseSyncConfiguration(id: Int!): CourseSyncConfiguration
  courseSyncConfigurationByConfigName(
    configName: String!
  ): CourseSyncConfiguration

  """
  Reads a single `CourseSyncConfiguration` using its globally unique `ID`.
  """
  courseSyncConfigurationByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `CourseSyncConfiguration`.
    """
    nodeId: ID!
  ): CourseSyncConfiguration

  """
  Reads and enables pagination through a set of `CourseSyncConfiguration`.
  """
  courseSyncConfigurations(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CourseSyncConfigurationCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `CourseSyncConfiguration`.
    """
    orderBy: [CourseSyncConfigurationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CourseSyncConfigurationsConnection
  courseTemp(id: Int!): CourseTemp

  """
  Reads a single `CourseTemp` using its globally unique `ID`.
  """
  courseTempByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `CourseTemp`.
    """
    nodeId: ID!
  ): CourseTemp

  """
  Reads and enables pagination through a set of `CourseTemp`.
  """
  courseTemps(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CourseTempCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `CourseTemp`.
    """
    orderBy: [CourseTempsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CourseTempsConnection

  """
  Reads and enables pagination through a set of `Course`.
  """
  courses(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CourseCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Course`.
    """
    orderBy: [CoursesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CoursesConnection
  currentAccountDoceboId: Int
  currentAccountEmail: String
  currentAccountId: Int
  currentCompany: Int
  currentMarket: Int
  doceboTier(id: Int!): DoceboTier
  doceboTierByMarketIdAndTierCode(marketId: Int!, tierCode: Tier!): DoceboTier

  """
  Reads a single `DoceboTier` using its globally unique `ID`.
  """
  doceboTierByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `DoceboTier`.
    """
    nodeId: ID!
  ): DoceboTier

  """
  Reads and enables pagination through a set of `DoceboTier`.
  """
  doceboTiers(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DoceboTierCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: DoceboTierFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `DoceboTier`.
    """
    orderBy: [DoceboTiersOrderBy!] = [PRIMARY_KEY_ASC]
  ): DoceboTiersConnection
  entryCollection(
    limit: Int = 100
    locale: String
    order: [EntryOrder]
    preview: Boolean
    skip: Int = 0
    where: EntryFilter
  ): EntryCollection
  evidenceCategory(
    id: String!
    locale: String
    preview: Boolean
  ): EvidenceCategory
  evidenceCategoryCollection(
    limit: Int = 100
    locale: String
    order: [EvidenceCategoryOrder]
    preview: Boolean
    skip: Int = 0
    where: EvidenceCategoryFilter
  ): EvidenceCategoryCollection
  evidenceItem(id: Int!): EvidenceItem

  """
  Reads a single `EvidenceItem` using its globally unique `ID`.
  """
  evidenceItemByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `EvidenceItem`.
    """
    nodeId: ID!
  ): EvidenceItem

  """
  Reads and enables pagination through a set of `EvidenceItem`.
  """
  evidenceItems(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EvidenceItemCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EvidenceItemFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `EvidenceItem`.
    """
    orderBy: [EvidenceItemsOrderBy!] = [PRIMARY_KEY_ASC]
  ): EvidenceItemsConnection

  """
  Reads and enables pagination through a set of `EvidenceItem`.
  """
  evidenceItemsByMarket(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EvidenceItemFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int
    market: Int!

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
  ): EvidenceItemsConnection

  """
  Reads and enables pagination through a set of `FindIncompleteCompanyProfile`.
  """
  findIncompleteCompanyProfiles(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `FindIncompleteCompanyProfile`.
    """
    orderBy: [FindIncompleteCompanyProfilesOrderBy!] = [NATURAL]
  ): FindIncompleteCompanyProfilesConnection

  """
  Reads and enables pagination through a set of `FindRoofer`.
  """
  findRoofers(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `FindRoofer`.
    """
    orderBy: [FindRoofersOrderBy!] = [NATURAL]
  ): FindRoofersConnection
  guarantee(id: Int!): Guarantee
  guaranteeByBmiReferenceId(bmiReferenceId: String!): Guarantee

  """
  Reads a single `Guarantee` using its globally unique `ID`.
  """
  guaranteeByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Guarantee`.
    """
    nodeId: ID!
  ): Guarantee
  guaranteeTemplate(
    id: String!
    locale: String
    preview: Boolean
  ): GuaranteeTemplate
  guaranteeTemplateCollection(
    limit: Int = 100
    locale: String
    order: [GuaranteeTemplateOrder]
    preview: Boolean
    skip: Int = 0
    where: GuaranteeTemplateFilter
  ): GuaranteeTemplateCollection
  guaranteeType(id: String!, locale: String, preview: Boolean): GuaranteeType
  guaranteeTypeCollection(
    limit: Int = 100
    locale: String
    order: [GuaranteeTypeOrder]
    preview: Boolean
    skip: Int = 0
    where: GuaranteeTypeFilter
  ): GuaranteeTypeCollection

  """
  Reads and enables pagination through a set of `Guarantee`.
  """
  guarantees(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GuaranteeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: GuaranteeFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Guarantee`.
    """
    orderBy: [GuaranteesOrderBy!] = [PRIMARY_KEY_ASC]
  ): GuaranteesConnection

  """
  Reads and enables pagination through a set of `Guarantee`.
  """
  guaranteesByMarket(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: GuaranteeFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int
    market: Int!

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
  ): GuaranteesConnection
  invitation(id: Int!): Invitation

  """
  Reads a single `Invitation` using its globally unique `ID`.
  """
  invitationByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Invitation`.
    """
    nodeId: ID!
  ): Invitation

  """
  Reads and enables pagination through a set of `Invitation`.
  """
  invitations(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: InvitationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: InvitationFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Invitation`.
    """
    orderBy: [InvitationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): InvitationsConnection
  invitedByCompanies(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: IntFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
  ): InvitedByCompaniesConnection
  isPartOfProject(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: IntFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
  ): IsPartOfProjectConnection
  isProjectEnabledByMarket: Boolean
  market(id: Int!): Market
  marketByDoceboCatalogueId(doceboCatalogueId: Int!): Market
  marketByDomain(domain: String!): Market

  """
  Reads a single `Market` using its globally unique `ID`.
  """
  marketByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Market`.
    """
    nodeId: ID!
  ): Market
  marketContent(id: String!, locale: String, preview: Boolean): MarketContent
  marketContentCollection(
    limit: Int = 100
    locale: String
    order: [MarketContentOrder]
    preview: Boolean
    skip: Int = 0
    where: MarketContentFilter
  ): MarketContentCollection

  """
  Reads and enables pagination through a set of `Market`.
  """
  markets(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MarketCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MarketFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Market`.
    """
    orderBy: [MarketsOrderBy!] = [PRIMARY_KEY_ASC]
  ): MarketsConnection
  mediaFolder(id: String!, locale: String, preview: Boolean): MediaFolder
  mediaFolderCollection(
    limit: Int = 100
    locale: String
    order: [MediaFolderOrder]
    preview: Boolean
    skip: Int = 0
    where: MediaFolderFilter
  ): MediaFolderCollection
  mediaTool(id: String!, locale: String, preview: Boolean): MediaTool
  mediaToolCollection(
    limit: Int = 100
    locale: String
    order: [MediaToolOrder]
    preview: Boolean
    skip: Int = 0
    where: MediaToolFilter
  ): MediaToolCollection
  messageTemplate(
    id: String!
    locale: String
    preview: Boolean
  ): MessageTemplate
  messageTemplateCollection(
    limit: Int = 100
    locale: String
    order: [MessageTemplateOrder]
    preview: Boolean
    skip: Int = 0
    where: MessageTemplateFilter
  ): MessageTemplateCollection
  migration(id: String!, locale: String, preview: Boolean): Migration
  migrationCollection(
    limit: Int = 100
    locale: String
    order: [MigrationOrder]
    preview: Boolean
    skip: Int = 0
    where: MigrationFilter
  ): MigrationCollection

  """
  Fetches an object given its globally unique `ID`.
  """
  node(
    """
    The globally unique `ID`.
    """
    nodeId: ID!
  ): Node

  """
  The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  """
  nodeId: ID!
  note(id: Int!): Note

  """
  Reads a single `Note` using its globally unique `ID`.
  """
  noteByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Note`.
    """
    nodeId: ID!
  ): Note

  """
  Reads and enables pagination through a set of `Note`.
  """
  notes(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: NoteCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: NoteFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Note`.
    """
    orderBy: [NotesOrderBy!] = [PRIMARY_KEY_ASC]
  ): NotesConnection
  notification(id: Int!): Notification

  """
  Reads a single `Notification` using its globally unique `ID`.
  """
  notificationByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Notification`.
    """
    nodeId: ID!
  ): Notification

  """
  Reads and enables pagination through a set of `Notification`.
  """
  notifications(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: NotificationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: NotificationFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Notification`.
    """
    orderBy: [NotificationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): NotificationsConnection
  partnerBrand(id: String!, locale: String, preview: Boolean): PartnerBrand
  partnerBrandCollection(
    limit: Int = 100
    locale: String
    order: [PartnerBrandOrder]
    preview: Boolean
    skip: Int = 0
    where: PartnerBrandFilter
  ): PartnerBrandCollection
  product(id: Int!): Product
  productByBmiRef(bmiRef: String!): Product

  """
  Reads a single `Product` using its globally unique `ID`.
  """
  productByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Product`.
    """
    nodeId: ID!
  ): Product

  """
  Reads and enables pagination through a set of `Product`.
  """
  products(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProductCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProductFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Product`.
    """
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProductsConnection
  project(id: Int!): Project

  """
  Reads a single `Project` using its globally unique `ID`.
  """
  projectByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Project`.
    """
    nodeId: ID!
  ): Project
  projectMember(id: Int!): ProjectMember

  """
  Reads a single `ProjectMember` using its globally unique `ID`.
  """
  projectMemberByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `ProjectMember`.
    """
    nodeId: ID!
  ): ProjectMember

  """
  Reads and enables pagination through a set of `ProjectMember`.
  """
  projectMembers(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectMemberCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProjectMemberFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `ProjectMember`.
    """
    orderBy: [ProjectMembersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectMembersConnection

  """
  Reads and enables pagination through a set of `Project`.
  """
  projects(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProjectFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Project`.
    """
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectsConnection

  """
  Reads and enables pagination through a set of `Project`.
  """
  projectsByMarket(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProjectFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int
    market: Int!

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
  ): ProjectsConnection

  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form.
  """
  query: Query!

  """
  Reads and enables pagination through a set of `Product`.
  """
  searchProducts(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProductFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    query: String!
    technology: Technology!
  ): ProductsConnection

  """
  Reads and enables pagination through a set of `System`.
  """
  searchSystems(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SystemFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    query: String!
    technology: Technology!
  ): SystemsConnection
  system(id: Int!): System
  systemByBmiRef(bmiRef: String!): System

  """
  Reads a single `System` using its globally unique `ID`.
  """
  systemByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `System`.
    """
    nodeId: ID!
  ): System
  systemMember(id: Int!): SystemMember

  """
  Reads a single `SystemMember` using its globally unique `ID`.
  """
  systemMemberByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `SystemMember`.
    """
    nodeId: ID!
  ): SystemMember
  systemMemberBySystemBmiRefAndProductBmiRefAndMarketId(
    marketId: Int!
    productBmiRef: String!
    systemBmiRef: String!
  ): SystemMember

  """
  Reads and enables pagination through a set of `SystemMember`.
  """
  systemMembers(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SystemMemberCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SystemMemberFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `SystemMember`.
    """
    orderBy: [SystemMembersOrderBy!] = [PRIMARY_KEY_ASC]
  ): SystemMembersConnection

  """
  Reads and enables pagination through a set of `System`.
  """
  systems(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SystemCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SystemFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `System`.
    """
    orderBy: [SystemsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SystemsConnection
  tierBenefit(id: String!, locale: String, preview: Boolean): TierBenefit
  tierBenefitCollection(
    limit: Int = 100
    locale: String
    order: [TierBenefitOrder]
    preview: Boolean
    skip: Int = 0
    where: TierBenefitFilter
  ): TierBenefitCollection
  token: Token
  tokenByUsername(username: String!): Token
  trainingContent(
    id: String!
    locale: String
    preview: Boolean
  ): TrainingContent
  trainingContentCollection(
    limit: Int = 100
    locale: String
    order: [TrainingContentOrder]
    preview: Boolean
    skip: Int = 0
    where: TrainingContentFilter
  ): TrainingContentCollection
  userByEmail(email: String): UserData
}

enum RequestStatus {
  APPROVED
  NEW
  REJECTED
  REVIEW
  SUBMITTED
}

enum Role {
  AUDITOR
  COMPANY_ADMIN
  INSTALLER
  MARKET_ADMIN
  SUPER_ADMIN
}

type SSOUrlOutput {
  url: String
}

input SelectOrgchart {
  branch_id: String
}

"""
A filter to be used against String fields. All fields are combined with a logical ‘and.’
"""
input StringFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: String

  """
  Not equal to the specified value, treating null like an ordinary value (case-insensitive).
  """
  distinctFromInsensitive: String

  """
  Ends with the specified string (case-sensitive).
  """
  endsWith: String

  """
  Ends with the specified string (case-insensitive).
  """
  endsWithInsensitive: String

  """
  Equal to the specified value.
  """
  equalTo: String

  """
  Equal to the specified value (case-insensitive).
  """
  equalToInsensitive: String

  """
  Greater than the specified value.
  """
  greaterThan: String

  """
  Greater than the specified value (case-insensitive).
  """
  greaterThanInsensitive: String

  """
  Greater than or equal to the specified value.
  """
  greaterThanOrEqualTo: String

  """
  Greater than or equal to the specified value (case-insensitive).
  """
  greaterThanOrEqualToInsensitive: String

  """
  Included in the specified list.
  """
  in: [String!]

  """
  Included in the specified list (case-insensitive).
  """
  inInsensitive: [String!]

  """
  Contains the specified string (case-sensitive).
  """
  includes: String

  """
  Contains the specified string (case-insensitive).
  """
  includesInsensitive: String

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """
  Less than the specified value.
  """
  lessThan: String

  """
  Less than the specified value (case-insensitive).
  """
  lessThanInsensitive: String

  """
  Less than or equal to the specified value.
  """
  lessThanOrEqualTo: String

  """
  Less than or equal to the specified value (case-insensitive).
  """
  lessThanOrEqualToInsensitive: String

  """
  Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  like: String

  """
  Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  likeInsensitive: String

  """
  Equal to the specified value, treating null like an ordinary value.
  """
  notDistinctFrom: String

  """
  Equal to the specified value, treating null like an ordinary value (case-insensitive).
  """
  notDistinctFromInsensitive: String

  """
  Does not end with the specified string (case-sensitive).
  """
  notEndsWith: String

  """
  Does not end with the specified string (case-insensitive).
  """
  notEndsWithInsensitive: String

  """
  Not equal to the specified value.
  """
  notEqualTo: String

  """
  Not equal to the specified value (case-insensitive).
  """
  notEqualToInsensitive: String

  """
  Not included in the specified list.
  """
  notIn: [String!]

  """
  Not included in the specified list (case-insensitive).
  """
  notInInsensitive: [String!]

  """
  Does not contain the specified string (case-sensitive).
  """
  notIncludes: String

  """
  Does not contain the specified string (case-insensitive).
  """
  notIncludesInsensitive: String

  """
  Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  notLike: String

  """
  Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  notLikeInsensitive: String

  """
  Does not start with the specified string (case-sensitive).
  """
  notStartsWith: String

  """
  Does not start with the specified string (case-insensitive).
  """
  notStartsWithInsensitive: String

  """
  Starts with the specified string (case-sensitive).
  """
  startsWith: String

  """
  Starts with the specified string (case-insensitive).
  """
  startsWithInsensitive: String
}

type Sys {
  environmentId: String!
  firstPublishedAt: DateTime
  id: String!
  publishedAt: DateTime
  publishedVersion: Int
  spaceId: String!
}

input SysFilter {
  firstPublishedAt: DateTime
  firstPublishedAt_exists: Boolean
  firstPublishedAt_gt: DateTime
  firstPublishedAt_gte: DateTime
  firstPublishedAt_in: [DateTime]
  firstPublishedAt_lt: DateTime
  firstPublishedAt_lte: DateTime
  firstPublishedAt_not: DateTime
  firstPublishedAt_not_in: [DateTime]
  id: String
  id_contains: String
  id_exists: Boolean
  id_in: [String]
  id_not: String
  id_not_contains: String
  id_not_in: [String]
  publishedAt: DateTime
  publishedAt_exists: Boolean
  publishedAt_gt: DateTime
  publishedAt_gte: DateTime
  publishedAt_in: [DateTime]
  publishedAt_lt: DateTime
  publishedAt_lte: DateTime
  publishedAt_not: DateTime
  publishedAt_not_in: [DateTime]
  publishedVersion: Float
  publishedVersion_exists: Boolean
  publishedVersion_gt: Float
  publishedVersion_gte: Float
  publishedVersion_in: [Float]
  publishedVersion_lt: Float
  publishedVersion_lte: Float
  publishedVersion_not: Float
  publishedVersion_not_in: [Float]
}

"""
A collection of products that can be guaranteed as a system
"""
type System implements Node {
  """
  A unique reference for the system known to BMI
  """
  bmiRef: String!
  createdAt: Datetime!

  """
  A description for the System
  """
  description: String

  """
  Reads and enables pagination through a set of `Guarantee`.
  """
  guaranteesBySystemBmiRef(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GuaranteeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: GuaranteeFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Guarantee`.
    """
    orderBy: [GuaranteesOrderBy!] = [PRIMARY_KEY_ASC]
  ): GuaranteesConnection!

  """
  Primary key
  """
  id: Int!

  """
  Reads a single `Market` that is related to this `System`.
  """
  market: Market

  """
  fk
  """
  marketId: Int!

  """
  The maximum number of years that this system can be guaranteed for.  Must be greater than 10.
  """
  maximumValidityYears: Int!

  """
  Short name for the System
  """
  name: String!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  If true this system is available for users to select when applying for a system or solution guarantee
  """
  published: Boolean!

  """
  Reads and enables pagination through a set of `SystemMember`.
  """
  systemMembersBySystemBmiRef(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SystemMemberCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SystemMemberFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `SystemMember`.
    """
    orderBy: [SystemMembersOrderBy!] = [PRIMARY_KEY_ASC]
  ): SystemMembersConnection!

  """
  ek
  """
  technology: Technology!
  updatedAt: Datetime!
}

"""
A condition to be used against `System` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input SystemCondition {
  """
  Checks for equality with the object’s `bmiRef` field.
  """
  bmiRef: String

  """
  Checks for equality with the object’s `id` field.
  """
  id: Int

  """
  Checks for equality with the object’s `marketId` field.
  """
  marketId: Int

  """
  Checks for equality with the object’s `name` field.
  """
  name: String
}

"""
A filter to be used against `System` object types. All fields are combined with a logical ‘and.’
"""
input SystemFilter {
  """
  Checks for all expressions in this list.
  """
  and: [SystemFilter!]

  """
  Filter by the object’s `bmiRef` field.
  """
  bmiRef: StringFilter

  """
  Filter by the object’s `id` field.
  """
  id: IntFilter

  """
  Filter by the object’s `marketId` field.
  """
  marketId: IntFilter

  """
  Filter by the object’s `name` field.
  """
  name: StringFilter

  """
  Negates the expression.
  """
  not: SystemFilter

  """
  Checks for any expressions in this list.
  """
  or: [SystemFilter!]
}

"""
An input for mutations affecting `System`
"""
input SystemInput {
  """
  A unique reference for the system known to BMI
  """
  bmiRef: String!
  createdAt: Datetime

  """
  A description for the System
  """
  description: String
  guaranteesUsingBmiRef: GuaranteeSystemBmiRefFkeyInverseInput

  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int
  marketToMarketId: SystemMarketIdFkeyInput

  """
  The maximum number of years that this system can be guaranteed for.  Must be greater than 10.
  """
  maximumValidityYears: Int!

  """
  Short name for the System
  """
  name: String!

  """
  If true this system is available for users to select when applying for a system or solution guarantee
  """
  published: Boolean!
  systemMembersUsingBmiRef: SystemMemberSystemBmiRefFkeyInverseInput

  """
  ek
  """
  technology: Technology!
  updatedAt: Datetime
}

"""
Input for the nested mutation of `market` in the `SystemInput` mutation.
"""
input SystemMarketIdFkeyInput {
  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectByDoceboCatalogueId: MarketMarketDoceboCatalogueIdKeyConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectByDomain: MarketMarketDomainKeyConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectById: MarketMarketPkeyConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectByNodeId: MarketNodeIdConnect

  """
  A `MarketInput` object that will be created and connected to this object.
  """
  create: SystemMarketIdFkeyMarketCreateInput

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteByDoceboCatalogueId: MarketMarketDoceboCatalogueIdKeyDelete

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteByDomain: MarketMarketDomainKeyDelete

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteById: MarketMarketPkeyDelete

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteByNodeId: MarketNodeIdDelete

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateByDoceboCatalogueId: MarketOnSystemForSystemMarketIdFkeyUsingMarketDoceboCatalogueIdKeyUpdate

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateByDomain: MarketOnSystemForSystemMarketIdFkeyUsingMarketDomainKeyUpdate

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateById: MarketOnSystemForSystemMarketIdFkeyUsingMarketPkeyUpdate

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateByNodeId: SystemOnSystemForSystemMarketIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `system` in the `MarketInput` mutation.
"""
input SystemMarketIdFkeyInverseInput {
  """
  The primary key(s) for `system` for the far side of the relationship.
  """
  connectByBmiRef: [SystemSystemBmiRefKeyConnect!]

  """
  The primary key(s) for `system` for the far side of the relationship.
  """
  connectById: [SystemSystemPkeyConnect!]

  """
  The primary key(s) for `system` for the far side of the relationship.
  """
  connectByNodeId: [SystemNodeIdConnect!]

  """
  A `SystemInput` object that will be created and connected to this object.
  """
  create: [SystemMarketIdFkeySystemCreateInput!]

  """
  The primary key(s) for `system` for the far side of the relationship.
  """
  deleteByBmiRef: [SystemSystemBmiRefKeyDelete!]

  """
  The primary key(s) for `system` for the far side of the relationship.
  """
  deleteById: [SystemSystemPkeyDelete!]

  """
  The primary key(s) for `system` for the far side of the relationship.
  """
  deleteByNodeId: [SystemNodeIdDelete!]

  """
  Flag indicating whether all other `system` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `system` for the far side of the relationship.
  """
  updateByBmiRef: [SystemOnSystemForSystemMarketIdFkeyUsingSystemBmiRefKeyUpdate!]

  """
  The primary key(s) and patch data for `system` for the far side of the relationship.
  """
  updateById: [SystemOnSystemForSystemMarketIdFkeyUsingSystemPkeyUpdate!]

  """
  The primary key(s) and patch data for `system` for the far side of the relationship.
  """
  updateByNodeId: [MarketOnSystemForSystemMarketIdFkeyNodeIdUpdate!]
}

"""
The `market` to be created by this mutation.
"""
input SystemMarketIdFkeyMarketCreateInput {
  accountsUsingId: AccountMarketIdFkeyInverseInput

  """
  The space in Contenful
  """
  cmsSpaceId: String
  companiesUsingId: CompanyMarketIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberMarketIdFkeyInverseInput
  createdAt: Datetime

  """
  The default catalogue for the Market.  All users in the Market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int
  doceboCatalogueIdT2: Int
  doceboCatalogueIdT3: Int
  doceboCatalogueIdT4: Int

  """
  The Docebo branch that new user are inserted into if they register as a Company Admin. Note that this never gets updated by InTouch. Originally there was going to be a distinction between installer branches and admin branches in Docebo, but this is no longer the preferred approach.
  """
  doceboCompanyAdminBranchId: String

  """
  The Docebo branch that new user are inserted into if they register as an installer.  Note that this never gets updated by InTouch.  Originally there was going to be a distinction between installer branches and admin branches in Docebo, but this is no longer the preferred approach.
  """
  doceboInstallersBranchId: String

  """
  the country code used for example as the subdomain
  """
  domain: String!

  """
  The coordinates of the middle of the Market on a map
  """
  geoMiddle: PointInput

  """
  Reference to the Google Analytics tracking ID that is used for the Country GA reports
  """
  gtag: String
  gtagMarketMedia: String

  """
  Primary key
  """
  id: Int

  """
  ek
  """
  language: Language!

  """
  The length of the radius in km (from the geo_middle lat/lng), for which the Google Places API biases the search results for address autocomplete. Locations outside of the radius will not be excluded.
  """
  locationBiasRadiusKm: Int

  """
  The address of the merchandising site for the market.  CTAs of the MERCHANDISING type will link to this address
  """
  merchandisingUrl: String

  """
  A short name for the market, e.g. Italy, Norway, Netherlands
  """
  name: String
  productsUsingId: ProductMarketIdFkeyInverseInput

  """
  Whether the market supports Projects.  If so then the Projects link should be available in th left hand navigation.
  """
  projectsEnabled: Boolean

  """
  The mailbox on intouch.bmigroup.com that emails will be sent from for this Market
  """
  sendMailbox: String

  """
  The From name used when sending an email
  """
  sendName: String
  systemMembersUsingId: SystemMemberMarketIdFkeyInverseInput
  systemsUsingId: SystemMarketIdFkeyInverseInput
  updatedAt: Datetime
}

"""
The `system` to be created by this mutation.
"""
input SystemMarketIdFkeySystemCreateInput {
  """
  A unique reference for the system known to BMI
  """
  bmiRef: String!
  createdAt: Datetime

  """
  A description for the System
  """
  description: String
  guaranteesUsingBmiRef: GuaranteeSystemBmiRefFkeyInverseInput

  """
  Primary key
  """
  id: Int
  marketToMarketId: SystemMarketIdFkeyInput

  """
  The maximum number of years that this system can be guaranteed for.  Must be greater than 10.
  """
  maximumValidityYears: Int!

  """
  Short name for the System
  """
  name: String!

  """
  If true this system is available for users to select when applying for a system or solution guarantee
  """
  published: Boolean!
  systemMembersUsingBmiRef: SystemMemberSystemBmiRefFkeyInverseInput

  """
  ek
  """
  technology: Technology!
  updatedAt: Datetime
}

"""
A Products that make up a system
"""
type SystemMember implements Node {
  createdAt: Datetime!

  """
  Primary key
  """
  id: Int!

  """
  Reads a single `Market` that is related to this `SystemMember`.
  """
  market: Market

  """
  fk
  """
  marketId: Int!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  fk
  """
  productBmiRef: String!

  """
  Reads a single `Product` that is related to this `SystemMember`.
  """
  productByProductBmiRef: Product

  """
  fk
  """
  systemBmiRef: String!

  """
  Reads a single `System` that is related to this `SystemMember`.
  """
  systemBySystemBmiRef: System
  updatedAt: Datetime!
}

"""
A condition to be used against `SystemMember` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input SystemMemberCondition {
  """
  Checks for equality with the object’s `id` field.
  """
  id: Int

  """
  Checks for equality with the object’s `marketId` field.
  """
  marketId: Int

  """
  Checks for equality with the object’s `productBmiRef` field.
  """
  productBmiRef: String

  """
  Checks for equality with the object’s `systemBmiRef` field.
  """
  systemBmiRef: String
}

"""
A filter to be used against `SystemMember` object types. All fields are combined with a logical ‘and.’
"""
input SystemMemberFilter {
  """
  Checks for all expressions in this list.
  """
  and: [SystemMemberFilter!]

  """
  Filter by the object’s `id` field.
  """
  id: IntFilter

  """
  Filter by the object’s `marketId` field.
  """
  marketId: IntFilter

  """
  Negates the expression.
  """
  not: SystemMemberFilter

  """
  Checks for any expressions in this list.
  """
  or: [SystemMemberFilter!]

  """
  Filter by the object’s `productBmiRef` field.
  """
  productBmiRef: StringFilter

  """
  Filter by the object’s `systemBmiRef` field.
  """
  systemBmiRef: StringFilter
}

"""
An input for mutations affecting `SystemMember`
"""
input SystemMemberInput {
  createdAt: Datetime

  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int
  marketToMarketId: SystemMemberMarketIdFkeyInput

  """
  fk
  """
  productBmiRef: String
  productToProductBmiRef: SystemMemberProductBmiRefFkeyInput

  """
  fk
  """
  systemBmiRef: String
  systemToSystemBmiRef: SystemMemberSystemBmiRefFkeyInput
  updatedAt: Datetime
}

"""
Input for the nested mutation of `market` in the `SystemMemberInput` mutation.
"""
input SystemMemberMarketIdFkeyInput {
  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectByDoceboCatalogueId: MarketMarketDoceboCatalogueIdKeyConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectByDomain: MarketMarketDomainKeyConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectById: MarketMarketPkeyConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectByNodeId: MarketNodeIdConnect

  """
  A `MarketInput` object that will be created and connected to this object.
  """
  create: SystemMemberMarketIdFkeyMarketCreateInput

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteByDoceboCatalogueId: MarketMarketDoceboCatalogueIdKeyDelete

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteByDomain: MarketMarketDomainKeyDelete

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteById: MarketMarketPkeyDelete

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteByNodeId: MarketNodeIdDelete

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateByDoceboCatalogueId: MarketOnSystemMemberForSystemMemberMarketIdFkeyUsingMarketDoceboCatalogueIdKeyUpdate

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateByDomain: MarketOnSystemMemberForSystemMemberMarketIdFkeyUsingMarketDomainKeyUpdate

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateById: MarketOnSystemMemberForSystemMemberMarketIdFkeyUsingMarketPkeyUpdate

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateByNodeId: SystemMemberOnSystemMemberForSystemMemberMarketIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `systemMember` in the `MarketInput` mutation.
"""
input SystemMemberMarketIdFkeyInverseInput {
  """
  The primary key(s) for `systemMember` for the far side of the relationship.
  """
  connectById: [SystemMemberSystemMemberPkeyConnect!]

  """
  The primary key(s) for `systemMember` for the far side of the relationship.
  """
  connectByNodeId: [SystemMemberNodeIdConnect!]

  """
  The primary key(s) for `systemMember` for the far side of the relationship.
  """
  connectBySystemBmiRefAndProductBmiRefAndMarketId: [SystemMemberSystemMemberSystemBmiRefProductBmiRefMarketIdKeyConnect!]

  """
  A `SystemMemberInput` object that will be created and connected to this object.
  """
  create: [SystemMemberMarketIdFkeySystemMemberCreateInput!]

  """
  The primary key(s) for `systemMember` for the far side of the relationship.
  """
  deleteById: [SystemMemberSystemMemberPkeyDelete!]

  """
  The primary key(s) for `systemMember` for the far side of the relationship.
  """
  deleteByNodeId: [SystemMemberNodeIdDelete!]

  """
  The primary key(s) for `systemMember` for the far side of the relationship.
  """
  deleteBySystemBmiRefAndProductBmiRefAndMarketId: [SystemMemberSystemMemberSystemBmiRefProductBmiRefMarketIdKeyDelete!]

  """
  Flag indicating whether all other `systemMember` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `systemMember` for the far side of the relationship.
  """
  updateById: [SystemMemberOnSystemMemberForSystemMemberMarketIdFkeyUsingSystemMemberPkeyUpdate!]

  """
  The primary key(s) and patch data for `systemMember` for the far side of the relationship.
  """
  updateByNodeId: [MarketOnSystemMemberForSystemMemberMarketIdFkeyNodeIdUpdate!]

  """
  The primary key(s) and patch data for `systemMember` for the far side of the relationship.
  """
  updateBySystemBmiRefAndProductBmiRefAndMarketId: [SystemMemberOnSystemMemberForSystemMemberMarketIdFkeyUsingSystemMemberSystemBmiRefProductBmiRefMarketIdKeyUpdate!]
}

"""
The `market` to be created by this mutation.
"""
input SystemMemberMarketIdFkeyMarketCreateInput {
  accountsUsingId: AccountMarketIdFkeyInverseInput

  """
  The space in Contenful
  """
  cmsSpaceId: String
  companiesUsingId: CompanyMarketIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberMarketIdFkeyInverseInput
  createdAt: Datetime

  """
  The default catalogue for the Market.  All users in the Market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int
  doceboCatalogueIdT2: Int
  doceboCatalogueIdT3: Int
  doceboCatalogueIdT4: Int

  """
  The Docebo branch that new user are inserted into if they register as a Company Admin. Note that this never gets updated by InTouch. Originally there was going to be a distinction between installer branches and admin branches in Docebo, but this is no longer the preferred approach.
  """
  doceboCompanyAdminBranchId: String

  """
  The Docebo branch that new user are inserted into if they register as an installer.  Note that this never gets updated by InTouch.  Originally there was going to be a distinction between installer branches and admin branches in Docebo, but this is no longer the preferred approach.
  """
  doceboInstallersBranchId: String

  """
  the country code used for example as the subdomain
  """
  domain: String!

  """
  The coordinates of the middle of the Market on a map
  """
  geoMiddle: PointInput

  """
  Reference to the Google Analytics tracking ID that is used for the Country GA reports
  """
  gtag: String
  gtagMarketMedia: String

  """
  Primary key
  """
  id: Int

  """
  ek
  """
  language: Language!

  """
  The length of the radius in km (from the geo_middle lat/lng), for which the Google Places API biases the search results for address autocomplete. Locations outside of the radius will not be excluded.
  """
  locationBiasRadiusKm: Int

  """
  The address of the merchandising site for the market.  CTAs of the MERCHANDISING type will link to this address
  """
  merchandisingUrl: String

  """
  A short name for the market, e.g. Italy, Norway, Netherlands
  """
  name: String
  productsUsingId: ProductMarketIdFkeyInverseInput

  """
  Whether the market supports Projects.  If so then the Projects link should be available in th left hand navigation.
  """
  projectsEnabled: Boolean

  """
  The mailbox on intouch.bmigroup.com that emails will be sent from for this Market
  """
  sendMailbox: String

  """
  The From name used when sending an email
  """
  sendName: String
  systemMembersUsingId: SystemMemberMarketIdFkeyInverseInput
  systemsUsingId: SystemMarketIdFkeyInverseInput
  updatedAt: Datetime
}

"""
The `systemMember` to be created by this mutation.
"""
input SystemMemberMarketIdFkeySystemMemberCreateInput {
  createdAt: Datetime

  """
  Primary key
  """
  id: Int
  marketToMarketId: SystemMemberMarketIdFkeyInput

  """
  fk
  """
  productBmiRef: String
  productToProductBmiRef: SystemMemberProductBmiRefFkeyInput

  """
  fk
  """
  systemBmiRef: String
  systemToSystemBmiRef: SystemMemberSystemBmiRefFkeyInput
  updatedAt: Datetime
}

"""
The globally unique `ID` look up for the row to connect.
"""
input SystemMemberNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `systemMember` to be connected.
  """
  nodeId: ID!
}

"""
The globally unique `ID` look up for the row to delete.
"""
input SystemMemberNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `systemMember` to be deleted.
  """
  nodeId: ID!
}

"""
The globally unique `ID` look up for the row to update.
"""
input SystemMemberOnSystemMemberForSystemMemberMarketIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `market` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: MarketPatch!
}

"""
The fields on `systemMember` to look up the row to update.
"""
input SystemMemberOnSystemMemberForSystemMemberMarketIdFkeyUsingSystemMemberPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `systemMember` being updated.
  """
  patch: updateSystemMemberOnSystemMemberForSystemMemberMarketIdFkeyPatch!
}

"""
The fields on `systemMember` to look up the row to update.
"""
input SystemMemberOnSystemMemberForSystemMemberMarketIdFkeyUsingSystemMemberSystemBmiRefProductBmiRefMarketIdKeyUpdate {
  """
  fk
  """
  marketId: Int!

  """
  An object where the defined keys will be set on the `systemMember` being updated.
  """
  patch: updateSystemMemberOnSystemMemberForSystemMemberMarketIdFkeyPatch!

  """
  fk
  """
  productBmiRef: String!

  """
  fk
  """
  systemBmiRef: String!
}

"""
The globally unique `ID` look up for the row to update.
"""
input SystemMemberOnSystemMemberForSystemMemberProductBmiRefFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `product` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `product` being updated.
  """
  patch: ProductPatch!
}

"""
The fields on `systemMember` to look up the row to update.
"""
input SystemMemberOnSystemMemberForSystemMemberProductBmiRefFkeyUsingSystemMemberPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `systemMember` being updated.
  """
  patch: updateSystemMemberOnSystemMemberForSystemMemberProductBmiRefFkeyPatch!
}

"""
The fields on `systemMember` to look up the row to update.
"""
input SystemMemberOnSystemMemberForSystemMemberProductBmiRefFkeyUsingSystemMemberSystemBmiRefProductBmiRefMarketIdKeyUpdate {
  """
  fk
  """
  marketId: Int!

  """
  An object where the defined keys will be set on the `systemMember` being updated.
  """
  patch: updateSystemMemberOnSystemMemberForSystemMemberProductBmiRefFkeyPatch!

  """
  fk
  """
  productBmiRef: String!

  """
  fk
  """
  systemBmiRef: String!
}

"""
The globally unique `ID` look up for the row to update.
"""
input SystemMemberOnSystemMemberForSystemMemberSystemBmiRefFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `system` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `system` being updated.
  """
  patch: SystemPatch!
}

"""
The fields on `systemMember` to look up the row to update.
"""
input SystemMemberOnSystemMemberForSystemMemberSystemBmiRefFkeyUsingSystemMemberPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `systemMember` being updated.
  """
  patch: updateSystemMemberOnSystemMemberForSystemMemberSystemBmiRefFkeyPatch!
}

"""
The fields on `systemMember` to look up the row to update.
"""
input SystemMemberOnSystemMemberForSystemMemberSystemBmiRefFkeyUsingSystemMemberSystemBmiRefProductBmiRefMarketIdKeyUpdate {
  """
  fk
  """
  marketId: Int!

  """
  An object where the defined keys will be set on the `systemMember` being updated.
  """
  patch: updateSystemMemberOnSystemMemberForSystemMemberSystemBmiRefFkeyPatch!

  """
  fk
  """
  productBmiRef: String!

  """
  fk
  """
  systemBmiRef: String!
}

"""
Represents an update to a `SystemMember`. Fields that are set will be updated.
"""
input SystemMemberPatch {
  createdAt: Datetime

  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int
  marketToMarketId: SystemMemberMarketIdFkeyInput

  """
  fk
  """
  productBmiRef: String
  productToProductBmiRef: SystemMemberProductBmiRefFkeyInput

  """
  fk
  """
  systemBmiRef: String
  systemToSystemBmiRef: SystemMemberSystemBmiRefFkeyInput
  updatedAt: Datetime
}

"""
Input for the nested mutation of `product` in the `SystemMemberInput` mutation.
"""
input SystemMemberProductBmiRefFkeyInput {
  """
  The primary key(s) for `product` for the far side of the relationship.
  """
  connectByBmiRef: ProductProductBmiRefKeyConnect

  """
  The primary key(s) for `product` for the far side of the relationship.
  """
  connectById: ProductProductPkeyConnect

  """
  The primary key(s) for `product` for the far side of the relationship.
  """
  connectByNodeId: ProductNodeIdConnect

  """
  A `ProductInput` object that will be created and connected to this object.
  """
  create: SystemMemberProductBmiRefFkeyProductCreateInput

  """
  The primary key(s) for `product` for the far side of the relationship.
  """
  deleteByBmiRef: ProductProductBmiRefKeyDelete

  """
  The primary key(s) for `product` for the far side of the relationship.
  """
  deleteById: ProductProductPkeyDelete

  """
  The primary key(s) for `product` for the far side of the relationship.
  """
  deleteByNodeId: ProductNodeIdDelete

  """
  The primary key(s) and patch data for `product` for the far side of the relationship.
  """
  updateByBmiRef: ProductOnSystemMemberForSystemMemberProductBmiRefFkeyUsingProductBmiRefKeyUpdate

  """
  The primary key(s) and patch data for `product` for the far side of the relationship.
  """
  updateById: ProductOnSystemMemberForSystemMemberProductBmiRefFkeyUsingProductPkeyUpdate

  """
  The primary key(s) and patch data for `product` for the far side of the relationship.
  """
  updateByNodeId: SystemMemberOnSystemMemberForSystemMemberProductBmiRefFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `systemMember` in the `ProductInput` mutation.
"""
input SystemMemberProductBmiRefFkeyInverseInput {
  """
  The primary key(s) for `systemMember` for the far side of the relationship.
  """
  connectById: [SystemMemberSystemMemberPkeyConnect!]

  """
  The primary key(s) for `systemMember` for the far side of the relationship.
  """
  connectByNodeId: [SystemMemberNodeIdConnect!]

  """
  The primary key(s) for `systemMember` for the far side of the relationship.
  """
  connectBySystemBmiRefAndProductBmiRefAndMarketId: [SystemMemberSystemMemberSystemBmiRefProductBmiRefMarketIdKeyConnect!]

  """
  A `SystemMemberInput` object that will be created and connected to this object.
  """
  create: [SystemMemberProductBmiRefFkeySystemMemberCreateInput!]

  """
  The primary key(s) for `systemMember` for the far side of the relationship.
  """
  deleteById: [SystemMemberSystemMemberPkeyDelete!]

  """
  The primary key(s) for `systemMember` for the far side of the relationship.
  """
  deleteByNodeId: [SystemMemberNodeIdDelete!]

  """
  The primary key(s) for `systemMember` for the far side of the relationship.
  """
  deleteBySystemBmiRefAndProductBmiRefAndMarketId: [SystemMemberSystemMemberSystemBmiRefProductBmiRefMarketIdKeyDelete!]

  """
  Flag indicating whether all other `systemMember` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `systemMember` for the far side of the relationship.
  """
  updateById: [SystemMemberOnSystemMemberForSystemMemberProductBmiRefFkeyUsingSystemMemberPkeyUpdate!]

  """
  The primary key(s) and patch data for `systemMember` for the far side of the relationship.
  """
  updateByNodeId: [ProductOnSystemMemberForSystemMemberProductBmiRefFkeyNodeIdUpdate!]

  """
  The primary key(s) and patch data for `systemMember` for the far side of the relationship.
  """
  updateBySystemBmiRefAndProductBmiRefAndMarketId: [SystemMemberOnSystemMemberForSystemMemberProductBmiRefFkeyUsingSystemMemberSystemBmiRefProductBmiRefMarketIdKeyUpdate!]
}

"""
The `product` to be created by this mutation.
"""
input SystemMemberProductBmiRefFkeyProductCreateInput {
  """
  A unique reference for the product known to BMI
  """
  bmiRef: String!

  """
  The Products brand
  """
  brand: String!
  createdAt: Datetime

  """
  A description of the Product
  """
  description: String

  """
  The family of Products this Product is in
  """
  family: String!
  guaranteesUsingBmiRef: GuaranteeProductBmiRefFkeyInverseInput

  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int
  marketToMarketId: ProductMarketIdFkeyInput

  """
  The number of years that this product can be guaranteed for
  """
  maximumValidityYears: Int!

  """
  Short name for the Product
  """
  name: String!

  """
  Whether the Product is avialable for new guarantees
  """
  published: Boolean!
  systemMembersUsingBmiRef: SystemMemberProductBmiRefFkeyInverseInput

  """
  ek
  """
  technology: Technology!
  updatedAt: Datetime
}

"""
The `systemMember` to be created by this mutation.
"""
input SystemMemberProductBmiRefFkeySystemMemberCreateInput {
  createdAt: Datetime

  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int
  marketToMarketId: SystemMemberMarketIdFkeyInput
  productToProductBmiRef: SystemMemberProductBmiRefFkeyInput

  """
  fk
  """
  systemBmiRef: String
  systemToSystemBmiRef: SystemMemberSystemBmiRefFkeyInput
  updatedAt: Datetime
}

"""
Input for the nested mutation of `system` in the `SystemMemberInput` mutation.
"""
input SystemMemberSystemBmiRefFkeyInput {
  """
  The primary key(s) for `system` for the far side of the relationship.
  """
  connectByBmiRef: SystemSystemBmiRefKeyConnect

  """
  The primary key(s) for `system` for the far side of the relationship.
  """
  connectById: SystemSystemPkeyConnect

  """
  The primary key(s) for `system` for the far side of the relationship.
  """
  connectByNodeId: SystemNodeIdConnect

  """
  A `SystemInput` object that will be created and connected to this object.
  """
  create: SystemMemberSystemBmiRefFkeySystemCreateInput

  """
  The primary key(s) for `system` for the far side of the relationship.
  """
  deleteByBmiRef: SystemSystemBmiRefKeyDelete

  """
  The primary key(s) for `system` for the far side of the relationship.
  """
  deleteById: SystemSystemPkeyDelete

  """
  The primary key(s) for `system` for the far side of the relationship.
  """
  deleteByNodeId: SystemNodeIdDelete

  """
  The primary key(s) and patch data for `system` for the far side of the relationship.
  """
  updateByBmiRef: SystemOnSystemMemberForSystemMemberSystemBmiRefFkeyUsingSystemBmiRefKeyUpdate

  """
  The primary key(s) and patch data for `system` for the far side of the relationship.
  """
  updateById: SystemOnSystemMemberForSystemMemberSystemBmiRefFkeyUsingSystemPkeyUpdate

  """
  The primary key(s) and patch data for `system` for the far side of the relationship.
  """
  updateByNodeId: SystemMemberOnSystemMemberForSystemMemberSystemBmiRefFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `systemMember` in the `SystemInput` mutation.
"""
input SystemMemberSystemBmiRefFkeyInverseInput {
  """
  The primary key(s) for `systemMember` for the far side of the relationship.
  """
  connectById: [SystemMemberSystemMemberPkeyConnect!]

  """
  The primary key(s) for `systemMember` for the far side of the relationship.
  """
  connectByNodeId: [SystemMemberNodeIdConnect!]

  """
  The primary key(s) for `systemMember` for the far side of the relationship.
  """
  connectBySystemBmiRefAndProductBmiRefAndMarketId: [SystemMemberSystemMemberSystemBmiRefProductBmiRefMarketIdKeyConnect!]

  """
  A `SystemMemberInput` object that will be created and connected to this object.
  """
  create: [SystemMemberSystemBmiRefFkeySystemMemberCreateInput!]

  """
  The primary key(s) for `systemMember` for the far side of the relationship.
  """
  deleteById: [SystemMemberSystemMemberPkeyDelete!]

  """
  The primary key(s) for `systemMember` for the far side of the relationship.
  """
  deleteByNodeId: [SystemMemberNodeIdDelete!]

  """
  The primary key(s) for `systemMember` for the far side of the relationship.
  """
  deleteBySystemBmiRefAndProductBmiRefAndMarketId: [SystemMemberSystemMemberSystemBmiRefProductBmiRefMarketIdKeyDelete!]

  """
  Flag indicating whether all other `systemMember` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `systemMember` for the far side of the relationship.
  """
  updateById: [SystemMemberOnSystemMemberForSystemMemberSystemBmiRefFkeyUsingSystemMemberPkeyUpdate!]

  """
  The primary key(s) and patch data for `systemMember` for the far side of the relationship.
  """
  updateByNodeId: [SystemOnSystemMemberForSystemMemberSystemBmiRefFkeyNodeIdUpdate!]

  """
  The primary key(s) and patch data for `systemMember` for the far side of the relationship.
  """
  updateBySystemBmiRefAndProductBmiRefAndMarketId: [SystemMemberOnSystemMemberForSystemMemberSystemBmiRefFkeyUsingSystemMemberSystemBmiRefProductBmiRefMarketIdKeyUpdate!]
}

"""
The `system` to be created by this mutation.
"""
input SystemMemberSystemBmiRefFkeySystemCreateInput {
  """
  A unique reference for the system known to BMI
  """
  bmiRef: String!
  createdAt: Datetime

  """
  A description for the System
  """
  description: String
  guaranteesUsingBmiRef: GuaranteeSystemBmiRefFkeyInverseInput

  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int
  marketToMarketId: SystemMarketIdFkeyInput

  """
  The maximum number of years that this system can be guaranteed for.  Must be greater than 10.
  """
  maximumValidityYears: Int!

  """
  Short name for the System
  """
  name: String!

  """
  If true this system is available for users to select when applying for a system or solution guarantee
  """
  published: Boolean!
  systemMembersUsingBmiRef: SystemMemberSystemBmiRefFkeyInverseInput

  """
  ek
  """
  technology: Technology!
  updatedAt: Datetime
}

"""
The `systemMember` to be created by this mutation.
"""
input SystemMemberSystemBmiRefFkeySystemMemberCreateInput {
  createdAt: Datetime

  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int
  marketToMarketId: SystemMemberMarketIdFkeyInput

  """
  fk
  """
  productBmiRef: String
  productToProductBmiRef: SystemMemberProductBmiRefFkeyInput
  systemToSystemBmiRef: SystemMemberSystemBmiRefFkeyInput
  updatedAt: Datetime
}

"""
The fields on `systemMember` to look up the row to connect.
"""
input SystemMemberSystemMemberPkeyConnect {
  """
  Primary key
  """
  id: Int!
}

"""
The fields on `systemMember` to look up the row to delete.
"""
input SystemMemberSystemMemberPkeyDelete {
  """
  Primary key
  """
  id: Int!
}

"""
The fields on `systemMember` to look up the row to connect.
"""
input SystemMemberSystemMemberSystemBmiRefProductBmiRefMarketIdKeyConnect {
  """
  fk
  """
  marketId: Int!

  """
  fk
  """
  productBmiRef: String!

  """
  fk
  """
  systemBmiRef: String!
}

"""
The fields on `systemMember` to look up the row to delete.
"""
input SystemMemberSystemMemberSystemBmiRefProductBmiRefMarketIdKeyDelete {
  """
  fk
  """
  marketId: Int!

  """
  fk
  """
  productBmiRef: String!

  """
  fk
  """
  systemBmiRef: String!
}

"""
A connection to a list of `SystemMember` values.
"""
type SystemMembersConnection {
  """
  A list of edges which contains the `SystemMember` and cursor to aid in pagination.
  """
  edges: [SystemMembersEdge!]!

  """
  A list of `SystemMember` objects.
  """
  nodes: [SystemMember!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `SystemMember` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `SystemMember` edge in the connection.
"""
type SystemMembersEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `SystemMember` at the end of the edge.
  """
  node: SystemMember!
}

"""
Methods to use when ordering `SystemMember`.
"""
enum SystemMembersOrderBy {
  ID_ASC
  ID_DESC
  MARKET_ID_ASC
  MARKET_ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  PRODUCT_BMI_REF_ASC
  PRODUCT_BMI_REF_DESC
  SYSTEM_BMI_REF_ASC
  SYSTEM_BMI_REF_DESC
}

"""
The globally unique `ID` look up for the row to connect.
"""
input SystemNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `system` to be connected.
  """
  nodeId: ID!
}

"""
The globally unique `ID` look up for the row to delete.
"""
input SystemNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `system` to be deleted.
  """
  nodeId: ID!
}

"""
The globally unique `ID` look up for the row to update.
"""
input SystemOnGuaranteeForGuaranteeSystemBmiRefFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `guarantee` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `guarantee` being updated.
  """
  patch: GuaranteePatch!
}

"""
The fields on `system` to look up the row to update.
"""
input SystemOnGuaranteeForGuaranteeSystemBmiRefFkeyUsingSystemBmiRefKeyUpdate {
  """
  A unique reference for the system known to BMI
  """
  bmiRef: String!

  """
  An object where the defined keys will be set on the `system` being updated.
  """
  patch: updateSystemOnGuaranteeForGuaranteeSystemBmiRefFkeyPatch!
}

"""
The fields on `system` to look up the row to update.
"""
input SystemOnGuaranteeForGuaranteeSystemBmiRefFkeyUsingSystemPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `system` being updated.
  """
  patch: updateSystemOnGuaranteeForGuaranteeSystemBmiRefFkeyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input SystemOnSystemForSystemMarketIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `market` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: MarketPatch!
}

"""
The fields on `system` to look up the row to update.
"""
input SystemOnSystemForSystemMarketIdFkeyUsingSystemBmiRefKeyUpdate {
  """
  A unique reference for the system known to BMI
  """
  bmiRef: String!

  """
  An object where the defined keys will be set on the `system` being updated.
  """
  patch: updateSystemOnSystemForSystemMarketIdFkeyPatch!
}

"""
The fields on `system` to look up the row to update.
"""
input SystemOnSystemForSystemMarketIdFkeyUsingSystemPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `system` being updated.
  """
  patch: updateSystemOnSystemForSystemMarketIdFkeyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input SystemOnSystemMemberForSystemMemberSystemBmiRefFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `systemMember` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `systemMember` being updated.
  """
  patch: SystemMemberPatch!
}

"""
The fields on `system` to look up the row to update.
"""
input SystemOnSystemMemberForSystemMemberSystemBmiRefFkeyUsingSystemBmiRefKeyUpdate {
  """
  A unique reference for the system known to BMI
  """
  bmiRef: String!

  """
  An object where the defined keys will be set on the `system` being updated.
  """
  patch: updateSystemOnSystemMemberForSystemMemberSystemBmiRefFkeyPatch!
}

"""
The fields on `system` to look up the row to update.
"""
input SystemOnSystemMemberForSystemMemberSystemBmiRefFkeyUsingSystemPkeyUpdate {
  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `system` being updated.
  """
  patch: updateSystemOnSystemMemberForSystemMemberSystemBmiRefFkeyPatch!
}

"""
Represents an update to a `System`. Fields that are set will be updated.
"""
input SystemPatch {
  """
  A unique reference for the system known to BMI
  """
  bmiRef: String
  createdAt: Datetime

  """
  A description for the System
  """
  description: String
  guaranteesUsingBmiRef: GuaranteeSystemBmiRefFkeyInverseInput

  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int
  marketToMarketId: SystemMarketIdFkeyInput

  """
  The maximum number of years that this system can be guaranteed for.  Must be greater than 10.
  """
  maximumValidityYears: Int

  """
  Short name for the System
  """
  name: String

  """
  If true this system is available for users to select when applying for a system or solution guarantee
  """
  published: Boolean
  systemMembersUsingBmiRef: SystemMemberSystemBmiRefFkeyInverseInput

  """
  ek
  """
  technology: Technology
  updatedAt: Datetime
}

"""
The fields on `system` to look up the row to connect.
"""
input SystemSystemBmiRefKeyConnect {
  """
  A unique reference for the system known to BMI
  """
  bmiRef: String!
}

"""
The fields on `system` to look up the row to delete.
"""
input SystemSystemBmiRefKeyDelete {
  """
  A unique reference for the system known to BMI
  """
  bmiRef: String!
}

"""
The fields on `system` to look up the row to connect.
"""
input SystemSystemPkeyConnect {
  """
  Primary key
  """
  id: Int!
}

"""
The fields on `system` to look up the row to delete.
"""
input SystemSystemPkeyDelete {
  """
  Primary key
  """
  id: Int!
}

"""
A connection to a list of `System` values.
"""
type SystemsConnection {
  """
  A list of edges which contains the `System` and cursor to aid in pagination.
  """
  edges: [SystemsEdge!]!

  """
  A list of `System` objects.
  """
  nodes: [System!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `System` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `System` edge in the connection.
"""
type SystemsEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `System` at the end of the edge.
  """
  node: System!
}

"""
Methods to use when ordering `System`.
"""
enum SystemsOrderBy {
  BMI_REF_ASC
  BMI_REF_DESC
  ID_ASC
  ID_DESC
  MARKET_ID_ASC
  MARKET_ID_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

enum Technology {
  FLAT
  OTHER
  PITCHED
}

enum Tier {
  T1
  T2
  T3
  T4
  T5
  T6
  T7
}

"""
A benefit received by being part of a tier [See type definition](https://app.contentful.com/spaces/j30snaps0u9c/content_types/tierBenefit)
"""
type TierBenefit implements Entry {
  contentfulMetadata: ContentfulMetadata!
  description(locale: String): TierBenefitDescription
  guaranteeValidityOffsetYears(locale: String): Int
  linkedFrom(allowedLocales: [String]): TierBenefitLinkingCollections
  name(locale: String): String
  shortDescription(locale: String): String
  sys: Sys!
  tier(locale: String): String
}

type TierBenefitCollection {
  items: [TierBenefit]!
  limit: Int!
  skip: Int!
  total: Int!
}

type TierBenefitDescription {
  json: JSON!
  links: TierBenefitDescriptionLinks!
}

type TierBenefitDescriptionAssets {
  block: [Asset]!
  hyperlink: [Asset]!
}

type TierBenefitDescriptionEntries {
  block: [Entry]!
  hyperlink: [Entry]!
  inline: [Entry]!
}

type TierBenefitDescriptionLinks {
  assets: TierBenefitDescriptionAssets!
  entries: TierBenefitDescriptionEntries!
}

input TierBenefitFilter {
  AND: [TierBenefitFilter]
  OR: [TierBenefitFilter]
  contentfulMetadata: ContentfulMetadataFilter
  description_contains: String
  description_exists: Boolean
  description_not_contains: String
  guaranteeValidityOffsetYears: Int
  guaranteeValidityOffsetYears_exists: Boolean
  guaranteeValidityOffsetYears_gt: Int
  guaranteeValidityOffsetYears_gte: Int
  guaranteeValidityOffsetYears_in: [Int]
  guaranteeValidityOffsetYears_lt: Int
  guaranteeValidityOffsetYears_lte: Int
  guaranteeValidityOffsetYears_not: Int
  guaranteeValidityOffsetYears_not_in: [Int]
  name: String
  name_contains: String
  name_exists: Boolean
  name_in: [String]
  name_not: String
  name_not_contains: String
  name_not_in: [String]
  shortDescription: String
  shortDescription_contains: String
  shortDescription_exists: Boolean
  shortDescription_in: [String]
  shortDescription_not: String
  shortDescription_not_contains: String
  shortDescription_not_in: [String]
  sys: SysFilter
  tier: String
  tier_contains: String
  tier_exists: Boolean
  tier_in: [String]
  tier_not: String
  tier_not_contains: String
  tier_not_in: [String]
}

type TierBenefitLinkingCollections {
  entryCollection(
    limit: Int = 100
    locale: String
    preview: Boolean
    skip: Int = 0
  ): EntryCollection
}

enum TierBenefitOrder {
  guaranteeValidityOffsetYears_ASC
  guaranteeValidityOffsetYears_DESC
  name_ASC
  name_DESC
  sys_firstPublishedAt_ASC
  sys_firstPublishedAt_DESC
  sys_id_ASC
  sys_id_DESC
  sys_publishedAt_ASC
  sys_publishedAt_DESC
  sys_publishedVersion_ASC
  sys_publishedVersion_DESC
  tier_ASC
  tier_DESC
}

type Token {
  access_token: String
}

"""
[See type definition](https://app.contentful.com/spaces/j30snaps0u9c/content_types/trainingContent)
"""
type TrainingContent implements Entry {
  contentfulMetadata: ContentfulMetadata!
  description(locale: String): String
  image(locale: String, preview: Boolean): Asset
  linkedFrom(allowedLocales: [String]): TrainingContentLinkingCollections
  live(locale: String): String
  lmsCtaLabel(locale: String): String
  pageHeading(locale: String): String
  pageSubHeading(locale: String): String
  step1Description(locale: String): String
  step1Heading(locale: String): String
  step1SubHeading(locale: String): String
  step2Description(locale: String): String
  step2Heading(locale: String): String
  step2SubHeading(locale: String): String
  step3Description(locale: String): String
  step3Heading(locale: String): String
  step3SubHeading(locale: String): String
  sys: Sys!
}

type TrainingContentCollection {
  items: [TrainingContent]!
  limit: Int!
  skip: Int!
  total: Int!
}

input TrainingContentFilter {
  AND: [TrainingContentFilter]
  OR: [TrainingContentFilter]
  contentfulMetadata: ContentfulMetadataFilter
  description: String
  description_contains: String
  description_exists: Boolean
  description_in: [String]
  description_not: String
  description_not_contains: String
  description_not_in: [String]
  image_exists: Boolean
  live: String
  live_contains: String
  live_exists: Boolean
  live_in: [String]
  live_not: String
  live_not_contains: String
  live_not_in: [String]
  lmsCtaLabel: String
  lmsCtaLabel_contains: String
  lmsCtaLabel_exists: Boolean
  lmsCtaLabel_in: [String]
  lmsCtaLabel_not: String
  lmsCtaLabel_not_contains: String
  lmsCtaLabel_not_in: [String]
  pageHeading: String
  pageHeading_contains: String
  pageHeading_exists: Boolean
  pageHeading_in: [String]
  pageHeading_not: String
  pageHeading_not_contains: String
  pageHeading_not_in: [String]
  pageSubHeading: String
  pageSubHeading_contains: String
  pageSubHeading_exists: Boolean
  pageSubHeading_in: [String]
  pageSubHeading_not: String
  pageSubHeading_not_contains: String
  pageSubHeading_not_in: [String]
  step1Description: String
  step1Description_contains: String
  step1Description_exists: Boolean
  step1Description_in: [String]
  step1Description_not: String
  step1Description_not_contains: String
  step1Description_not_in: [String]
  step1Heading: String
  step1Heading_contains: String
  step1Heading_exists: Boolean
  step1Heading_in: [String]
  step1Heading_not: String
  step1Heading_not_contains: String
  step1Heading_not_in: [String]
  step1SubHeading: String
  step1SubHeading_contains: String
  step1SubHeading_exists: Boolean
  step1SubHeading_in: [String]
  step1SubHeading_not: String
  step1SubHeading_not_contains: String
  step1SubHeading_not_in: [String]
  step2Description: String
  step2Description_contains: String
  step2Description_exists: Boolean
  step2Description_in: [String]
  step2Description_not: String
  step2Description_not_contains: String
  step2Description_not_in: [String]
  step2Heading: String
  step2Heading_contains: String
  step2Heading_exists: Boolean
  step2Heading_in: [String]
  step2Heading_not: String
  step2Heading_not_contains: String
  step2Heading_not_in: [String]
  step2SubHeading: String
  step2SubHeading_contains: String
  step2SubHeading_exists: Boolean
  step2SubHeading_in: [String]
  step2SubHeading_not: String
  step2SubHeading_not_contains: String
  step2SubHeading_not_in: [String]
  step3Description: String
  step3Description_contains: String
  step3Description_exists: Boolean
  step3Description_in: [String]
  step3Description_not: String
  step3Description_not_contains: String
  step3Description_not_in: [String]
  step3Heading: String
  step3Heading_contains: String
  step3Heading_exists: Boolean
  step3Heading_in: [String]
  step3Heading_not: String
  step3Heading_not_contains: String
  step3Heading_not_in: [String]
  step3SubHeading: String
  step3SubHeading_contains: String
  step3SubHeading_exists: Boolean
  step3SubHeading_in: [String]
  step3SubHeading_not: String
  step3SubHeading_not_contains: String
  step3SubHeading_not_in: [String]
  sys: SysFilter
}

type TrainingContentLinkingCollections {
  entryCollection(
    limit: Int = 100
    locale: String
    preview: Boolean
    skip: Int = 0
  ): EntryCollection
}

enum TrainingContentOrder {
  live_ASC
  live_DESC
  lmsCtaLabel_ASC
  lmsCtaLabel_DESC
  pageHeading_ASC
  pageHeading_DESC
  pageSubHeading_ASC
  pageSubHeading_DESC
  step1Heading_ASC
  step1Heading_DESC
  step1SubHeading_ASC
  step1SubHeading_DESC
  step2Heading_ASC
  step2Heading_DESC
  step2SubHeading_ASC
  step2SubHeading_DESC
  step3Heading_ASC
  step3Heading_DESC
  step3SubHeading_ASC
  step3SubHeading_DESC
  sys_firstPublishedAt_ASC
  sys_firstPublishedAt_DESC
  sys_id_ASC
  sys_id_DESC
  sys_publishedAt_ASC
  sys_publishedAt_DESC
  sys_publishedVersion_ASC
  sys_publishedVersion_DESC
}

input TruncateAndInsertCertificationInput {
  certificates: [DoceboCertification]
}

"""
All input for the `updateAccountByDoceboUserId` mutation.
"""
input UpdateAccountByDoceboUserIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  User account in Docebo
  """
  doceboUserId: Int!

  """
  An object where the defined keys will be set on the `Account` being updated.
  """
  patch: AccountPatch!
}

"""
All input for the `updateAccountByEmail` mutation.
"""
input UpdateAccountByEmailInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The email address associated with the account
  """
  email: String!

  """
  An object where the defined keys will be set on the `Account` being updated.
  """
  patch: AccountPatch!
}

"""
All input for the `updateAccountByNodeId` mutation.
"""
input UpdateAccountByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Account` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Account` being updated.
  """
  patch: AccountPatch!
}

"""
All input for the `updateAccount` mutation.
"""
input UpdateAccountInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `Account` being updated.
  """
  patch: AccountPatch!
}

"""
The output of our update `Account` mutation.
"""
type UpdateAccountPayload {
  """
  The `Account` that was updated by this mutation.
  """
  account: Account

  """
  An edge for our `Account`. May be used by Relay 1.
  """
  accountEdge(
    """
    The method to use when ordering `Account`.
    """
    orderBy: [AccountsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AccountsEdge

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Market` that is related to this `Account`.
  """
  market: Market

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `updateAddressByNodeId` mutation.
"""
input UpdateAddressByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Address` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Address` being updated.
  """
  patch: AddressPatch!
}

"""
All input for the `updateAddress` mutation.
"""
input UpdateAddressInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `Address` being updated.
  """
  patch: AddressPatch!
}

"""
The output of our update `Address` mutation.
"""
type UpdateAddressPayload {
  """
  The `Address` that was updated by this mutation.
  """
  address: Address

  """
  An edge for our `Address`. May be used by Relay 1.
  """
  addressEdge(
    """
    The method to use when ordering `Address`.
    """
    orderBy: [AddressesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AddressesEdge

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `updateCertificationByNodeId` mutation.
"""
input UpdateCertificationByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Certification` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Certification` being updated.
  """
  patch: CertificationPatch!
}

"""
All input for the `updateCertification` mutation.
"""
input UpdateCertificationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `Certification` being updated.
  """
  patch: CertificationPatch!
}

"""
The output of our update `Certification` mutation.
"""
type UpdateCertificationPayload {
  """
  The `Certification` that was updated by this mutation.
  """
  certification: Certification

  """
  An edge for our `Certification`. May be used by Relay 1.
  """
  certificationEdge(
    """
    The method to use when ordering `Certification`.
    """
    orderBy: [CertificationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CertificationsEdge

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Account` that is related to this `Certification`.
  """
  doceboUser: Account

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `updateCompanyByMarketIdAndName` mutation.
"""
input UpdateCompanyByMarketIdAndNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  fk
  """
  marketId: Int!

  """
  The registered name of the Company
  """
  name: String!

  """
  An object where the defined keys will be set on the `Company` being updated.
  """
  patch: CompanyPatch!
}

"""
All input for the `updateCompanyByNodeId` mutation.
"""
input UpdateCompanyByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Company` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Company` being updated.
  """
  patch: CompanyPatch!
}

"""
All input for the `updateCompanyByReferenceNumber` mutation.
"""
input UpdateCompanyByReferenceNumberInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Company` being updated.
  """
  patch: CompanyPatch!

  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: Int!
}

"""
All input for the `updateCompanyDocumentByNodeId` mutation.
"""
input UpdateCompanyDocumentByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CompanyDocument` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `CompanyDocument` being updated.
  """
  patch: CompanyDocumentPatch!
}

"""
All input for the `updateCompanyDocument` mutation.
"""
input UpdateCompanyDocumentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `CompanyDocument` being updated.
  """
  patch: CompanyDocumentPatch!
}

"""
The output of our update `CompanyDocument` mutation.
"""
type UpdateCompanyDocumentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Company` that is related to this `CompanyDocument`.
  """
  company: Company

  """
  The `CompanyDocument` that was updated by this mutation.
  """
  companyDocument: CompanyDocument

  """
  An edge for our `CompanyDocument`. May be used by Relay 1.
  """
  companyDocumentEdge(
    """
    The method to use when ordering `CompanyDocument`.
    """
    orderBy: [CompanyDocumentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompanyDocumentsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `updateCompany` mutation.
"""
input UpdateCompanyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `Company` being updated.
  """
  patch: CompanyPatch!
}

"""
All input for the `updateCompanyMemberByMarketIdAndAccountIdAndCompanyId` mutation.
"""
input UpdateCompanyMemberByMarketIdAndAccountIdAndCompanyIdInput {
  """
  fk
  """
  accountId: Int!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  fk
  """
  companyId: Int!

  """
  fk
  """
  marketId: Int!

  """
  An object where the defined keys will be set on the `CompanyMember` being updated.
  """
  patch: CompanyMemberPatch!
}

"""
All input for the `updateCompanyMemberByNodeId` mutation.
"""
input UpdateCompanyMemberByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CompanyMember` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `CompanyMember` being updated.
  """
  patch: CompanyMemberPatch!
}

"""
All input for the `updateCompanyMember` mutation.
"""
input UpdateCompanyMemberInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `CompanyMember` being updated.
  """
  patch: CompanyMemberPatch!
}

"""
The output of our update `CompanyMember` mutation.
"""
type UpdateCompanyMemberPayload {
  """
  Reads a single `Account` that is related to this `CompanyMember`.
  """
  account: Account

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Company` that is related to this `CompanyMember`.
  """
  company: Company

  """
  The `CompanyMember` that was updated by this mutation.
  """
  companyMember: CompanyMember

  """
  An edge for our `CompanyMember`. May be used by Relay 1.
  """
  companyMemberEdge(
    """
    The method to use when ordering `CompanyMember`.
    """
    orderBy: [CompanyMembersOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompanyMembersEdge

  """
  Reads a single `Market` that is related to this `CompanyMember`.
  """
  market: Market

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `updateCompanyOperationByNodeId` mutation.
"""
input UpdateCompanyOperationByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CompanyOperation` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `CompanyOperation` being updated.
  """
  patch: CompanyOperationPatch!
}

"""
All input for the `updateCompanyOperation` mutation.
"""
input UpdateCompanyOperationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `CompanyOperation` being updated.
  """
  patch: CompanyOperationPatch!
}

"""
The output of our update `CompanyOperation` mutation.
"""
type UpdateCompanyOperationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Company` that is related to this `CompanyOperation`.
  """
  companyByCompany: Company

  """
  The `CompanyOperation` that was updated by this mutation.
  """
  companyOperation: CompanyOperation

  """
  An edge for our `CompanyOperation`. May be used by Relay 1.
  """
  companyOperationEdge(
    """
    The method to use when ordering `CompanyOperation`.
    """
    orderBy: [CompanyOperationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompanyOperationsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
The output of our update `Company` mutation.
"""
type UpdateCompanyPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Company` that was updated by this mutation.
  """
  company: Company

  """
  An edge for our `Company`. May be used by Relay 1.
  """
  companyEdge(
    """
    The method to use when ordering `Company`.
    """
    orderBy: [CompaniesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompaniesEdge

  """
  Reads a single `Market` that is related to this `Company`.
  """
  market: Market

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Address` that is related to this `Company`.
  """
  registeredAddress: Address

  """
  Reads a single `Address` that is related to this `Company`.
  """
  tradingAddress: Address
}

"""
All input for the `updateCourseByCourseId` mutation.
"""
input UpdateCourseByCourseIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Docebo CourseId
  """
  courseId: Int!

  """
  An object where the defined keys will be set on the `Course` being updated.
  """
  patch: CoursePatch!
}

"""
All input for the `updateCourseByNodeId` mutation.
"""
input UpdateCourseByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Course` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Course` being updated.
  """
  patch: CoursePatch!
}

"""
All input for the `updateCourseCatalogueByCatalogueIdAndCourseId` mutation.
"""
input UpdateCourseCatalogueByCatalogueIdAndCourseIdInput {
  """
  market
  """
  catalogueId: Int!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  fk
  """
  courseId: Int!

  """
  An object where the defined keys will be set on the `CourseCatalogue` being updated.
  """
  patch: CourseCataloguePatch!
}

"""
All input for the `updateCourseCatalogueByNodeId` mutation.
"""
input UpdateCourseCatalogueByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CourseCatalogue` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `CourseCatalogue` being updated.
  """
  patch: CourseCataloguePatch!
}

"""
All input for the `updateCourseCatalogue` mutation.
"""
input UpdateCourseCatalogueInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `CourseCatalogue` being updated.
  """
  patch: CourseCataloguePatch!
}

"""
The output of our update `CourseCatalogue` mutation.
"""
type UpdateCourseCataloguePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Course` that is related to this `CourseCatalogue`.
  """
  course: Course

  """
  The `CourseCatalogue` that was updated by this mutation.
  """
  courseCatalogue: CourseCatalogue

  """
  An edge for our `CourseCatalogue`. May be used by Relay 1.
  """
  courseCatalogueEdge(
    """
    The method to use when ordering `CourseCatalogue`.
    """
    orderBy: [CourseCataloguesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CourseCataloguesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `updateCourseCatalogueTempByNodeId` mutation.
"""
input UpdateCourseCatalogueTempByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CourseCatalogueTemp` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `CourseCatalogueTemp` being updated.
  """
  patch: CourseCatalogueTempPatch!
}

"""
All input for the `updateCourseCatalogueTemp` mutation.
"""
input UpdateCourseCatalogueTempInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `CourseCatalogueTemp` being updated.
  """
  patch: CourseCatalogueTempPatch!
}

"""
The output of our update `CourseCatalogueTemp` mutation.
"""
type UpdateCourseCatalogueTempPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `CourseCatalogueTemp` that was updated by this mutation.
  """
  courseCatalogueTemp: CourseCatalogueTemp

  """
  An edge for our `CourseCatalogueTemp`. May be used by Relay 1.
  """
  courseCatalogueTempEdge(
    """
    The method to use when ordering `CourseCatalogueTemp`.
    """
    orderBy: [CourseCatalogueTempsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CourseCatalogueTempsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `updateCourseEnrollmentByNodeId` mutation.
"""
input UpdateCourseEnrollmentByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CourseEnrollment` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `CourseEnrollment` being updated.
  """
  patch: CourseEnrollmentPatch!
}

"""
All input for the `updateCourseEnrollmentByUserIdAndCourseId` mutation.
"""
input UpdateCourseEnrollmentByUserIdAndCourseIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  fk
  """
  courseId: Int!

  """
  An object where the defined keys will be set on the `CourseEnrollment` being updated.
  """
  patch: CourseEnrollmentPatch!

  """
  account
  """
  userId: Int!
}

"""
All input for the `updateCourseEnrollment` mutation.
"""
input UpdateCourseEnrollmentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `CourseEnrollment` being updated.
  """
  patch: CourseEnrollmentPatch!
}

"""
The output of our update `CourseEnrollment` mutation.
"""
type UpdateCourseEnrollmentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Course` that is related to this `CourseEnrollment`.
  """
  course: Course

  """
  The `CourseEnrollment` that was updated by this mutation.
  """
  courseEnrollment: CourseEnrollment

  """
  An edge for our `CourseEnrollment`. May be used by Relay 1.
  """
  courseEnrollmentEdge(
    """
    The method to use when ordering `CourseEnrollment`.
    """
    orderBy: [CourseEnrollmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CourseEnrollmentsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `updateCourseEnrollmentTempByNodeId` mutation.
"""
input UpdateCourseEnrollmentTempByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CourseEnrollmentTemp` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `CourseEnrollmentTemp` being updated.
  """
  patch: CourseEnrollmentTempPatch!
}

"""
All input for the `updateCourseEnrollmentTemp` mutation.
"""
input UpdateCourseEnrollmentTempInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `CourseEnrollmentTemp` being updated.
  """
  patch: CourseEnrollmentTempPatch!
}

"""
The output of our update `CourseEnrollmentTemp` mutation.
"""
type UpdateCourseEnrollmentTempPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `CourseEnrollmentTemp` that was updated by this mutation.
  """
  courseEnrollmentTemp: CourseEnrollmentTemp

  """
  An edge for our `CourseEnrollmentTemp`. May be used by Relay 1.
  """
  courseEnrollmentTempEdge(
    """
    The method to use when ordering `CourseEnrollmentTemp`.
    """
    orderBy: [CourseEnrollmentTempsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CourseEnrollmentTempsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `updateCourse` mutation.
"""
input UpdateCourseInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `Course` being updated.
  """
  patch: CoursePatch!
}

"""
The output of our update `Course` mutation.
"""
type UpdateCoursePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Course` that was updated by this mutation.
  """
  course: Course

  """
  An edge for our `Course`. May be used by Relay 1.
  """
  courseEdge(
    """
    The method to use when ordering `Course`.
    """
    orderBy: [CoursesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CoursesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `updateCourseSyncConfigurationByConfigName` mutation.
"""
input UpdateCourseSyncConfigurationByConfigNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  account
  """
  configName: String!

  """
  An object where the defined keys will be set on the `CourseSyncConfiguration` being updated.
  """
  patch: CourseSyncConfigurationPatch!
}

"""
All input for the `updateCourseSyncConfigurationByNodeId` mutation.
"""
input UpdateCourseSyncConfigurationByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CourseSyncConfiguration` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `CourseSyncConfiguration` being updated.
  """
  patch: CourseSyncConfigurationPatch!
}

"""
All input for the `updateCourseSyncConfiguration` mutation.
"""
input UpdateCourseSyncConfigurationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `CourseSyncConfiguration` being updated.
  """
  patch: CourseSyncConfigurationPatch!
}

"""
The output of our update `CourseSyncConfiguration` mutation.
"""
type UpdateCourseSyncConfigurationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `CourseSyncConfiguration` that was updated by this mutation.
  """
  courseSyncConfiguration: CourseSyncConfiguration

  """
  An edge for our `CourseSyncConfiguration`. May be used by Relay 1.
  """
  courseSyncConfigurationEdge(
    """
    The method to use when ordering `CourseSyncConfiguration`.
    """
    orderBy: [CourseSyncConfigurationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CourseSyncConfigurationsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `updateCourseTempByNodeId` mutation.
"""
input UpdateCourseTempByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CourseTemp` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `CourseTemp` being updated.
  """
  patch: CourseTempPatch!
}

"""
All input for the `updateCourseTemp` mutation.
"""
input UpdateCourseTempInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `CourseTemp` being updated.
  """
  patch: CourseTempPatch!
}

"""
The output of our update `CourseTemp` mutation.
"""
type UpdateCourseTempPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `CourseTemp` that was updated by this mutation.
  """
  courseTemp: CourseTemp

  """
  An edge for our `CourseTemp`. May be used by Relay 1.
  """
  courseTempEdge(
    """
    The method to use when ordering `CourseTemp`.
    """
    orderBy: [CourseTempsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CourseTempsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `updateDoceboTierByMarketIdAndTierCode` mutation.
"""
input UpdateDoceboTierByMarketIdAndTierCodeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  marketId: Int!

  """
  An object where the defined keys will be set on the `DoceboTier` being updated.
  """
  patch: DoceboTierPatch!
  tierCode: Tier!
}

"""
All input for the `updateDoceboTierByNodeId` mutation.
"""
input UpdateDoceboTierByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `DoceboTier` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `DoceboTier` being updated.
  """
  patch: DoceboTierPatch!
}

"""
All input for the `updateDoceboTier` mutation.
"""
input UpdateDoceboTierInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!

  """
  An object where the defined keys will be set on the `DoceboTier` being updated.
  """
  patch: DoceboTierPatch!
}

"""
The output of our update `DoceboTier` mutation.
"""
type UpdateDoceboTierPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `DoceboTier` that was updated by this mutation.
  """
  doceboTier: DoceboTier

  """
  An edge for our `DoceboTier`. May be used by Relay 1.
  """
  doceboTierEdge(
    """
    The method to use when ordering `DoceboTier`.
    """
    orderBy: [DoceboTiersOrderBy!] = [PRIMARY_KEY_ASC]
  ): DoceboTiersEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

input UpdateDoceboTiersByMarketInput {
  T1: Int
  T2: Int
  T3: Int
  T4: Int
  T5: Int
  T6: Int
  T7: Int
  marketId: Int
}

type UpdateDoceboTiersByMarketResult {
  docebo_catalogue_id: Int
  id: Int
  market_id: Int
  tier_code: Tier
}

"""
All input for the `updateEvidenceItemByNodeId` mutation.
"""
input UpdateEvidenceItemByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `EvidenceItem` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `EvidenceItem` being updated.
  """
  patch: EvidenceItemPatch!
}

"""
All input for the `updateEvidenceItem` mutation.
"""
input UpdateEvidenceItemInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `EvidenceItem` being updated.
  """
  patch: EvidenceItemPatch!
}

"""
The output of our update `EvidenceItem` mutation.
"""
type UpdateEvidenceItemPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `EvidenceItem` that was updated by this mutation.
  """
  evidenceItem: EvidenceItem

  """
  An edge for our `EvidenceItem`. May be used by Relay 1.
  """
  evidenceItemEdge(
    """
    The method to use when ordering `EvidenceItem`.
    """
    orderBy: [EvidenceItemsOrderBy!] = [PRIMARY_KEY_ASC]
  ): EvidenceItemsEdge

  """
  Reads a single `Guarantee` that is related to this `EvidenceItem`.
  """
  guarantee: Guarantee

  """
  Reads a single `Project` that is related to this `EvidenceItem`.
  """
  project: Project

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Account` that is related to this `EvidenceItem`.
  """
  uploaderAccount: Account
}

"""
All input for the `updateGuaranteeByBmiReferenceId` mutation.
"""
input UpdateGuaranteeByBmiReferenceIdInput {
  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Guarantee` being updated.
  """
  patch: GuaranteePatch!
}

"""
All input for the `updateGuaranteeByNodeId` mutation.
"""
input UpdateGuaranteeByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Guarantee` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Guarantee` being updated.
  """
  patch: GuaranteePatch!
}

"""
All input for the `updateGuarantee` mutation.
"""
input UpdateGuaranteeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  guaranteeEventType: GuaranteeEventType

  """
  Primary key - starts at 6100
  """
  id: Int!

  """
  An object where the defined keys will be set on the `Guarantee` being updated.
  """
  patch: GuaranteePatch!
}

"""
The output of our update `Guarantee` mutation.
"""
type UpdateGuaranteePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Guarantee` that was updated by this mutation.
  """
  guarantee: Guarantee

  """
  An edge for our `Guarantee`. May be used by Relay 1.
  """
  guaranteeEdge(
    """
    The method to use when ordering `Guarantee`.
    """
    orderBy: [GuaranteesOrderBy!] = [PRIMARY_KEY_ASC]
  ): GuaranteesEdge

  """
  Reads a single `Product` that is related to this `Guarantee`.
  """
  productByProductBmiRef: Product

  """
  Reads a single `Project` that is related to this `Guarantee`.
  """
  project: Project

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Account` that is related to this `Guarantee`.
  """
  requestorAccount: Account

  """
  Reads a single `Account` that is related to this `Guarantee`.
  """
  reviewerAccount: Account

  """
  Reads a single `System` that is related to this `Guarantee`.
  """
  systemBySystemBmiRef: System
}

"""
All input for the `updateInvitationByNodeId` mutation.
"""
input UpdateInvitationByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Invitation` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Invitation` being updated.
  """
  patch: InvitationPatch!
}

"""
All input for the `updateInvitation` mutation.
"""
input UpdateInvitationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `Invitation` being updated.
  """
  patch: InvitationPatch!
}

"""
The output of our update `Invitation` mutation.
"""
type UpdateInvitationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Company` that is related to this `Invitation`.
  """
  company: Company

  """
  The `Invitation` that was updated by this mutation.
  """
  invitation: Invitation

  """
  An edge for our `Invitation`. May be used by Relay 1.
  """
  invitationEdge(
    """
    The method to use when ordering `Invitation`.
    """
    orderBy: [InvitationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): InvitationsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Account` that is related to this `Invitation`.
  """
  senderAccount: Account
}

"""
All input for the `updateMarketByDoceboCatalogueId` mutation.
"""
input UpdateMarketByDoceboCatalogueIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The default catalogue for the Market.  All users in the Market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int!

  """
  An object where the defined keys will be set on the `Market` being updated.
  """
  patch: MarketPatch!
}

"""
All input for the `updateMarketByDomain` mutation.
"""
input UpdateMarketByDomainInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  the country code used for example as the subdomain
  """
  domain: String!

  """
  An object where the defined keys will be set on the `Market` being updated.
  """
  patch: MarketPatch!
}

"""
All input for the `updateMarketByNodeId` mutation.
"""
input UpdateMarketByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Market` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Market` being updated.
  """
  patch: MarketPatch!
}

"""
All input for the `updateMarket` mutation.
"""
input UpdateMarketInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `Market` being updated.
  """
  patch: MarketPatch!
}

"""
The output of our update `Market` mutation.
"""
type UpdateMarketPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Market` that was updated by this mutation.
  """
  market: Market

  """
  An edge for our `Market`. May be used by Relay 1.
  """
  marketEdge(
    """
    The method to use when ordering `Market`.
    """
    orderBy: [MarketsOrderBy!] = [PRIMARY_KEY_ASC]
  ): MarketsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `updateNoteByNodeId` mutation.
"""
input UpdateNoteByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Note` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Note` being updated.
  """
  patch: NotePatch!
}

"""
All input for the `updateNote` mutation.
"""
input UpdateNoteInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `Note` being updated.
  """
  patch: NotePatch!
}

"""
The output of our update `Note` mutation.
"""
type UpdateNotePayload {
  """
  Reads a single `Account` that is related to this `Note`.
  """
  author: Account

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Note` that was updated by this mutation.
  """
  note: Note

  """
  An edge for our `Note`. May be used by Relay 1.
  """
  noteEdge(
    """
    The method to use when ordering `Note`.
    """
    orderBy: [NotesOrderBy!] = [PRIMARY_KEY_ASC]
  ): NotesEdge

  """
  Reads a single `Project` that is related to this `Note`.
  """
  project: Project

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `updateNotificationByNodeId` mutation.
"""
input UpdateNotificationByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Notification` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Notification` being updated.
  """
  patch: NotificationPatch!
}

"""
All input for the `updateNotification` mutation.
"""
input UpdateNotificationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `Notification` being updated.
  """
  patch: NotificationPatch!
}

"""
The output of our update `Notification` mutation.
"""
type UpdateNotificationPayload {
  """
  Reads a single `Account` that is related to this `Notification`.
  """
  account: Account

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Notification` that was updated by this mutation.
  """
  notification: Notification

  """
  An edge for our `Notification`. May be used by Relay 1.
  """
  notificationEdge(
    """
    The method to use when ordering `Notification`.
    """
    orderBy: [NotificationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): NotificationsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `updateProductByBmiRef` mutation.
"""
input UpdateProductByBmiRefInput {
  """
  A unique reference for the product known to BMI
  """
  bmiRef: String!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Product` being updated.
  """
  patch: ProductPatch!
}

"""
All input for the `updateProductByNodeId` mutation.
"""
input UpdateProductByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Product` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Product` being updated.
  """
  patch: ProductPatch!
}

"""
All input for the `updateProduct` mutation.
"""
input UpdateProductInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `Product` being updated.
  """
  patch: ProductPatch!
}

"""
The output of our update `Product` mutation.
"""
type UpdateProductPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Market` that is related to this `Product`.
  """
  market: Market

  """
  The `Product` that was updated by this mutation.
  """
  product: Product

  """
  An edge for our `Product`. May be used by Relay 1.
  """
  productEdge(
    """
    The method to use when ordering `Product`.
    """
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProductsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `updateProjectByNodeId` mutation.
"""
input UpdateProjectByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Project` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Project` being updated.
  """
  patch: ProjectPatch!
}

"""
All input for the `updateProject` mutation.
"""
input UpdateProjectInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `Project` being updated.
  """
  patch: ProjectPatch!
}

"""
All input for the `updateProjectMemberByNodeId` mutation.
"""
input UpdateProjectMemberByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ProjectMember` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `ProjectMember` being updated.
  """
  patch: ProjectMemberPatch!
}

"""
All input for the `updateProjectMember` mutation.
"""
input UpdateProjectMemberInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `ProjectMember` being updated.
  """
  patch: ProjectMemberPatch!
}

"""
The output of our update `ProjectMember` mutation.
"""
type UpdateProjectMemberPayload {
  """
  Reads a single `Account` that is related to this `ProjectMember`.
  """
  account: Account

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Project` that is related to this `ProjectMember`.
  """
  project: Project

  """
  The `ProjectMember` that was updated by this mutation.
  """
  projectMember: ProjectMember

  """
  An edge for our `ProjectMember`. May be used by Relay 1.
  """
  projectMemberEdge(
    """
    The method to use when ordering `ProjectMember`.
    """
    orderBy: [ProjectMembersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectMembersEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
The output of our update `Project` mutation.
"""
type UpdateProjectPayload {
  """
  Reads a single `Address` that is related to this `Project`.
  """
  buildingOwnerAddress: Address

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Company` that is related to this `Project`.
  """
  company: Company

  """
  The `Project` that was updated by this mutation.
  """
  project: Project

  """
  An edge for our `Project`. May be used by Relay 1.
  """
  projectEdge(
    """
    The method to use when ordering `Project`.
    """
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Address` that is related to this `Project`.
  """
  siteAddress: Address
}

"""
All input for the `updateSystemByBmiRef` mutation.
"""
input UpdateSystemByBmiRefInput {
  """
  A unique reference for the system known to BMI
  """
  bmiRef: String!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `System` being updated.
  """
  patch: SystemPatch!
}

"""
All input for the `updateSystemByNodeId` mutation.
"""
input UpdateSystemByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `System` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `System` being updated.
  """
  patch: SystemPatch!
}

"""
All input for the `updateSystem` mutation.
"""
input UpdateSystemInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `System` being updated.
  """
  patch: SystemPatch!
}

"""
All input for the `updateSystemMemberByNodeId` mutation.
"""
input UpdateSystemMemberByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `SystemMember` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `SystemMember` being updated.
  """
  patch: SystemMemberPatch!
}

"""
All input for the `updateSystemMemberBySystemBmiRefAndProductBmiRefAndMarketId` mutation.
"""
input UpdateSystemMemberBySystemBmiRefAndProductBmiRefAndMarketIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  fk
  """
  marketId: Int!

  """
  An object where the defined keys will be set on the `SystemMember` being updated.
  """
  patch: SystemMemberPatch!

  """
  fk
  """
  productBmiRef: String!

  """
  fk
  """
  systemBmiRef: String!
}

"""
All input for the `updateSystemMember` mutation.
"""
input UpdateSystemMemberInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!

  """
  An object where the defined keys will be set on the `SystemMember` being updated.
  """
  patch: SystemMemberPatch!
}

"""
The output of our update `SystemMember` mutation.
"""
type UpdateSystemMemberPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Market` that is related to this `SystemMember`.
  """
  market: Market

  """
  Reads a single `Product` that is related to this `SystemMember`.
  """
  productByProductBmiRef: Product

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `System` that is related to this `SystemMember`.
  """
  systemBySystemBmiRef: System

  """
  The `SystemMember` that was updated by this mutation.
  """
  systemMember: SystemMember

  """
  An edge for our `SystemMember`. May be used by Relay 1.
  """
  systemMemberEdge(
    """
    The method to use when ordering `SystemMember`.
    """
    orderBy: [SystemMembersOrderBy!] = [PRIMARY_KEY_ASC]
  ): SystemMembersEdge
}

"""
The output of our update `System` mutation.
"""
type UpdateSystemPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Market` that is related to this `System`.
  """
  market: Market

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  The `System` that was updated by this mutation.
  """
  system: System

  """
  An edge for our `System`. May be used by Relay 1.
  """
  systemEdge(
    """
    The method to use when ordering `System`.
    """
    orderBy: [SystemsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SystemsEdge
}

"""
The `Upload` scalar type represents a file upload.
"""
scalar Upload

input UserCreateInput {
  can_manage_subordinates: Boolean
  date_format: String
  email: String
  email_validation_status: Int
  expiration: String
  firstname: String
  force_change: Int
  language: String
  lastname: String
  level: Int
  password: String
  privacy: String
  role: Int
  select_orgchart: SelectOrgchart
  send_notification_email: Boolean
  timezone: String
  userid: String
  valid: Int
}

type UserCreateResponse {
  success: Boolean
  user_id: Int
}

type UserData {
  email: String
  email_validation_status: String
  expiration: String
  first_name: String
  lang_code: String
  language: String
  last_name: String
  level: String
  role: String
  role_id: String
  role_title: String
  user_id: String
  username: String
  uuid: String
  valid: String
}

input UserUpdateInput {
  can_manage_subordinates: Boolean
  date_format: String
  email: String
  email_validation_status: Int
  expiration: String
  firstname: String
  force_change: Int
  language: String
  lastname: String
  level: Int
  password: String
  privacy: String
  role: Int
  select_orgchart: SelectOrgchart
  send_notification_email: Boolean
  timezone: String
  userid: String
  valid: Int
}

type UserUpdateResponse {
  success: Boolean
  user_id: Int
}

scalar _Any

"""
A union of all federated types (those that use the @key directive).
"""
union _Entity =
    Account
  | Address
  | Certification
  | Company
  | CompanyDocument
  | CompanyMember
  | CompanyOperation
  | Course
  | CourseCatalogue
  | CourseCatalogueTemp
  | CourseEnrollment
  | CourseEnrollmentTemp
  | CourseSyncConfiguration
  | CourseTemp
  | DoceboTier
  | EvidenceItem
  | Guarantee
  | Invitation
  | Market
  | Note
  | Notification
  | Product
  | Project
  | ProjectMember
  | System
  | SystemMember

"""
Used to represent a set of fields. Grammatically, a field set is a
selection set minus the braces.
"""
scalar _FieldSet

"""
Describes our federated service.
"""
type _Service {
  """
  The GraphQL Schema Language definiton of our endpoint including the
  Apollo Federation directives (but not their definitions or the special
  Apollo Federation fields).
  """
  sdl: String @deprecated(reason: "Only Apollo Federation should use this")
}

input cfContentArticleNestedFilter {
  AND: [cfContentArticleNestedFilter]
  OR: [cfContentArticleNestedFilter]
  body_contains: String
  body_exists: Boolean
  body_not_contains: String
  contentfulMetadata: ContentfulMetadataFilter
  relativePath: String
  relativePath_contains: String
  relativePath_exists: Boolean
  relativePath_in: [String]
  relativePath_not: String
  relativePath_not_contains: String
  relativePath_not_in: [String]
  sys: SysFilter
  title: String
  title_contains: String
  title_exists: Boolean
  title_in: [String]
  title_not: String
  title_not_contains: String
  title_not_in: [String]
}

input cfMessageTemplateNestedFilter {
  AND: [cfMessageTemplateNestedFilter]
  OR: [cfMessageTemplateNestedFilter]
  contentfulMetadata: ContentfulMetadataFilter
  emailBody: String
  emailBody_contains: String
  emailBody_exists: Boolean
  emailBody_in: [String]
  emailBody_not: String
  emailBody_not_contains: String
  emailBody_not_in: [String]
  event: String
  event_contains: String
  event_exists: Boolean
  event_in: [String]
  event_not: String
  event_not_contains: String
  event_not_in: [String]
  format_contains_all: [String]
  format_contains_none: [String]
  format_contains_some: [String]
  format_exists: Boolean
  notificationBody: String
  notificationBody_contains: String
  notificationBody_exists: Boolean
  notificationBody_in: [String]
  notificationBody_not: String
  notificationBody_not_contains: String
  notificationBody_not_in: [String]
  subject: String
  subject_contains: String
  subject_exists: Boolean
  subject_in: [String]
  subject_not: String
  subject_not_contains: String
  subject_not_in: [String]
  sys: SysFilter
}

input resetPasswordImportedUsersInput {
  market: String
}

type resetPasswordImportedUsersResult {
  result: String
}

"""
An object where the defined keys will be set on the `account` being updated.
"""
input updateAccountOnAccountForAccountMarketIdFkeyPatch {
  certificationsUsingDoceboUserId: CertificationDoceboUserIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberAccountIdFkeyInverseInput

  """
  When the account was created
  """
  created: Datetime
  createdAt: Datetime

  """
  User account in Docebo
  """
  doceboUserId: Int

  """
  Username in Docebo.  Needed to generate the SSO link
  """
  doceboUsername: String

  """
  The email address associated with the account
  """
  email: String
  evidenceItemsUsingId: EvidenceItemUploaderAccountIdFkeyInverseInput

  """
  First name
  """
  firstName: String
  guaranteesToRequestorAccountIdUsingId: GuaranteeRequestorAccountIdFkeyInverseInput
  guaranteesToReviewerAccountIdUsingId: GuaranteeReviewerAccountIdFkeyInverseInput

  """
  Primary key
  """
  id: Int
  invitationsUsingId: InvitationSenderAccountIdFkeyInverseInput

  """
  Last name
  """
  lastName: String
  marketToMarketId: AccountMarketIdFkeyInput

  """
  Use to know if the user it is been migrated in Auth0 (the reset password mail it is been sent)
  """
  migratedToAuth0: Boolean

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String
  notesUsingId: NoteAuthorIdFkeyInverseInput
  notificationsUsingId: NotificationAccountIdFkeyInverseInput

  """
  A phone number that can optionally be provided, and is useful for Company Admin people to provide
  """
  phone: String

  """
  File reference. A profile picture of the user
  """
  photo: String
  photoUpload: Upload
  projectMembersUsingId: ProjectMemberAccountIdFkeyInverseInput

  """
  ek
  """
  role: Role
  shouldRemovePhoto: Boolean

  """
  ek
  """
  status: AccountStatus
  termsCondition: Boolean
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `account` being updated.
"""
input updateAccountOnCertificationForCertificationDoceboUserIdFkeyPatch {
  certificationsUsingDoceboUserId: CertificationDoceboUserIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberAccountIdFkeyInverseInput

  """
  When the account was created
  """
  created: Datetime
  createdAt: Datetime

  """
  Username in Docebo.  Needed to generate the SSO link
  """
  doceboUsername: String

  """
  The email address associated with the account
  """
  email: String
  evidenceItemsUsingId: EvidenceItemUploaderAccountIdFkeyInverseInput

  """
  First name
  """
  firstName: String
  guaranteesToRequestorAccountIdUsingId: GuaranteeRequestorAccountIdFkeyInverseInput
  guaranteesToReviewerAccountIdUsingId: GuaranteeReviewerAccountIdFkeyInverseInput

  """
  Primary key
  """
  id: Int
  invitationsUsingId: InvitationSenderAccountIdFkeyInverseInput

  """
  Last name
  """
  lastName: String

  """
  fk
  """
  marketId: Int
  marketToMarketId: AccountMarketIdFkeyInput

  """
  Use to know if the user it is been migrated in Auth0 (the reset password mail it is been sent)
  """
  migratedToAuth0: Boolean

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String
  notesUsingId: NoteAuthorIdFkeyInverseInput
  notificationsUsingId: NotificationAccountIdFkeyInverseInput

  """
  A phone number that can optionally be provided, and is useful for Company Admin people to provide
  """
  phone: String

  """
  File reference. A profile picture of the user
  """
  photo: String
  photoUpload: Upload
  projectMembersUsingId: ProjectMemberAccountIdFkeyInverseInput

  """
  ek
  """
  role: Role
  shouldRemovePhoto: Boolean

  """
  ek
  """
  status: AccountStatus
  termsCondition: Boolean
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `account` being updated.
"""
input updateAccountOnCompanyMemberForCompanyMemberAccountIdFkeyPatch {
  certificationsUsingDoceboUserId: CertificationDoceboUserIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberAccountIdFkeyInverseInput

  """
  When the account was created
  """
  created: Datetime
  createdAt: Datetime

  """
  User account in Docebo
  """
  doceboUserId: Int

  """
  Username in Docebo.  Needed to generate the SSO link
  """
  doceboUsername: String

  """
  The email address associated with the account
  """
  email: String
  evidenceItemsUsingId: EvidenceItemUploaderAccountIdFkeyInverseInput

  """
  First name
  """
  firstName: String
  guaranteesToRequestorAccountIdUsingId: GuaranteeRequestorAccountIdFkeyInverseInput
  guaranteesToReviewerAccountIdUsingId: GuaranteeReviewerAccountIdFkeyInverseInput

  """
  Primary key
  """
  id: Int
  invitationsUsingId: InvitationSenderAccountIdFkeyInverseInput

  """
  Last name
  """
  lastName: String

  """
  fk
  """
  marketId: Int
  marketToMarketId: AccountMarketIdFkeyInput

  """
  Use to know if the user it is been migrated in Auth0 (the reset password mail it is been sent)
  """
  migratedToAuth0: Boolean

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String
  notesUsingId: NoteAuthorIdFkeyInverseInput
  notificationsUsingId: NotificationAccountIdFkeyInverseInput

  """
  A phone number that can optionally be provided, and is useful for Company Admin people to provide
  """
  phone: String

  """
  File reference. A profile picture of the user
  """
  photo: String
  photoUpload: Upload
  projectMembersUsingId: ProjectMemberAccountIdFkeyInverseInput

  """
  ek
  """
  role: Role
  shouldRemovePhoto: Boolean

  """
  ek
  """
  status: AccountStatus
  termsCondition: Boolean
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `account` being updated.
"""
input updateAccountOnEvidenceItemForEvidenceItemUploaderAccountIdFkeyPatch {
  certificationsUsingDoceboUserId: CertificationDoceboUserIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberAccountIdFkeyInverseInput

  """
  When the account was created
  """
  created: Datetime
  createdAt: Datetime

  """
  User account in Docebo
  """
  doceboUserId: Int

  """
  Username in Docebo.  Needed to generate the SSO link
  """
  doceboUsername: String

  """
  The email address associated with the account
  """
  email: String
  evidenceItemsUsingId: EvidenceItemUploaderAccountIdFkeyInverseInput

  """
  First name
  """
  firstName: String
  guaranteesToRequestorAccountIdUsingId: GuaranteeRequestorAccountIdFkeyInverseInput
  guaranteesToReviewerAccountIdUsingId: GuaranteeReviewerAccountIdFkeyInverseInput

  """
  Primary key
  """
  id: Int
  invitationsUsingId: InvitationSenderAccountIdFkeyInverseInput

  """
  Last name
  """
  lastName: String

  """
  fk
  """
  marketId: Int
  marketToMarketId: AccountMarketIdFkeyInput

  """
  Use to know if the user it is been migrated in Auth0 (the reset password mail it is been sent)
  """
  migratedToAuth0: Boolean

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String
  notesUsingId: NoteAuthorIdFkeyInverseInput
  notificationsUsingId: NotificationAccountIdFkeyInverseInput

  """
  A phone number that can optionally be provided, and is useful for Company Admin people to provide
  """
  phone: String

  """
  File reference. A profile picture of the user
  """
  photo: String
  photoUpload: Upload
  projectMembersUsingId: ProjectMemberAccountIdFkeyInverseInput

  """
  ek
  """
  role: Role
  shouldRemovePhoto: Boolean

  """
  ek
  """
  status: AccountStatus
  termsCondition: Boolean
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `account` being updated.
"""
input updateAccountOnGuaranteeForGuaranteeRequestorAccountIdFkeyPatch {
  certificationsUsingDoceboUserId: CertificationDoceboUserIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberAccountIdFkeyInverseInput

  """
  When the account was created
  """
  created: Datetime
  createdAt: Datetime

  """
  User account in Docebo
  """
  doceboUserId: Int

  """
  Username in Docebo.  Needed to generate the SSO link
  """
  doceboUsername: String

  """
  The email address associated with the account
  """
  email: String
  evidenceItemsUsingId: EvidenceItemUploaderAccountIdFkeyInverseInput

  """
  First name
  """
  firstName: String
  guaranteesToRequestorAccountIdUsingId: GuaranteeRequestorAccountIdFkeyInverseInput
  guaranteesToReviewerAccountIdUsingId: GuaranteeReviewerAccountIdFkeyInverseInput

  """
  Primary key
  """
  id: Int
  invitationsUsingId: InvitationSenderAccountIdFkeyInverseInput

  """
  Last name
  """
  lastName: String

  """
  fk
  """
  marketId: Int
  marketToMarketId: AccountMarketIdFkeyInput

  """
  Use to know if the user it is been migrated in Auth0 (the reset password mail it is been sent)
  """
  migratedToAuth0: Boolean

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String
  notesUsingId: NoteAuthorIdFkeyInverseInput
  notificationsUsingId: NotificationAccountIdFkeyInverseInput

  """
  A phone number that can optionally be provided, and is useful for Company Admin people to provide
  """
  phone: String

  """
  File reference. A profile picture of the user
  """
  photo: String
  photoUpload: Upload
  projectMembersUsingId: ProjectMemberAccountIdFkeyInverseInput

  """
  ek
  """
  role: Role
  shouldRemovePhoto: Boolean

  """
  ek
  """
  status: AccountStatus
  termsCondition: Boolean
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `account` being updated.
"""
input updateAccountOnGuaranteeForGuaranteeReviewerAccountIdFkeyPatch {
  certificationsUsingDoceboUserId: CertificationDoceboUserIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberAccountIdFkeyInverseInput

  """
  When the account was created
  """
  created: Datetime
  createdAt: Datetime

  """
  User account in Docebo
  """
  doceboUserId: Int

  """
  Username in Docebo.  Needed to generate the SSO link
  """
  doceboUsername: String

  """
  The email address associated with the account
  """
  email: String
  evidenceItemsUsingId: EvidenceItemUploaderAccountIdFkeyInverseInput

  """
  First name
  """
  firstName: String
  guaranteesToRequestorAccountIdUsingId: GuaranteeRequestorAccountIdFkeyInverseInput
  guaranteesToReviewerAccountIdUsingId: GuaranteeReviewerAccountIdFkeyInverseInput

  """
  Primary key
  """
  id: Int
  invitationsUsingId: InvitationSenderAccountIdFkeyInverseInput

  """
  Last name
  """
  lastName: String

  """
  fk
  """
  marketId: Int
  marketToMarketId: AccountMarketIdFkeyInput

  """
  Use to know if the user it is been migrated in Auth0 (the reset password mail it is been sent)
  """
  migratedToAuth0: Boolean

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String
  notesUsingId: NoteAuthorIdFkeyInverseInput
  notificationsUsingId: NotificationAccountIdFkeyInverseInput

  """
  A phone number that can optionally be provided, and is useful for Company Admin people to provide
  """
  phone: String

  """
  File reference. A profile picture of the user
  """
  photo: String
  photoUpload: Upload
  projectMembersUsingId: ProjectMemberAccountIdFkeyInverseInput

  """
  ek
  """
  role: Role
  shouldRemovePhoto: Boolean

  """
  ek
  """
  status: AccountStatus
  termsCondition: Boolean
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `account` being updated.
"""
input updateAccountOnInvitationForInvitationSenderAccountIdFkeyPatch {
  certificationsUsingDoceboUserId: CertificationDoceboUserIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberAccountIdFkeyInverseInput

  """
  When the account was created
  """
  created: Datetime
  createdAt: Datetime

  """
  User account in Docebo
  """
  doceboUserId: Int

  """
  Username in Docebo.  Needed to generate the SSO link
  """
  doceboUsername: String

  """
  The email address associated with the account
  """
  email: String
  evidenceItemsUsingId: EvidenceItemUploaderAccountIdFkeyInverseInput

  """
  First name
  """
  firstName: String
  guaranteesToRequestorAccountIdUsingId: GuaranteeRequestorAccountIdFkeyInverseInput
  guaranteesToReviewerAccountIdUsingId: GuaranteeReviewerAccountIdFkeyInverseInput

  """
  Primary key
  """
  id: Int
  invitationsUsingId: InvitationSenderAccountIdFkeyInverseInput

  """
  Last name
  """
  lastName: String

  """
  fk
  """
  marketId: Int
  marketToMarketId: AccountMarketIdFkeyInput

  """
  Use to know if the user it is been migrated in Auth0 (the reset password mail it is been sent)
  """
  migratedToAuth0: Boolean

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String
  notesUsingId: NoteAuthorIdFkeyInverseInput
  notificationsUsingId: NotificationAccountIdFkeyInverseInput

  """
  A phone number that can optionally be provided, and is useful for Company Admin people to provide
  """
  phone: String

  """
  File reference. A profile picture of the user
  """
  photo: String
  photoUpload: Upload
  projectMembersUsingId: ProjectMemberAccountIdFkeyInverseInput

  """
  ek
  """
  role: Role
  shouldRemovePhoto: Boolean

  """
  ek
  """
  status: AccountStatus
  termsCondition: Boolean
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `account` being updated.
"""
input updateAccountOnNoteForNoteAuthorIdFkeyPatch {
  certificationsUsingDoceboUserId: CertificationDoceboUserIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberAccountIdFkeyInverseInput

  """
  When the account was created
  """
  created: Datetime
  createdAt: Datetime

  """
  User account in Docebo
  """
  doceboUserId: Int

  """
  Username in Docebo.  Needed to generate the SSO link
  """
  doceboUsername: String

  """
  The email address associated with the account
  """
  email: String
  evidenceItemsUsingId: EvidenceItemUploaderAccountIdFkeyInverseInput

  """
  First name
  """
  firstName: String
  guaranteesToRequestorAccountIdUsingId: GuaranteeRequestorAccountIdFkeyInverseInput
  guaranteesToReviewerAccountIdUsingId: GuaranteeReviewerAccountIdFkeyInverseInput

  """
  Primary key
  """
  id: Int
  invitationsUsingId: InvitationSenderAccountIdFkeyInverseInput

  """
  Last name
  """
  lastName: String

  """
  fk
  """
  marketId: Int
  marketToMarketId: AccountMarketIdFkeyInput

  """
  Use to know if the user it is been migrated in Auth0 (the reset password mail it is been sent)
  """
  migratedToAuth0: Boolean

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String
  notesUsingId: NoteAuthorIdFkeyInverseInput
  notificationsUsingId: NotificationAccountIdFkeyInverseInput

  """
  A phone number that can optionally be provided, and is useful for Company Admin people to provide
  """
  phone: String

  """
  File reference. A profile picture of the user
  """
  photo: String
  photoUpload: Upload
  projectMembersUsingId: ProjectMemberAccountIdFkeyInverseInput

  """
  ek
  """
  role: Role
  shouldRemovePhoto: Boolean

  """
  ek
  """
  status: AccountStatus
  termsCondition: Boolean
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `account` being updated.
"""
input updateAccountOnNotificationForNotificationAccountIdFkeyPatch {
  certificationsUsingDoceboUserId: CertificationDoceboUserIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberAccountIdFkeyInverseInput

  """
  When the account was created
  """
  created: Datetime
  createdAt: Datetime

  """
  User account in Docebo
  """
  doceboUserId: Int

  """
  Username in Docebo.  Needed to generate the SSO link
  """
  doceboUsername: String

  """
  The email address associated with the account
  """
  email: String
  evidenceItemsUsingId: EvidenceItemUploaderAccountIdFkeyInverseInput

  """
  First name
  """
  firstName: String
  guaranteesToRequestorAccountIdUsingId: GuaranteeRequestorAccountIdFkeyInverseInput
  guaranteesToReviewerAccountIdUsingId: GuaranteeReviewerAccountIdFkeyInverseInput

  """
  Primary key
  """
  id: Int
  invitationsUsingId: InvitationSenderAccountIdFkeyInverseInput

  """
  Last name
  """
  lastName: String

  """
  fk
  """
  marketId: Int
  marketToMarketId: AccountMarketIdFkeyInput

  """
  Use to know if the user it is been migrated in Auth0 (the reset password mail it is been sent)
  """
  migratedToAuth0: Boolean

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String
  notesUsingId: NoteAuthorIdFkeyInverseInput
  notificationsUsingId: NotificationAccountIdFkeyInverseInput

  """
  A phone number that can optionally be provided, and is useful for Company Admin people to provide
  """
  phone: String

  """
  File reference. A profile picture of the user
  """
  photo: String
  photoUpload: Upload
  projectMembersUsingId: ProjectMemberAccountIdFkeyInverseInput

  """
  ek
  """
  role: Role
  shouldRemovePhoto: Boolean

  """
  ek
  """
  status: AccountStatus
  termsCondition: Boolean
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `account` being updated.
"""
input updateAccountOnProjectMemberForProjectMemberAccountIdFkeyPatch {
  certificationsUsingDoceboUserId: CertificationDoceboUserIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberAccountIdFkeyInverseInput

  """
  When the account was created
  """
  created: Datetime
  createdAt: Datetime

  """
  User account in Docebo
  """
  doceboUserId: Int

  """
  Username in Docebo.  Needed to generate the SSO link
  """
  doceboUsername: String

  """
  The email address associated with the account
  """
  email: String
  evidenceItemsUsingId: EvidenceItemUploaderAccountIdFkeyInverseInput

  """
  First name
  """
  firstName: String
  guaranteesToRequestorAccountIdUsingId: GuaranteeRequestorAccountIdFkeyInverseInput
  guaranteesToReviewerAccountIdUsingId: GuaranteeReviewerAccountIdFkeyInverseInput

  """
  Primary key
  """
  id: Int
  invitationsUsingId: InvitationSenderAccountIdFkeyInverseInput

  """
  Last name
  """
  lastName: String

  """
  fk
  """
  marketId: Int
  marketToMarketId: AccountMarketIdFkeyInput

  """
  Use to know if the user it is been migrated in Auth0 (the reset password mail it is been sent)
  """
  migratedToAuth0: Boolean

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String
  notesUsingId: NoteAuthorIdFkeyInverseInput
  notificationsUsingId: NotificationAccountIdFkeyInverseInput

  """
  A phone number that can optionally be provided, and is useful for Company Admin people to provide
  """
  phone: String

  """
  File reference. A profile picture of the user
  """
  photo: String
  photoUpload: Upload
  projectMembersUsingId: ProjectMemberAccountIdFkeyInverseInput

  """
  ek
  """
  role: Role
  shouldRemovePhoto: Boolean

  """
  ek
  """
  status: AccountStatus
  termsCondition: Boolean
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `address` being updated.
"""
input updateAddressOnCompanyForCompanyRegisteredAddressIdFkeyPatch {
  companiesToRegisteredAddressIdUsingId: CompanyRegisteredAddressIdFkeyInverseInput
  companiesToTradingAddressIdUsingId: CompanyTradingAddressIdFkeyInverseInput

  """
  The coordinates on a map of the world
  """
  coordinates: PointInput

  """
  The country for this address
  """
  country: String
  createdAt: Datetime

  """
  First line of this address
  """
  firstLine: String

  """
  Primary key
  """
  id: Int

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String

  """
  The postcode for this address
  """
  postcode: String
  projectsToBuildingOwnerAddressIdUsingId: ProjectBuildingOwnerAddressIdFkeyInverseInput
  projectsToSiteAddressIdUsingId: ProjectSiteAddressIdFkeyInverseInput

  """
  The region if relevant
  """
  region: String

  """
  Second line of this address
  """
  secondLine: String

  """
  The postal town
  """
  town: String
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `address` being updated.
"""
input updateAddressOnCompanyForCompanyTradingAddressIdFkeyPatch {
  companiesToRegisteredAddressIdUsingId: CompanyRegisteredAddressIdFkeyInverseInput
  companiesToTradingAddressIdUsingId: CompanyTradingAddressIdFkeyInverseInput

  """
  The coordinates on a map of the world
  """
  coordinates: PointInput

  """
  The country for this address
  """
  country: String
  createdAt: Datetime

  """
  First line of this address
  """
  firstLine: String

  """
  Primary key
  """
  id: Int

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String

  """
  The postcode for this address
  """
  postcode: String
  projectsToBuildingOwnerAddressIdUsingId: ProjectBuildingOwnerAddressIdFkeyInverseInput
  projectsToSiteAddressIdUsingId: ProjectSiteAddressIdFkeyInverseInput

  """
  The region if relevant
  """
  region: String

  """
  Second line of this address
  """
  secondLine: String

  """
  The postal town
  """
  town: String
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `address` being updated.
"""
input updateAddressOnProjectForProjectBuildingOwnerAddressIdFkeyPatch {
  companiesToRegisteredAddressIdUsingId: CompanyRegisteredAddressIdFkeyInverseInput
  companiesToTradingAddressIdUsingId: CompanyTradingAddressIdFkeyInverseInput

  """
  The coordinates on a map of the world
  """
  coordinates: PointInput

  """
  The country for this address
  """
  country: String
  createdAt: Datetime

  """
  First line of this address
  """
  firstLine: String

  """
  Primary key
  """
  id: Int

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String

  """
  The postcode for this address
  """
  postcode: String
  projectsToBuildingOwnerAddressIdUsingId: ProjectBuildingOwnerAddressIdFkeyInverseInput
  projectsToSiteAddressIdUsingId: ProjectSiteAddressIdFkeyInverseInput

  """
  The region if relevant
  """
  region: String

  """
  Second line of this address
  """
  secondLine: String

  """
  The postal town
  """
  town: String
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `address` being updated.
"""
input updateAddressOnProjectForProjectSiteAddressIdFkeyPatch {
  companiesToRegisteredAddressIdUsingId: CompanyRegisteredAddressIdFkeyInverseInput
  companiesToTradingAddressIdUsingId: CompanyTradingAddressIdFkeyInverseInput

  """
  The coordinates on a map of the world
  """
  coordinates: PointInput

  """
  The country for this address
  """
  country: String
  createdAt: Datetime

  """
  First line of this address
  """
  firstLine: String

  """
  Primary key
  """
  id: Int

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String

  """
  The postcode for this address
  """
  postcode: String
  projectsToBuildingOwnerAddressIdUsingId: ProjectBuildingOwnerAddressIdFkeyInverseInput
  projectsToSiteAddressIdUsingId: ProjectSiteAddressIdFkeyInverseInput

  """
  The region if relevant
  """
  region: String

  """
  Second line of this address
  """
  secondLine: String

  """
  The postal town
  """
  town: String
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `certification` being updated.
"""
input updateCertificationOnCertificationForCertificationDoceboUserIdFkeyPatch {
  accountToDoceboUserId: CertificationDoceboUserIdFkeyInput
  createdAt: Datetime

  """
  The last day that this certification is valid
  """
  expiryDate: Datetime

  """
  Primary key
  """
  id: Int

  """
  The name of the certification according to Docebo
  """
  name: String

  """
  technology
  """
  technology: String
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `companyDocument` being updated.
"""
input updateCompanyDocumentOnCompanyDocumentForCompanyDocumentCompanyIdFkeyPatch {
  companyToCompanyId: CompanyDocumentCompanyIdFkeyInput
  createdAt: Datetime

  """
  The reference to the document
  """
  document: String

  """
  Primary key
  """
  id: Int
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `companyMember` being updated.
"""
input updateCompanyMemberOnCompanyMemberForCompanyMemberAccountIdFkeyPatch {
  accountToAccountId: CompanyMemberAccountIdFkeyInput

  """
  fk
  """
  companyId: Int
  companyToCompanyId: CompanyMemberCompanyIdFkeyInput
  createdAt: Datetime

  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int
  marketToMarketId: CompanyMemberMarketIdFkeyInput
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `companyMember` being updated.
"""
input updateCompanyMemberOnCompanyMemberForCompanyMemberCompanyIdFkeyPatch {
  """
  fk
  """
  accountId: Int
  accountToAccountId: CompanyMemberAccountIdFkeyInput
  companyToCompanyId: CompanyMemberCompanyIdFkeyInput
  createdAt: Datetime

  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int
  marketToMarketId: CompanyMemberMarketIdFkeyInput
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `companyMember` being updated.
"""
input updateCompanyMemberOnCompanyMemberForCompanyMemberMarketIdFkeyPatch {
  """
  fk
  """
  accountId: Int
  accountToAccountId: CompanyMemberAccountIdFkeyInput

  """
  fk
  """
  companyId: Int
  companyToCompanyId: CompanyMemberCompanyIdFkeyInput
  createdAt: Datetime

  """
  Primary key
  """
  id: Int
  marketToMarketId: CompanyMemberMarketIdFkeyInput
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `company` being updated.
"""
input updateCompanyOnCompanyDocumentForCompanyDocumentCompanyIdFkeyPatch {
  """
  A descirption of the Company intended for Find a Roofer
  """
  aboutUs: String
  addressToRegisteredAddressId: CompanyRegisteredAddressIdFkeyInput
  addressToTradingAddressId: CompanyTradingAddressIdFkeyInput

  """
  ek
  """
  businessType: BusinessType
  companyDocumentsUsingId: CompanyDocumentCompanyIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberCompanyIdFkeyInverseInput
  companyOperationsUsingId: CompanyOperationCompanyFkeyInverseInput
  createdAt: Datetime

  """
  The Company facebook website
  """
  facebook: String

  """
  Primary key
  """
  id: Int
  invitationsUsingId: InvitationCompanyIdFkeyInverseInput

  """
  Their Company LinkedIn page URL
  """
  linkedIn: String

  """
  A reference to the logo image
  """
  logo: String
  logoUpload: Upload

  """
  fk
  """
  marketId: Int
  marketToMarketId: CompanyMarketIdFkeyInput

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String

  """
  The registered name of the Company
  """
  name: String

  """
  the email address to contact the owner
  """
  ownerEmail: String

  """
  the name of the owner of the Company
  """
  ownerFullname: String

  """
  the phone number to contact the owner
  """
  ownerPhone: String

  """
  The Company public phone number
  """
  phone: String
  projectsUsingId: ProjectCompanyIdFkeyInverseInput

  """
  The email address that they can be contacted with by the public assuming they are listed
  """
  publicEmail: String

  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: Int

  """
  fk
  """
  registeredAddressId: Int

  """
  Used for reference when importing data from the legacy system
  """
  registeredAddressMigrationId: String

  """
  the email address of the person who filled out the company registration form
  """
  registeredBy: String

  """
  the date that the Company registration form was submitted
  """
  registeredDate: Datetime
  shouldRemoveLogo: Boolean

  """
  ek
  """
  status: CompanyStatus

  """
  The Tax number in that Market, such as the VAT number
  """
  taxNumber: String

  """
  ek
  """
  tier: Tier

  """
  fk
  """
  tradingAddressId: Int

  """
  Used for reference when importing data from the legacy system
  """
  tradingAddressMigrationId: String
  updatedAt: Datetime

  """
  The Company website URL
  """
  website: String
}

"""
An object where the defined keys will be set on the `company` being updated.
"""
input updateCompanyOnCompanyForCompanyMarketIdFkeyPatch {
  """
  A descirption of the Company intended for Find a Roofer
  """
  aboutUs: String
  addressToRegisteredAddressId: CompanyRegisteredAddressIdFkeyInput
  addressToTradingAddressId: CompanyTradingAddressIdFkeyInput

  """
  ek
  """
  businessType: BusinessType
  companyDocumentsUsingId: CompanyDocumentCompanyIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberCompanyIdFkeyInverseInput
  companyOperationsUsingId: CompanyOperationCompanyFkeyInverseInput
  createdAt: Datetime

  """
  The Company facebook website
  """
  facebook: String

  """
  Primary key
  """
  id: Int
  invitationsUsingId: InvitationCompanyIdFkeyInverseInput

  """
  Their Company LinkedIn page URL
  """
  linkedIn: String

  """
  A reference to the logo image
  """
  logo: String
  logoUpload: Upload
  marketToMarketId: CompanyMarketIdFkeyInput

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String

  """
  The registered name of the Company
  """
  name: String

  """
  the email address to contact the owner
  """
  ownerEmail: String

  """
  the name of the owner of the Company
  """
  ownerFullname: String

  """
  the phone number to contact the owner
  """
  ownerPhone: String

  """
  The Company public phone number
  """
  phone: String
  projectsUsingId: ProjectCompanyIdFkeyInverseInput

  """
  The email address that they can be contacted with by the public assuming they are listed
  """
  publicEmail: String

  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: Int

  """
  fk
  """
  registeredAddressId: Int

  """
  Used for reference when importing data from the legacy system
  """
  registeredAddressMigrationId: String

  """
  the email address of the person who filled out the company registration form
  """
  registeredBy: String

  """
  the date that the Company registration form was submitted
  """
  registeredDate: Datetime
  shouldRemoveLogo: Boolean

  """
  ek
  """
  status: CompanyStatus

  """
  The Tax number in that Market, such as the VAT number
  """
  taxNumber: String

  """
  ek
  """
  tier: Tier

  """
  fk
  """
  tradingAddressId: Int

  """
  Used for reference when importing data from the legacy system
  """
  tradingAddressMigrationId: String
  updatedAt: Datetime

  """
  The Company website URL
  """
  website: String
}

"""
An object where the defined keys will be set on the `company` being updated.
"""
input updateCompanyOnCompanyForCompanyRegisteredAddressIdFkeyPatch {
  """
  A descirption of the Company intended for Find a Roofer
  """
  aboutUs: String
  addressToRegisteredAddressId: CompanyRegisteredAddressIdFkeyInput
  addressToTradingAddressId: CompanyTradingAddressIdFkeyInput

  """
  ek
  """
  businessType: BusinessType
  companyDocumentsUsingId: CompanyDocumentCompanyIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberCompanyIdFkeyInverseInput
  companyOperationsUsingId: CompanyOperationCompanyFkeyInverseInput
  createdAt: Datetime

  """
  The Company facebook website
  """
  facebook: String

  """
  Primary key
  """
  id: Int
  invitationsUsingId: InvitationCompanyIdFkeyInverseInput

  """
  Their Company LinkedIn page URL
  """
  linkedIn: String

  """
  A reference to the logo image
  """
  logo: String
  logoUpload: Upload

  """
  fk
  """
  marketId: Int
  marketToMarketId: CompanyMarketIdFkeyInput

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String

  """
  The registered name of the Company
  """
  name: String

  """
  the email address to contact the owner
  """
  ownerEmail: String

  """
  the name of the owner of the Company
  """
  ownerFullname: String

  """
  the phone number to contact the owner
  """
  ownerPhone: String

  """
  The Company public phone number
  """
  phone: String
  projectsUsingId: ProjectCompanyIdFkeyInverseInput

  """
  The email address that they can be contacted with by the public assuming they are listed
  """
  publicEmail: String

  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: Int

  """
  Used for reference when importing data from the legacy system
  """
  registeredAddressMigrationId: String

  """
  the email address of the person who filled out the company registration form
  """
  registeredBy: String

  """
  the date that the Company registration form was submitted
  """
  registeredDate: Datetime
  shouldRemoveLogo: Boolean

  """
  ek
  """
  status: CompanyStatus

  """
  The Tax number in that Market, such as the VAT number
  """
  taxNumber: String

  """
  ek
  """
  tier: Tier

  """
  fk
  """
  tradingAddressId: Int

  """
  Used for reference when importing data from the legacy system
  """
  tradingAddressMigrationId: String
  updatedAt: Datetime

  """
  The Company website URL
  """
  website: String
}

"""
An object where the defined keys will be set on the `company` being updated.
"""
input updateCompanyOnCompanyForCompanyTradingAddressIdFkeyPatch {
  """
  A descirption of the Company intended for Find a Roofer
  """
  aboutUs: String
  addressToRegisteredAddressId: CompanyRegisteredAddressIdFkeyInput
  addressToTradingAddressId: CompanyTradingAddressIdFkeyInput

  """
  ek
  """
  businessType: BusinessType
  companyDocumentsUsingId: CompanyDocumentCompanyIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberCompanyIdFkeyInverseInput
  companyOperationsUsingId: CompanyOperationCompanyFkeyInverseInput
  createdAt: Datetime

  """
  The Company facebook website
  """
  facebook: String

  """
  Primary key
  """
  id: Int
  invitationsUsingId: InvitationCompanyIdFkeyInverseInput

  """
  Their Company LinkedIn page URL
  """
  linkedIn: String

  """
  A reference to the logo image
  """
  logo: String
  logoUpload: Upload

  """
  fk
  """
  marketId: Int
  marketToMarketId: CompanyMarketIdFkeyInput

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String

  """
  The registered name of the Company
  """
  name: String

  """
  the email address to contact the owner
  """
  ownerEmail: String

  """
  the name of the owner of the Company
  """
  ownerFullname: String

  """
  the phone number to contact the owner
  """
  ownerPhone: String

  """
  The Company public phone number
  """
  phone: String
  projectsUsingId: ProjectCompanyIdFkeyInverseInput

  """
  The email address that they can be contacted with by the public assuming they are listed
  """
  publicEmail: String

  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: Int

  """
  fk
  """
  registeredAddressId: Int

  """
  Used for reference when importing data from the legacy system
  """
  registeredAddressMigrationId: String

  """
  the email address of the person who filled out the company registration form
  """
  registeredBy: String

  """
  the date that the Company registration form was submitted
  """
  registeredDate: Datetime
  shouldRemoveLogo: Boolean

  """
  ek
  """
  status: CompanyStatus

  """
  The Tax number in that Market, such as the VAT number
  """
  taxNumber: String

  """
  ek
  """
  tier: Tier

  """
  Used for reference when importing data from the legacy system
  """
  tradingAddressMigrationId: String
  updatedAt: Datetime

  """
  The Company website URL
  """
  website: String
}

"""
An object where the defined keys will be set on the `company` being updated.
"""
input updateCompanyOnCompanyMemberForCompanyMemberCompanyIdFkeyPatch {
  """
  A descirption of the Company intended for Find a Roofer
  """
  aboutUs: String
  addressToRegisteredAddressId: CompanyRegisteredAddressIdFkeyInput
  addressToTradingAddressId: CompanyTradingAddressIdFkeyInput

  """
  ek
  """
  businessType: BusinessType
  companyDocumentsUsingId: CompanyDocumentCompanyIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberCompanyIdFkeyInverseInput
  companyOperationsUsingId: CompanyOperationCompanyFkeyInverseInput
  createdAt: Datetime

  """
  The Company facebook website
  """
  facebook: String

  """
  Primary key
  """
  id: Int
  invitationsUsingId: InvitationCompanyIdFkeyInverseInput

  """
  Their Company LinkedIn page URL
  """
  linkedIn: String

  """
  A reference to the logo image
  """
  logo: String
  logoUpload: Upload

  """
  fk
  """
  marketId: Int
  marketToMarketId: CompanyMarketIdFkeyInput

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String

  """
  The registered name of the Company
  """
  name: String

  """
  the email address to contact the owner
  """
  ownerEmail: String

  """
  the name of the owner of the Company
  """
  ownerFullname: String

  """
  the phone number to contact the owner
  """
  ownerPhone: String

  """
  The Company public phone number
  """
  phone: String
  projectsUsingId: ProjectCompanyIdFkeyInverseInput

  """
  The email address that they can be contacted with by the public assuming they are listed
  """
  publicEmail: String

  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: Int

  """
  fk
  """
  registeredAddressId: Int

  """
  Used for reference when importing data from the legacy system
  """
  registeredAddressMigrationId: String

  """
  the email address of the person who filled out the company registration form
  """
  registeredBy: String

  """
  the date that the Company registration form was submitted
  """
  registeredDate: Datetime
  shouldRemoveLogo: Boolean

  """
  ek
  """
  status: CompanyStatus

  """
  The Tax number in that Market, such as the VAT number
  """
  taxNumber: String

  """
  ek
  """
  tier: Tier

  """
  fk
  """
  tradingAddressId: Int

  """
  Used for reference when importing data from the legacy system
  """
  tradingAddressMigrationId: String
  updatedAt: Datetime

  """
  The Company website URL
  """
  website: String
}

"""
An object where the defined keys will be set on the `company` being updated.
"""
input updateCompanyOnCompanyOperationForCompanyOperationCompanyFkeyPatch {
  """
  A descirption of the Company intended for Find a Roofer
  """
  aboutUs: String
  addressToRegisteredAddressId: CompanyRegisteredAddressIdFkeyInput
  addressToTradingAddressId: CompanyTradingAddressIdFkeyInput

  """
  ek
  """
  businessType: BusinessType
  companyDocumentsUsingId: CompanyDocumentCompanyIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberCompanyIdFkeyInverseInput
  companyOperationsUsingId: CompanyOperationCompanyFkeyInverseInput
  createdAt: Datetime

  """
  The Company facebook website
  """
  facebook: String

  """
  Primary key
  """
  id: Int
  invitationsUsingId: InvitationCompanyIdFkeyInverseInput

  """
  Their Company LinkedIn page URL
  """
  linkedIn: String

  """
  A reference to the logo image
  """
  logo: String
  logoUpload: Upload

  """
  fk
  """
  marketId: Int
  marketToMarketId: CompanyMarketIdFkeyInput

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String

  """
  The registered name of the Company
  """
  name: String

  """
  the email address to contact the owner
  """
  ownerEmail: String

  """
  the name of the owner of the Company
  """
  ownerFullname: String

  """
  the phone number to contact the owner
  """
  ownerPhone: String

  """
  The Company public phone number
  """
  phone: String
  projectsUsingId: ProjectCompanyIdFkeyInverseInput

  """
  The email address that they can be contacted with by the public assuming they are listed
  """
  publicEmail: String

  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: Int

  """
  fk
  """
  registeredAddressId: Int

  """
  Used for reference when importing data from the legacy system
  """
  registeredAddressMigrationId: String

  """
  the email address of the person who filled out the company registration form
  """
  registeredBy: String

  """
  the date that the Company registration form was submitted
  """
  registeredDate: Datetime
  shouldRemoveLogo: Boolean

  """
  ek
  """
  status: CompanyStatus

  """
  The Tax number in that Market, such as the VAT number
  """
  taxNumber: String

  """
  ek
  """
  tier: Tier

  """
  fk
  """
  tradingAddressId: Int

  """
  Used for reference when importing data from the legacy system
  """
  tradingAddressMigrationId: String
  updatedAt: Datetime

  """
  The Company website URL
  """
  website: String
}

"""
An object where the defined keys will be set on the `company` being updated.
"""
input updateCompanyOnInvitationForInvitationCompanyIdFkeyPatch {
  """
  A descirption of the Company intended for Find a Roofer
  """
  aboutUs: String
  addressToRegisteredAddressId: CompanyRegisteredAddressIdFkeyInput
  addressToTradingAddressId: CompanyTradingAddressIdFkeyInput

  """
  ek
  """
  businessType: BusinessType
  companyDocumentsUsingId: CompanyDocumentCompanyIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberCompanyIdFkeyInverseInput
  companyOperationsUsingId: CompanyOperationCompanyFkeyInverseInput
  createdAt: Datetime

  """
  The Company facebook website
  """
  facebook: String

  """
  Primary key
  """
  id: Int
  invitationsUsingId: InvitationCompanyIdFkeyInverseInput

  """
  Their Company LinkedIn page URL
  """
  linkedIn: String

  """
  A reference to the logo image
  """
  logo: String
  logoUpload: Upload

  """
  fk
  """
  marketId: Int
  marketToMarketId: CompanyMarketIdFkeyInput

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String

  """
  The registered name of the Company
  """
  name: String

  """
  the email address to contact the owner
  """
  ownerEmail: String

  """
  the name of the owner of the Company
  """
  ownerFullname: String

  """
  the phone number to contact the owner
  """
  ownerPhone: String

  """
  The Company public phone number
  """
  phone: String
  projectsUsingId: ProjectCompanyIdFkeyInverseInput

  """
  The email address that they can be contacted with by the public assuming they are listed
  """
  publicEmail: String

  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: Int

  """
  fk
  """
  registeredAddressId: Int

  """
  Used for reference when importing data from the legacy system
  """
  registeredAddressMigrationId: String

  """
  the email address of the person who filled out the company registration form
  """
  registeredBy: String

  """
  the date that the Company registration form was submitted
  """
  registeredDate: Datetime
  shouldRemoveLogo: Boolean

  """
  ek
  """
  status: CompanyStatus

  """
  The Tax number in that Market, such as the VAT number
  """
  taxNumber: String

  """
  ek
  """
  tier: Tier

  """
  fk
  """
  tradingAddressId: Int

  """
  Used for reference when importing data from the legacy system
  """
  tradingAddressMigrationId: String
  updatedAt: Datetime

  """
  The Company website URL
  """
  website: String
}

"""
An object where the defined keys will be set on the `company` being updated.
"""
input updateCompanyOnProjectForProjectCompanyIdFkeyPatch {
  """
  A descirption of the Company intended for Find a Roofer
  """
  aboutUs: String
  addressToRegisteredAddressId: CompanyRegisteredAddressIdFkeyInput
  addressToTradingAddressId: CompanyTradingAddressIdFkeyInput

  """
  ek
  """
  businessType: BusinessType
  companyDocumentsUsingId: CompanyDocumentCompanyIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberCompanyIdFkeyInverseInput
  companyOperationsUsingId: CompanyOperationCompanyFkeyInverseInput
  createdAt: Datetime

  """
  The Company facebook website
  """
  facebook: String

  """
  Primary key
  """
  id: Int
  invitationsUsingId: InvitationCompanyIdFkeyInverseInput

  """
  Their Company LinkedIn page URL
  """
  linkedIn: String

  """
  A reference to the logo image
  """
  logo: String
  logoUpload: Upload

  """
  fk
  """
  marketId: Int
  marketToMarketId: CompanyMarketIdFkeyInput

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String

  """
  The registered name of the Company
  """
  name: String

  """
  the email address to contact the owner
  """
  ownerEmail: String

  """
  the name of the owner of the Company
  """
  ownerFullname: String

  """
  the phone number to contact the owner
  """
  ownerPhone: String

  """
  The Company public phone number
  """
  phone: String
  projectsUsingId: ProjectCompanyIdFkeyInverseInput

  """
  The email address that they can be contacted with by the public assuming they are listed
  """
  publicEmail: String

  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: Int

  """
  fk
  """
  registeredAddressId: Int

  """
  Used for reference when importing data from the legacy system
  """
  registeredAddressMigrationId: String

  """
  the email address of the person who filled out the company registration form
  """
  registeredBy: String

  """
  the date that the Company registration form was submitted
  """
  registeredDate: Datetime
  shouldRemoveLogo: Boolean

  """
  ek
  """
  status: CompanyStatus

  """
  The Tax number in that Market, such as the VAT number
  """
  taxNumber: String

  """
  ek
  """
  tier: Tier

  """
  fk
  """
  tradingAddressId: Int

  """
  Used for reference when importing data from the legacy system
  """
  tradingAddressMigrationId: String
  updatedAt: Datetime

  """
  The Company website URL
  """
  website: String
}

"""
An object where the defined keys will be set on the `companyOperation` being updated.
"""
input updateCompanyOperationOnCompanyOperationForCompanyOperationCompanyFkeyPatch {
  companyToCompany: CompanyOperationCompanyFkeyInput
  createdAt: Datetime

  """
  Primary key
  """
  id: Int

  """
  ek
  """
  operation: Operation
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `evidenceItem` being updated.
"""
input updateEvidenceItemOnEvidenceItemForEvidenceItemGuaranteeIdFkeyPatch {
  accountToUploaderAccountId: EvidenceItemUploaderAccountIdFkeyInput

  """
  File reference or the file itself. Photo of the evidence
  """
  attachment: String
  createdAt: Datetime

  """
  ek
  """
  customEvidenceCategoryKey: CustomEvidenceCategoryKey

  """
  ek
  """
  evidenceCategoryType: EvidenceCategoryType
  guaranteeToGuaranteeId: EvidenceItemGuaranteeIdFkeyInput

  """
  Primary key
  """
  id: Int

  """
  Short name for the item of evidence
  """
  name: String

  """
  fk
  """
  projectId: Int
  projectToProjectId: EvidenceItemProjectIdFkeyInput
  updatedAt: Datetime
  uploaderAccountId: Int
}

"""
An object where the defined keys will be set on the `evidenceItem` being updated.
"""
input updateEvidenceItemOnEvidenceItemForEvidenceItemProjectIdFkeyPatch {
  accountToUploaderAccountId: EvidenceItemUploaderAccountIdFkeyInput

  """
  File reference or the file itself. Photo of the evidence
  """
  attachment: String
  createdAt: Datetime

  """
  ek
  """
  customEvidenceCategoryKey: CustomEvidenceCategoryKey

  """
  ek
  """
  evidenceCategoryType: EvidenceCategoryType

  """
  fk
  """
  guaranteeId: Int
  guaranteeToGuaranteeId: EvidenceItemGuaranteeIdFkeyInput

  """
  Primary key
  """
  id: Int

  """
  Short name for the item of evidence
  """
  name: String
  projectToProjectId: EvidenceItemProjectIdFkeyInput
  updatedAt: Datetime
  uploaderAccountId: Int
}

"""
An object where the defined keys will be set on the `evidenceItem` being updated.
"""
input updateEvidenceItemOnEvidenceItemForEvidenceItemUploaderAccountIdFkeyPatch {
  accountToUploaderAccountId: EvidenceItemUploaderAccountIdFkeyInput

  """
  File reference or the file itself. Photo of the evidence
  """
  attachment: String
  createdAt: Datetime

  """
  ek
  """
  customEvidenceCategoryKey: CustomEvidenceCategoryKey

  """
  ek
  """
  evidenceCategoryType: EvidenceCategoryType

  """
  fk
  """
  guaranteeId: Int
  guaranteeToGuaranteeId: EvidenceItemGuaranteeIdFkeyInput

  """
  Primary key
  """
  id: Int

  """
  Short name for the item of evidence
  """
  name: String

  """
  fk
  """
  projectId: Int
  projectToProjectId: EvidenceItemProjectIdFkeyInput
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `guarantee` being updated.
"""
input updateGuaranteeOnEvidenceItemForEvidenceItemGuaranteeIdFkeyPatch {
  accountToRequestorAccountId: GuaranteeRequestorAccountIdFkeyInput
  accountToReviewerAccountId: GuaranteeReviewerAccountIdFkeyInput

  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String

  """
  ek
  """
  coverage: GuaranteeCoverage
  createdAt: Datetime
  evidenceItemsUsingId: EvidenceItemGuaranteeIdFkeyInverseInput

  """
  When the guarantee will expire.  This should be calculated when the request_status becomes APPROVED. dependent on the StartDate, the Validity of the Product or System and the ValidityOffset in this Tier.
  The date is stored in UTC.
  """
  expiryDate: Datetime

  """
  The pdf file that is emailed out, or a reference to it, or reference to the service that will generate it on demand
  """
  fileStorageId: String

  """
  ek
  """
  guaranteeReferenceCode: GuaranteeReferenceCode

  """
  Primary key - starts at 6100
  """
  id: Int

  """
  ek
  """
  languageCode: Language

  """
  fk
  """
  productBmiRef: String
  productToProductBmiRef: GuaranteeProductBmiRefFkeyInput

  """
  fk
  """
  projectId: Int
  projectToProjectId: GuaranteeProjectIdFkeyInput

  """
  fk
  """
  requestorAccountId: Int

  """
  fk
  """
  reviewerAccountId: Int

  """
  The date that the Guarantee is approved either automatically or manually. The date is stored in UTC.
  """
  startDate: Datetime

  """
  ek
  """
  status: RequestStatus

  """
  fk
  """
  systemBmiRef: String
  systemToSystemBmiRef: GuaranteeSystemBmiRefFkeyInput
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `guarantee` being updated.
"""
input updateGuaranteeOnGuaranteeForGuaranteeProductBmiRefFkeyPatch {
  accountToRequestorAccountId: GuaranteeRequestorAccountIdFkeyInput
  accountToReviewerAccountId: GuaranteeReviewerAccountIdFkeyInput

  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String

  """
  ek
  """
  coverage: GuaranteeCoverage
  createdAt: Datetime
  evidenceItemsUsingId: EvidenceItemGuaranteeIdFkeyInverseInput

  """
  When the guarantee will expire.  This should be calculated when the request_status becomes APPROVED. dependent on the StartDate, the Validity of the Product or System and the ValidityOffset in this Tier.
  The date is stored in UTC.
  """
  expiryDate: Datetime

  """
  The pdf file that is emailed out, or a reference to it, or reference to the service that will generate it on demand
  """
  fileStorageId: String

  """
  ek
  """
  guaranteeReferenceCode: GuaranteeReferenceCode

  """
  Primary key - starts at 6100
  """
  id: Int

  """
  ek
  """
  languageCode: Language
  productToProductBmiRef: GuaranteeProductBmiRefFkeyInput

  """
  fk
  """
  projectId: Int
  projectToProjectId: GuaranteeProjectIdFkeyInput

  """
  fk
  """
  requestorAccountId: Int

  """
  fk
  """
  reviewerAccountId: Int

  """
  The date that the Guarantee is approved either automatically or manually. The date is stored in UTC.
  """
  startDate: Datetime

  """
  ek
  """
  status: RequestStatus

  """
  fk
  """
  systemBmiRef: String
  systemToSystemBmiRef: GuaranteeSystemBmiRefFkeyInput
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `guarantee` being updated.
"""
input updateGuaranteeOnGuaranteeForGuaranteeProjectIdFkeyPatch {
  accountToRequestorAccountId: GuaranteeRequestorAccountIdFkeyInput
  accountToReviewerAccountId: GuaranteeReviewerAccountIdFkeyInput

  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String

  """
  ek
  """
  coverage: GuaranteeCoverage
  createdAt: Datetime
  evidenceItemsUsingId: EvidenceItemGuaranteeIdFkeyInverseInput

  """
  When the guarantee will expire.  This should be calculated when the request_status becomes APPROVED. dependent on the StartDate, the Validity of the Product or System and the ValidityOffset in this Tier.
  The date is stored in UTC.
  """
  expiryDate: Datetime

  """
  The pdf file that is emailed out, or a reference to it, or reference to the service that will generate it on demand
  """
  fileStorageId: String

  """
  ek
  """
  guaranteeReferenceCode: GuaranteeReferenceCode

  """
  Primary key - starts at 6100
  """
  id: Int

  """
  ek
  """
  languageCode: Language

  """
  fk
  """
  productBmiRef: String
  productToProductBmiRef: GuaranteeProductBmiRefFkeyInput
  projectToProjectId: GuaranteeProjectIdFkeyInput

  """
  fk
  """
  requestorAccountId: Int

  """
  fk
  """
  reviewerAccountId: Int

  """
  The date that the Guarantee is approved either automatically or manually. The date is stored in UTC.
  """
  startDate: Datetime

  """
  ek
  """
  status: RequestStatus

  """
  fk
  """
  systemBmiRef: String
  systemToSystemBmiRef: GuaranteeSystemBmiRefFkeyInput
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `guarantee` being updated.
"""
input updateGuaranteeOnGuaranteeForGuaranteeRequestorAccountIdFkeyPatch {
  accountToRequestorAccountId: GuaranteeRequestorAccountIdFkeyInput
  accountToReviewerAccountId: GuaranteeReviewerAccountIdFkeyInput

  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String

  """
  ek
  """
  coverage: GuaranteeCoverage
  createdAt: Datetime
  evidenceItemsUsingId: EvidenceItemGuaranteeIdFkeyInverseInput

  """
  When the guarantee will expire.  This should be calculated when the request_status becomes APPROVED. dependent on the StartDate, the Validity of the Product or System and the ValidityOffset in this Tier.
  The date is stored in UTC.
  """
  expiryDate: Datetime

  """
  The pdf file that is emailed out, or a reference to it, or reference to the service that will generate it on demand
  """
  fileStorageId: String

  """
  ek
  """
  guaranteeReferenceCode: GuaranteeReferenceCode

  """
  Primary key - starts at 6100
  """
  id: Int

  """
  ek
  """
  languageCode: Language

  """
  fk
  """
  productBmiRef: String
  productToProductBmiRef: GuaranteeProductBmiRefFkeyInput

  """
  fk
  """
  projectId: Int
  projectToProjectId: GuaranteeProjectIdFkeyInput

  """
  fk
  """
  reviewerAccountId: Int

  """
  The date that the Guarantee is approved either automatically or manually. The date is stored in UTC.
  """
  startDate: Datetime

  """
  ek
  """
  status: RequestStatus

  """
  fk
  """
  systemBmiRef: String
  systemToSystemBmiRef: GuaranteeSystemBmiRefFkeyInput
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `guarantee` being updated.
"""
input updateGuaranteeOnGuaranteeForGuaranteeReviewerAccountIdFkeyPatch {
  accountToRequestorAccountId: GuaranteeRequestorAccountIdFkeyInput
  accountToReviewerAccountId: GuaranteeReviewerAccountIdFkeyInput

  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String

  """
  ek
  """
  coverage: GuaranteeCoverage
  createdAt: Datetime
  evidenceItemsUsingId: EvidenceItemGuaranteeIdFkeyInverseInput

  """
  When the guarantee will expire.  This should be calculated when the request_status becomes APPROVED. dependent on the StartDate, the Validity of the Product or System and the ValidityOffset in this Tier.
  The date is stored in UTC.
  """
  expiryDate: Datetime

  """
  The pdf file that is emailed out, or a reference to it, or reference to the service that will generate it on demand
  """
  fileStorageId: String

  """
  ek
  """
  guaranteeReferenceCode: GuaranteeReferenceCode

  """
  Primary key - starts at 6100
  """
  id: Int

  """
  ek
  """
  languageCode: Language

  """
  fk
  """
  productBmiRef: String
  productToProductBmiRef: GuaranteeProductBmiRefFkeyInput

  """
  fk
  """
  projectId: Int
  projectToProjectId: GuaranteeProjectIdFkeyInput

  """
  fk
  """
  requestorAccountId: Int

  """
  The date that the Guarantee is approved either automatically or manually. The date is stored in UTC.
  """
  startDate: Datetime

  """
  ek
  """
  status: RequestStatus

  """
  fk
  """
  systemBmiRef: String
  systemToSystemBmiRef: GuaranteeSystemBmiRefFkeyInput
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `guarantee` being updated.
"""
input updateGuaranteeOnGuaranteeForGuaranteeSystemBmiRefFkeyPatch {
  accountToRequestorAccountId: GuaranteeRequestorAccountIdFkeyInput
  accountToReviewerAccountId: GuaranteeReviewerAccountIdFkeyInput

  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String

  """
  ek
  """
  coverage: GuaranteeCoverage
  createdAt: Datetime
  evidenceItemsUsingId: EvidenceItemGuaranteeIdFkeyInverseInput

  """
  When the guarantee will expire.  This should be calculated when the request_status becomes APPROVED. dependent on the StartDate, the Validity of the Product or System and the ValidityOffset in this Tier.
  The date is stored in UTC.
  """
  expiryDate: Datetime

  """
  The pdf file that is emailed out, or a reference to it, or reference to the service that will generate it on demand
  """
  fileStorageId: String

  """
  ek
  """
  guaranteeReferenceCode: GuaranteeReferenceCode

  """
  Primary key - starts at 6100
  """
  id: Int

  """
  ek
  """
  languageCode: Language

  """
  fk
  """
  productBmiRef: String
  productToProductBmiRef: GuaranteeProductBmiRefFkeyInput

  """
  fk
  """
  projectId: Int
  projectToProjectId: GuaranteeProjectIdFkeyInput

  """
  fk
  """
  requestorAccountId: Int

  """
  fk
  """
  reviewerAccountId: Int

  """
  The date that the Guarantee is approved either automatically or manually. The date is stored in UTC.
  """
  startDate: Datetime

  """
  ek
  """
  status: RequestStatus
  systemToSystemBmiRef: GuaranteeSystemBmiRefFkeyInput
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `invitation` being updated.
"""
input updateInvitationOnInvitationForInvitationCompanyIdFkeyPatch {
  accountToSenderAccountId: InvitationSenderAccountIdFkeyInput
  companyToCompanyId: InvitationCompanyIdFkeyInput
  createdAt: Datetime

  """
  Primary key
  """
  id: Int

  """
  An email address
  """
  invitee: String

  """
  An optional note that can be included in the invitation by the sender
  """
  personalNote: String

  """
  fk
  """
  senderAccountId: Int

  """
  ek
  """
  status: InvitationStatus
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `invitation` being updated.
"""
input updateInvitationOnInvitationForInvitationSenderAccountIdFkeyPatch {
  accountToSenderAccountId: InvitationSenderAccountIdFkeyInput

  """
  fk
  """
  companyId: Int
  companyToCompanyId: InvitationCompanyIdFkeyInput
  createdAt: Datetime

  """
  Primary key
  """
  id: Int

  """
  An email address
  """
  invitee: String

  """
  An optional note that can be included in the invitation by the sender
  """
  personalNote: String

  """
  ek
  """
  status: InvitationStatus
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `market` being updated.
"""
input updateMarketOnAccountForAccountMarketIdFkeyPatch {
  accountsUsingId: AccountMarketIdFkeyInverseInput

  """
  The space in Contenful
  """
  cmsSpaceId: String
  companiesUsingId: CompanyMarketIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberMarketIdFkeyInverseInput
  createdAt: Datetime

  """
  The default catalogue for the Market.  All users in the Market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int
  doceboCatalogueIdT2: Int
  doceboCatalogueIdT3: Int
  doceboCatalogueIdT4: Int

  """
  The Docebo branch that new user are inserted into if they register as a Company Admin. Note that this never gets updated by InTouch. Originally there was going to be a distinction between installer branches and admin branches in Docebo, but this is no longer the preferred approach.
  """
  doceboCompanyAdminBranchId: String

  """
  The Docebo branch that new user are inserted into if they register as an installer.  Note that this never gets updated by InTouch.  Originally there was going to be a distinction between installer branches and admin branches in Docebo, but this is no longer the preferred approach.
  """
  doceboInstallersBranchId: String

  """
  the country code used for example as the subdomain
  """
  domain: String

  """
  The coordinates of the middle of the Market on a map
  """
  geoMiddle: PointInput

  """
  Reference to the Google Analytics tracking ID that is used for the Country GA reports
  """
  gtag: String
  gtagMarketMedia: String

  """
  Primary key
  """
  id: Int

  """
  ek
  """
  language: Language

  """
  The length of the radius in km (from the geo_middle lat/lng), for which the Google Places API biases the search results for address autocomplete. Locations outside of the radius will not be excluded.
  """
  locationBiasRadiusKm: Int

  """
  The address of the merchandising site for the market.  CTAs of the MERCHANDISING type will link to this address
  """
  merchandisingUrl: String

  """
  A short name for the market, e.g. Italy, Norway, Netherlands
  """
  name: String
  productsUsingId: ProductMarketIdFkeyInverseInput

  """
  Whether the market supports Projects.  If so then the Projects link should be available in th left hand navigation.
  """
  projectsEnabled: Boolean

  """
  The mailbox on intouch.bmigroup.com that emails will be sent from for this Market
  """
  sendMailbox: String

  """
  The From name used when sending an email
  """
  sendName: String
  systemMembersUsingId: SystemMemberMarketIdFkeyInverseInput
  systemsUsingId: SystemMarketIdFkeyInverseInput
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `market` being updated.
"""
input updateMarketOnCompanyForCompanyMarketIdFkeyPatch {
  accountsUsingId: AccountMarketIdFkeyInverseInput

  """
  The space in Contenful
  """
  cmsSpaceId: String
  companiesUsingId: CompanyMarketIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberMarketIdFkeyInverseInput
  createdAt: Datetime

  """
  The default catalogue for the Market.  All users in the Market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int
  doceboCatalogueIdT2: Int
  doceboCatalogueIdT3: Int
  doceboCatalogueIdT4: Int

  """
  The Docebo branch that new user are inserted into if they register as a Company Admin. Note that this never gets updated by InTouch. Originally there was going to be a distinction between installer branches and admin branches in Docebo, but this is no longer the preferred approach.
  """
  doceboCompanyAdminBranchId: String

  """
  The Docebo branch that new user are inserted into if they register as an installer.  Note that this never gets updated by InTouch.  Originally there was going to be a distinction between installer branches and admin branches in Docebo, but this is no longer the preferred approach.
  """
  doceboInstallersBranchId: String

  """
  the country code used for example as the subdomain
  """
  domain: String

  """
  The coordinates of the middle of the Market on a map
  """
  geoMiddle: PointInput

  """
  Reference to the Google Analytics tracking ID that is used for the Country GA reports
  """
  gtag: String
  gtagMarketMedia: String

  """
  Primary key
  """
  id: Int

  """
  ek
  """
  language: Language

  """
  The length of the radius in km (from the geo_middle lat/lng), for which the Google Places API biases the search results for address autocomplete. Locations outside of the radius will not be excluded.
  """
  locationBiasRadiusKm: Int

  """
  The address of the merchandising site for the market.  CTAs of the MERCHANDISING type will link to this address
  """
  merchandisingUrl: String

  """
  A short name for the market, e.g. Italy, Norway, Netherlands
  """
  name: String
  productsUsingId: ProductMarketIdFkeyInverseInput

  """
  Whether the market supports Projects.  If so then the Projects link should be available in th left hand navigation.
  """
  projectsEnabled: Boolean

  """
  The mailbox on intouch.bmigroup.com that emails will be sent from for this Market
  """
  sendMailbox: String

  """
  The From name used when sending an email
  """
  sendName: String
  systemMembersUsingId: SystemMemberMarketIdFkeyInverseInput
  systemsUsingId: SystemMarketIdFkeyInverseInput
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `market` being updated.
"""
input updateMarketOnCompanyMemberForCompanyMemberMarketIdFkeyPatch {
  accountsUsingId: AccountMarketIdFkeyInverseInput

  """
  The space in Contenful
  """
  cmsSpaceId: String
  companiesUsingId: CompanyMarketIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberMarketIdFkeyInverseInput
  createdAt: Datetime

  """
  The default catalogue for the Market.  All users in the Market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int
  doceboCatalogueIdT2: Int
  doceboCatalogueIdT3: Int
  doceboCatalogueIdT4: Int

  """
  The Docebo branch that new user are inserted into if they register as a Company Admin. Note that this never gets updated by InTouch. Originally there was going to be a distinction between installer branches and admin branches in Docebo, but this is no longer the preferred approach.
  """
  doceboCompanyAdminBranchId: String

  """
  The Docebo branch that new user are inserted into if they register as an installer.  Note that this never gets updated by InTouch.  Originally there was going to be a distinction between installer branches and admin branches in Docebo, but this is no longer the preferred approach.
  """
  doceboInstallersBranchId: String

  """
  the country code used for example as the subdomain
  """
  domain: String

  """
  The coordinates of the middle of the Market on a map
  """
  geoMiddle: PointInput

  """
  Reference to the Google Analytics tracking ID that is used for the Country GA reports
  """
  gtag: String
  gtagMarketMedia: String

  """
  Primary key
  """
  id: Int

  """
  ek
  """
  language: Language

  """
  The length of the radius in km (from the geo_middle lat/lng), for which the Google Places API biases the search results for address autocomplete. Locations outside of the radius will not be excluded.
  """
  locationBiasRadiusKm: Int

  """
  The address of the merchandising site for the market.  CTAs of the MERCHANDISING type will link to this address
  """
  merchandisingUrl: String

  """
  A short name for the market, e.g. Italy, Norway, Netherlands
  """
  name: String
  productsUsingId: ProductMarketIdFkeyInverseInput

  """
  Whether the market supports Projects.  If so then the Projects link should be available in th left hand navigation.
  """
  projectsEnabled: Boolean

  """
  The mailbox on intouch.bmigroup.com that emails will be sent from for this Market
  """
  sendMailbox: String

  """
  The From name used when sending an email
  """
  sendName: String
  systemMembersUsingId: SystemMemberMarketIdFkeyInverseInput
  systemsUsingId: SystemMarketIdFkeyInverseInput
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `market` being updated.
"""
input updateMarketOnProductForProductMarketIdFkeyPatch {
  accountsUsingId: AccountMarketIdFkeyInverseInput

  """
  The space in Contenful
  """
  cmsSpaceId: String
  companiesUsingId: CompanyMarketIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberMarketIdFkeyInverseInput
  createdAt: Datetime

  """
  The default catalogue for the Market.  All users in the Market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int
  doceboCatalogueIdT2: Int
  doceboCatalogueIdT3: Int
  doceboCatalogueIdT4: Int

  """
  The Docebo branch that new user are inserted into if they register as a Company Admin. Note that this never gets updated by InTouch. Originally there was going to be a distinction between installer branches and admin branches in Docebo, but this is no longer the preferred approach.
  """
  doceboCompanyAdminBranchId: String

  """
  The Docebo branch that new user are inserted into if they register as an installer.  Note that this never gets updated by InTouch.  Originally there was going to be a distinction between installer branches and admin branches in Docebo, but this is no longer the preferred approach.
  """
  doceboInstallersBranchId: String

  """
  the country code used for example as the subdomain
  """
  domain: String

  """
  The coordinates of the middle of the Market on a map
  """
  geoMiddle: PointInput

  """
  Reference to the Google Analytics tracking ID that is used for the Country GA reports
  """
  gtag: String
  gtagMarketMedia: String

  """
  Primary key
  """
  id: Int

  """
  ek
  """
  language: Language

  """
  The length of the radius in km (from the geo_middle lat/lng), for which the Google Places API biases the search results for address autocomplete. Locations outside of the radius will not be excluded.
  """
  locationBiasRadiusKm: Int

  """
  The address of the merchandising site for the market.  CTAs of the MERCHANDISING type will link to this address
  """
  merchandisingUrl: String

  """
  A short name for the market, e.g. Italy, Norway, Netherlands
  """
  name: String
  productsUsingId: ProductMarketIdFkeyInverseInput

  """
  Whether the market supports Projects.  If so then the Projects link should be available in th left hand navigation.
  """
  projectsEnabled: Boolean

  """
  The mailbox on intouch.bmigroup.com that emails will be sent from for this Market
  """
  sendMailbox: String

  """
  The From name used when sending an email
  """
  sendName: String
  systemMembersUsingId: SystemMemberMarketIdFkeyInverseInput
  systemsUsingId: SystemMarketIdFkeyInverseInput
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `market` being updated.
"""
input updateMarketOnSystemForSystemMarketIdFkeyPatch {
  accountsUsingId: AccountMarketIdFkeyInverseInput

  """
  The space in Contenful
  """
  cmsSpaceId: String
  companiesUsingId: CompanyMarketIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberMarketIdFkeyInverseInput
  createdAt: Datetime

  """
  The default catalogue for the Market.  All users in the Market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int
  doceboCatalogueIdT2: Int
  doceboCatalogueIdT3: Int
  doceboCatalogueIdT4: Int

  """
  The Docebo branch that new user are inserted into if they register as a Company Admin. Note that this never gets updated by InTouch. Originally there was going to be a distinction between installer branches and admin branches in Docebo, but this is no longer the preferred approach.
  """
  doceboCompanyAdminBranchId: String

  """
  The Docebo branch that new user are inserted into if they register as an installer.  Note that this never gets updated by InTouch.  Originally there was going to be a distinction between installer branches and admin branches in Docebo, but this is no longer the preferred approach.
  """
  doceboInstallersBranchId: String

  """
  the country code used for example as the subdomain
  """
  domain: String

  """
  The coordinates of the middle of the Market on a map
  """
  geoMiddle: PointInput

  """
  Reference to the Google Analytics tracking ID that is used for the Country GA reports
  """
  gtag: String
  gtagMarketMedia: String

  """
  Primary key
  """
  id: Int

  """
  ek
  """
  language: Language

  """
  The length of the radius in km (from the geo_middle lat/lng), for which the Google Places API biases the search results for address autocomplete. Locations outside of the radius will not be excluded.
  """
  locationBiasRadiusKm: Int

  """
  The address of the merchandising site for the market.  CTAs of the MERCHANDISING type will link to this address
  """
  merchandisingUrl: String

  """
  A short name for the market, e.g. Italy, Norway, Netherlands
  """
  name: String
  productsUsingId: ProductMarketIdFkeyInverseInput

  """
  Whether the market supports Projects.  If so then the Projects link should be available in th left hand navigation.
  """
  projectsEnabled: Boolean

  """
  The mailbox on intouch.bmigroup.com that emails will be sent from for this Market
  """
  sendMailbox: String

  """
  The From name used when sending an email
  """
  sendName: String
  systemMembersUsingId: SystemMemberMarketIdFkeyInverseInput
  systemsUsingId: SystemMarketIdFkeyInverseInput
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `market` being updated.
"""
input updateMarketOnSystemMemberForSystemMemberMarketIdFkeyPatch {
  accountsUsingId: AccountMarketIdFkeyInverseInput

  """
  The space in Contenful
  """
  cmsSpaceId: String
  companiesUsingId: CompanyMarketIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberMarketIdFkeyInverseInput
  createdAt: Datetime

  """
  The default catalogue for the Market.  All users in the Market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int
  doceboCatalogueIdT2: Int
  doceboCatalogueIdT3: Int
  doceboCatalogueIdT4: Int

  """
  The Docebo branch that new user are inserted into if they register as a Company Admin. Note that this never gets updated by InTouch. Originally there was going to be a distinction between installer branches and admin branches in Docebo, but this is no longer the preferred approach.
  """
  doceboCompanyAdminBranchId: String

  """
  The Docebo branch that new user are inserted into if they register as an installer.  Note that this never gets updated by InTouch.  Originally there was going to be a distinction between installer branches and admin branches in Docebo, but this is no longer the preferred approach.
  """
  doceboInstallersBranchId: String

  """
  the country code used for example as the subdomain
  """
  domain: String

  """
  The coordinates of the middle of the Market on a map
  """
  geoMiddle: PointInput

  """
  Reference to the Google Analytics tracking ID that is used for the Country GA reports
  """
  gtag: String
  gtagMarketMedia: String

  """
  Primary key
  """
  id: Int

  """
  ek
  """
  language: Language

  """
  The length of the radius in km (from the geo_middle lat/lng), for which the Google Places API biases the search results for address autocomplete. Locations outside of the radius will not be excluded.
  """
  locationBiasRadiusKm: Int

  """
  The address of the merchandising site for the market.  CTAs of the MERCHANDISING type will link to this address
  """
  merchandisingUrl: String

  """
  A short name for the market, e.g. Italy, Norway, Netherlands
  """
  name: String
  productsUsingId: ProductMarketIdFkeyInverseInput

  """
  Whether the market supports Projects.  If so then the Projects link should be available in th left hand navigation.
  """
  projectsEnabled: Boolean

  """
  The mailbox on intouch.bmigroup.com that emails will be sent from for this Market
  """
  sendMailbox: String

  """
  The From name used when sending an email
  """
  sendName: String
  systemMembersUsingId: SystemMemberMarketIdFkeyInverseInput
  systemsUsingId: SystemMarketIdFkeyInverseInput
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `note` being updated.
"""
input updateNoteOnNoteForNoteAuthorIdFkeyPatch {
  accountToAuthorId: NoteAuthorIdFkeyInput

  """
  The body of the Note
  """
  body: String
  createdAt: Datetime

  """
  Primary key
  """
  id: Int

  """
  fk
  """
  projectId: Int
  projectToProjectId: NoteProjectIdFkeyInput
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `note` being updated.
"""
input updateNoteOnNoteForNoteProjectIdFkeyPatch {
  accountToAuthorId: NoteAuthorIdFkeyInput

  """
  fk
  """
  authorId: Int

  """
  The body of the Note
  """
  body: String
  createdAt: Datetime

  """
  Primary key
  """
  id: Int
  projectToProjectId: NoteProjectIdFkeyInput
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `notification` being updated.
"""
input updateNotificationOnNotificationForNotificationAccountIdFkeyPatch {
  accountToAccountId: NotificationAccountIdFkeyInput

  """
  The body of the message
  """
  body: String
  createdAt: Datetime

  """
  Primary key
  """
  id: Int

  """
  Whether the message has been read
  """
  read: Boolean

  """
  The datetime stamp for when the message was sent
  """
  sendDate: Datetime
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `product` being updated.
"""
input updateProductOnGuaranteeForGuaranteeProductBmiRefFkeyPatch {
  """
  A unique reference for the product known to BMI
  """
  bmiRef: String

  """
  The Products brand
  """
  brand: String
  createdAt: Datetime

  """
  A description of the Product
  """
  description: String

  """
  The family of Products this Product is in
  """
  family: String
  guaranteesUsingBmiRef: GuaranteeProductBmiRefFkeyInverseInput

  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int
  marketToMarketId: ProductMarketIdFkeyInput

  """
  The number of years that this product can be guaranteed for
  """
  maximumValidityYears: Int

  """
  Short name for the Product
  """
  name: String

  """
  Whether the Product is avialable for new guarantees
  """
  published: Boolean
  systemMembersUsingBmiRef: SystemMemberProductBmiRefFkeyInverseInput

  """
  ek
  """
  technology: Technology
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `product` being updated.
"""
input updateProductOnProductForProductMarketIdFkeyPatch {
  """
  A unique reference for the product known to BMI
  """
  bmiRef: String

  """
  The Products brand
  """
  brand: String
  createdAt: Datetime

  """
  A description of the Product
  """
  description: String

  """
  The family of Products this Product is in
  """
  family: String
  guaranteesUsingBmiRef: GuaranteeProductBmiRefFkeyInverseInput

  """
  Primary key
  """
  id: Int
  marketToMarketId: ProductMarketIdFkeyInput

  """
  The number of years that this product can be guaranteed for
  """
  maximumValidityYears: Int

  """
  Short name for the Product
  """
  name: String

  """
  Whether the Product is avialable for new guarantees
  """
  published: Boolean
  systemMembersUsingBmiRef: SystemMemberProductBmiRefFkeyInverseInput

  """
  ek
  """
  technology: Technology
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `product` being updated.
"""
input updateProductOnSystemMemberForSystemMemberProductBmiRefFkeyPatch {
  """
  A unique reference for the product known to BMI
  """
  bmiRef: String

  """
  The Products brand
  """
  brand: String
  createdAt: Datetime

  """
  A description of the Product
  """
  description: String

  """
  The family of Products this Product is in
  """
  family: String
  guaranteesUsingBmiRef: GuaranteeProductBmiRefFkeyInverseInput

  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int
  marketToMarketId: ProductMarketIdFkeyInput

  """
  The number of years that this product can be guaranteed for
  """
  maximumValidityYears: Int

  """
  Short name for the Product
  """
  name: String

  """
  Whether the Product is avialable for new guarantees
  """
  published: Boolean
  systemMembersUsingBmiRef: SystemMemberProductBmiRefFkeyInverseInput

  """
  ek
  """
  technology: Technology
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `projectMember` being updated.
"""
input updateProjectMemberOnProjectMemberForProjectMemberAccountIdFkeyPatch {
  accountToAccountId: ProjectMemberAccountIdFkeyInput
  createdAt: Datetime

  """
  Primary key
  """
  id: Int

  """
  The responsible installer
  """
  isResponsibleInstaller: Boolean

  """
  fk
  """
  projectId: Int
  projectToProjectId: ProjectMemberProjectIdFkeyInput
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `projectMember` being updated.
"""
input updateProjectMemberOnProjectMemberForProjectMemberProjectIdFkeyPatch {
  """
  fk
  """
  accountId: Int
  accountToAccountId: ProjectMemberAccountIdFkeyInput
  createdAt: Datetime

  """
  Primary key
  """
  id: Int

  """
  The responsible installer
  """
  isResponsibleInstaller: Boolean
  projectToProjectId: ProjectMemberProjectIdFkeyInput
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `project` being updated.
"""
input updateProjectOnEvidenceItemForEvidenceItemProjectIdFkeyPatch {
  addressToBuildingOwnerAddressId: ProjectBuildingOwnerAddressIdFkeyInput
  addressToSiteAddressId: ProjectSiteAddressIdFkeyInput

  """
  fk
  """
  buildingOwnerAddressId: Int

  """
  Name of the Building Owner company if there is such a thing.  Not the same as an InTouch Company.
  """
  buildingOwnerCompany: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerFirstname: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerLastname: String

  """
  Email address of the person who owns the building that the roof is going on.  Not mandatory for a Project, but mandatory when the Company applies for a Guarantee related to the project.
  """
  buildingOwnerMail: String

  """
  fk
  """
  companyId: Int
  companyToCompanyId: ProjectCompanyIdFkeyInput
  createdAt: Datetime

  """
  Short description of what the Project is about.  Sometimes useful to clarify some points to BMI
  """
  description: String

  """
  The date that the Project officially expects to end or ended
  """
  endDate: Datetime
  evidenceItemsUsingId: EvidenceItemProjectIdFkeyInverseInput
  guaranteesUsingId: GuaranteeProjectIdFkeyInverseInput

  """
  If this is true then the Project should be hidden from End Users
  """
  hidden: Boolean

  """
  Primary key
  """
  id: Int
  migrationId: String

  """
  Short name for the Project
  """
  name: String
  notesUsingId: NoteProjectIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberProjectIdFkeyInverseInput

  """
  The number of square meters of roof that this project covers
  """
  roofArea: Int

  """
  fk
  """
  siteAddressId: Int

  """
  The date that the Project officially starts or started
  """
  startDate: Datetime

  """
  ek
  """
  technology: Technology
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `project` being updated.
"""
input updateProjectOnGuaranteeForGuaranteeProjectIdFkeyPatch {
  addressToBuildingOwnerAddressId: ProjectBuildingOwnerAddressIdFkeyInput
  addressToSiteAddressId: ProjectSiteAddressIdFkeyInput

  """
  fk
  """
  buildingOwnerAddressId: Int

  """
  Name of the Building Owner company if there is such a thing.  Not the same as an InTouch Company.
  """
  buildingOwnerCompany: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerFirstname: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerLastname: String

  """
  Email address of the person who owns the building that the roof is going on.  Not mandatory for a Project, but mandatory when the Company applies for a Guarantee related to the project.
  """
  buildingOwnerMail: String

  """
  fk
  """
  companyId: Int
  companyToCompanyId: ProjectCompanyIdFkeyInput
  createdAt: Datetime

  """
  Short description of what the Project is about.  Sometimes useful to clarify some points to BMI
  """
  description: String

  """
  The date that the Project officially expects to end or ended
  """
  endDate: Datetime
  evidenceItemsUsingId: EvidenceItemProjectIdFkeyInverseInput
  guaranteesUsingId: GuaranteeProjectIdFkeyInverseInput

  """
  If this is true then the Project should be hidden from End Users
  """
  hidden: Boolean

  """
  Primary key
  """
  id: Int
  migrationId: String

  """
  Short name for the Project
  """
  name: String
  notesUsingId: NoteProjectIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberProjectIdFkeyInverseInput

  """
  The number of square meters of roof that this project covers
  """
  roofArea: Int

  """
  fk
  """
  siteAddressId: Int

  """
  The date that the Project officially starts or started
  """
  startDate: Datetime

  """
  ek
  """
  technology: Technology
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `project` being updated.
"""
input updateProjectOnNoteForNoteProjectIdFkeyPatch {
  addressToBuildingOwnerAddressId: ProjectBuildingOwnerAddressIdFkeyInput
  addressToSiteAddressId: ProjectSiteAddressIdFkeyInput

  """
  fk
  """
  buildingOwnerAddressId: Int

  """
  Name of the Building Owner company if there is such a thing.  Not the same as an InTouch Company.
  """
  buildingOwnerCompany: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerFirstname: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerLastname: String

  """
  Email address of the person who owns the building that the roof is going on.  Not mandatory for a Project, but mandatory when the Company applies for a Guarantee related to the project.
  """
  buildingOwnerMail: String

  """
  fk
  """
  companyId: Int
  companyToCompanyId: ProjectCompanyIdFkeyInput
  createdAt: Datetime

  """
  Short description of what the Project is about.  Sometimes useful to clarify some points to BMI
  """
  description: String

  """
  The date that the Project officially expects to end or ended
  """
  endDate: Datetime
  evidenceItemsUsingId: EvidenceItemProjectIdFkeyInverseInput
  guaranteesUsingId: GuaranteeProjectIdFkeyInverseInput

  """
  If this is true then the Project should be hidden from End Users
  """
  hidden: Boolean

  """
  Primary key
  """
  id: Int
  migrationId: String

  """
  Short name for the Project
  """
  name: String
  notesUsingId: NoteProjectIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberProjectIdFkeyInverseInput

  """
  The number of square meters of roof that this project covers
  """
  roofArea: Int

  """
  fk
  """
  siteAddressId: Int

  """
  The date that the Project officially starts or started
  """
  startDate: Datetime

  """
  ek
  """
  technology: Technology
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `project` being updated.
"""
input updateProjectOnProjectForProjectBuildingOwnerAddressIdFkeyPatch {
  addressToBuildingOwnerAddressId: ProjectBuildingOwnerAddressIdFkeyInput
  addressToSiteAddressId: ProjectSiteAddressIdFkeyInput

  """
  Name of the Building Owner company if there is such a thing.  Not the same as an InTouch Company.
  """
  buildingOwnerCompany: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerFirstname: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerLastname: String

  """
  Email address of the person who owns the building that the roof is going on.  Not mandatory for a Project, but mandatory when the Company applies for a Guarantee related to the project.
  """
  buildingOwnerMail: String

  """
  fk
  """
  companyId: Int
  companyToCompanyId: ProjectCompanyIdFkeyInput
  createdAt: Datetime

  """
  Short description of what the Project is about.  Sometimes useful to clarify some points to BMI
  """
  description: String

  """
  The date that the Project officially expects to end or ended
  """
  endDate: Datetime
  evidenceItemsUsingId: EvidenceItemProjectIdFkeyInverseInput
  guaranteesUsingId: GuaranteeProjectIdFkeyInverseInput

  """
  If this is true then the Project should be hidden from End Users
  """
  hidden: Boolean

  """
  Primary key
  """
  id: Int
  migrationId: String

  """
  Short name for the Project
  """
  name: String
  notesUsingId: NoteProjectIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberProjectIdFkeyInverseInput

  """
  The number of square meters of roof that this project covers
  """
  roofArea: Int

  """
  fk
  """
  siteAddressId: Int

  """
  The date that the Project officially starts or started
  """
  startDate: Datetime

  """
  ek
  """
  technology: Technology
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `project` being updated.
"""
input updateProjectOnProjectForProjectCompanyIdFkeyPatch {
  addressToBuildingOwnerAddressId: ProjectBuildingOwnerAddressIdFkeyInput
  addressToSiteAddressId: ProjectSiteAddressIdFkeyInput

  """
  fk
  """
  buildingOwnerAddressId: Int

  """
  Name of the Building Owner company if there is such a thing.  Not the same as an InTouch Company.
  """
  buildingOwnerCompany: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerFirstname: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerLastname: String

  """
  Email address of the person who owns the building that the roof is going on.  Not mandatory for a Project, but mandatory when the Company applies for a Guarantee related to the project.
  """
  buildingOwnerMail: String
  companyToCompanyId: ProjectCompanyIdFkeyInput
  createdAt: Datetime

  """
  Short description of what the Project is about.  Sometimes useful to clarify some points to BMI
  """
  description: String

  """
  The date that the Project officially expects to end or ended
  """
  endDate: Datetime
  evidenceItemsUsingId: EvidenceItemProjectIdFkeyInverseInput
  guaranteesUsingId: GuaranteeProjectIdFkeyInverseInput

  """
  If this is true then the Project should be hidden from End Users
  """
  hidden: Boolean

  """
  Primary key
  """
  id: Int
  migrationId: String

  """
  Short name for the Project
  """
  name: String
  notesUsingId: NoteProjectIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberProjectIdFkeyInverseInput

  """
  The number of square meters of roof that this project covers
  """
  roofArea: Int

  """
  fk
  """
  siteAddressId: Int

  """
  The date that the Project officially starts or started
  """
  startDate: Datetime

  """
  ek
  """
  technology: Technology
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `project` being updated.
"""
input updateProjectOnProjectForProjectSiteAddressIdFkeyPatch {
  addressToBuildingOwnerAddressId: ProjectBuildingOwnerAddressIdFkeyInput
  addressToSiteAddressId: ProjectSiteAddressIdFkeyInput

  """
  fk
  """
  buildingOwnerAddressId: Int

  """
  Name of the Building Owner company if there is such a thing.  Not the same as an InTouch Company.
  """
  buildingOwnerCompany: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerFirstname: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerLastname: String

  """
  Email address of the person who owns the building that the roof is going on.  Not mandatory for a Project, but mandatory when the Company applies for a Guarantee related to the project.
  """
  buildingOwnerMail: String

  """
  fk
  """
  companyId: Int
  companyToCompanyId: ProjectCompanyIdFkeyInput
  createdAt: Datetime

  """
  Short description of what the Project is about.  Sometimes useful to clarify some points to BMI
  """
  description: String

  """
  The date that the Project officially expects to end or ended
  """
  endDate: Datetime
  evidenceItemsUsingId: EvidenceItemProjectIdFkeyInverseInput
  guaranteesUsingId: GuaranteeProjectIdFkeyInverseInput

  """
  If this is true then the Project should be hidden from End Users
  """
  hidden: Boolean

  """
  Primary key
  """
  id: Int
  migrationId: String

  """
  Short name for the Project
  """
  name: String
  notesUsingId: NoteProjectIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberProjectIdFkeyInverseInput

  """
  The number of square meters of roof that this project covers
  """
  roofArea: Int

  """
  The date that the Project officially starts or started
  """
  startDate: Datetime

  """
  ek
  """
  technology: Technology
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `project` being updated.
"""
input updateProjectOnProjectMemberForProjectMemberProjectIdFkeyPatch {
  addressToBuildingOwnerAddressId: ProjectBuildingOwnerAddressIdFkeyInput
  addressToSiteAddressId: ProjectSiteAddressIdFkeyInput

  """
  fk
  """
  buildingOwnerAddressId: Int

  """
  Name of the Building Owner company if there is such a thing.  Not the same as an InTouch Company.
  """
  buildingOwnerCompany: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerFirstname: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerLastname: String

  """
  Email address of the person who owns the building that the roof is going on.  Not mandatory for a Project, but mandatory when the Company applies for a Guarantee related to the project.
  """
  buildingOwnerMail: String

  """
  fk
  """
  companyId: Int
  companyToCompanyId: ProjectCompanyIdFkeyInput
  createdAt: Datetime

  """
  Short description of what the Project is about.  Sometimes useful to clarify some points to BMI
  """
  description: String

  """
  The date that the Project officially expects to end or ended
  """
  endDate: Datetime
  evidenceItemsUsingId: EvidenceItemProjectIdFkeyInverseInput
  guaranteesUsingId: GuaranteeProjectIdFkeyInverseInput

  """
  If this is true then the Project should be hidden from End Users
  """
  hidden: Boolean

  """
  Primary key
  """
  id: Int
  migrationId: String

  """
  Short name for the Project
  """
  name: String
  notesUsingId: NoteProjectIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberProjectIdFkeyInverseInput

  """
  The number of square meters of roof that this project covers
  """
  roofArea: Int

  """
  fk
  """
  siteAddressId: Int

  """
  The date that the Project officially starts or started
  """
  startDate: Datetime

  """
  ek
  """
  technology: Technology
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `systemMember` being updated.
"""
input updateSystemMemberOnSystemMemberForSystemMemberMarketIdFkeyPatch {
  createdAt: Datetime

  """
  Primary key
  """
  id: Int
  marketToMarketId: SystemMemberMarketIdFkeyInput

  """
  fk
  """
  productBmiRef: String
  productToProductBmiRef: SystemMemberProductBmiRefFkeyInput

  """
  fk
  """
  systemBmiRef: String
  systemToSystemBmiRef: SystemMemberSystemBmiRefFkeyInput
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `systemMember` being updated.
"""
input updateSystemMemberOnSystemMemberForSystemMemberProductBmiRefFkeyPatch {
  createdAt: Datetime

  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int
  marketToMarketId: SystemMemberMarketIdFkeyInput
  productToProductBmiRef: SystemMemberProductBmiRefFkeyInput

  """
  fk
  """
  systemBmiRef: String
  systemToSystemBmiRef: SystemMemberSystemBmiRefFkeyInput
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `systemMember` being updated.
"""
input updateSystemMemberOnSystemMemberForSystemMemberSystemBmiRefFkeyPatch {
  createdAt: Datetime

  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int
  marketToMarketId: SystemMemberMarketIdFkeyInput

  """
  fk
  """
  productBmiRef: String
  productToProductBmiRef: SystemMemberProductBmiRefFkeyInput
  systemToSystemBmiRef: SystemMemberSystemBmiRefFkeyInput
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `system` being updated.
"""
input updateSystemOnGuaranteeForGuaranteeSystemBmiRefFkeyPatch {
  """
  A unique reference for the system known to BMI
  """
  bmiRef: String
  createdAt: Datetime

  """
  A description for the System
  """
  description: String
  guaranteesUsingBmiRef: GuaranteeSystemBmiRefFkeyInverseInput

  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int
  marketToMarketId: SystemMarketIdFkeyInput

  """
  The maximum number of years that this system can be guaranteed for.  Must be greater than 10.
  """
  maximumValidityYears: Int

  """
  Short name for the System
  """
  name: String

  """
  If true this system is available for users to select when applying for a system or solution guarantee
  """
  published: Boolean
  systemMembersUsingBmiRef: SystemMemberSystemBmiRefFkeyInverseInput

  """
  ek
  """
  technology: Technology
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `system` being updated.
"""
input updateSystemOnSystemForSystemMarketIdFkeyPatch {
  """
  A unique reference for the system known to BMI
  """
  bmiRef: String
  createdAt: Datetime

  """
  A description for the System
  """
  description: String
  guaranteesUsingBmiRef: GuaranteeSystemBmiRefFkeyInverseInput

  """
  Primary key
  """
  id: Int
  marketToMarketId: SystemMarketIdFkeyInput

  """
  The maximum number of years that this system can be guaranteed for.  Must be greater than 10.
  """
  maximumValidityYears: Int

  """
  Short name for the System
  """
  name: String

  """
  If true this system is available for users to select when applying for a system or solution guarantee
  """
  published: Boolean
  systemMembersUsingBmiRef: SystemMemberSystemBmiRefFkeyInverseInput

  """
  ek
  """
  technology: Technology
  updatedAt: Datetime
}

"""
An object where the defined keys will be set on the `system` being updated.
"""
input updateSystemOnSystemMemberForSystemMemberSystemBmiRefFkeyPatch {
  """
  A unique reference for the system known to BMI
  """
  bmiRef: String
  createdAt: Datetime

  """
  A description for the System
  """
  description: String
  guaranteesUsingBmiRef: GuaranteeSystemBmiRefFkeyInverseInput

  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int
  marketToMarketId: SystemMarketIdFkeyInput

  """
  The maximum number of years that this system can be guaranteed for.  Must be greater than 10.
  """
  maximumValidityYears: Int

  """
  Short name for the System
  """
  name: String

  """
  If true this system is available for users to select when applying for a system or solution guarantee
  """
  published: Boolean
  systemMembersUsingBmiRef: SystemMemberSystemBmiRefFkeyInverseInput

  """
  ek
  """
  technology: Technology
  updatedAt: Datetime
}
