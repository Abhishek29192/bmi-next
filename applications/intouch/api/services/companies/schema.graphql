directive @external on FIELD_DEFINITION

directive @requires(fields: _FieldSet!) on FIELD_DEFINITION

directive @provides(fields: _FieldSet!) on FIELD_DEFINITION

directive @key(fields: _FieldSet!) on OBJECT | INTERFACE

"""
The root query type which gives access points into the data universe.
"""
type Query implements Node {
  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form.
  """
  query: Query!

  """
  The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  """
  nodeId: ID!

  """
  Fetches an object given its globally unique `ID`.
  """
  node(
    """
    The globally unique `ID`.
    """
    nodeId: ID!
  ): Node

  """
  Reads and enables pagination through a set of `Account`.
  """
  accounts(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `Account`.
    """
    orderBy: [AccountsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AccountCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AccountFilter
  ): AccountsConnection

  """
  Reads and enables pagination through a set of `Address`.
  """
  addresses(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `Address`.
    """
    orderBy: [AddressesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AddressCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AddressFilter
  ): AddressesConnection

  """
  Reads and enables pagination through a set of `Certification`.
  """
  certifications(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `Certification`.
    """
    orderBy: [CertificationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CertificationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CertificationFilter
  ): CertificationsConnection

  """
  Reads and enables pagination through a set of `Company`.
  """
  companies(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `Company`.
    """
    orderBy: [CompaniesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CompanyCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CompanyFilter
  ): CompaniesConnection

  """
  Reads and enables pagination through a set of `CompanyDocument`.
  """
  companyDocuments(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `CompanyDocument`.
    """
    orderBy: [CompanyDocumentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CompanyDocumentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CompanyDocumentFilter
  ): CompanyDocumentsConnection

  """
  Reads and enables pagination through a set of `CompanyMember`.
  """
  companyMembers(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `CompanyMember`.
    """
    orderBy: [CompanyMembersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CompanyMemberCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CompanyMemberFilter
  ): CompanyMembersConnection

  """
  Reads and enables pagination through a set of `CompanyOperation`.
  """
  companyOperations(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `CompanyOperation`.
    """
    orderBy: [CompanyOperationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CompanyOperationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CompanyOperationFilter
  ): CompanyOperationsConnection

  """
  Reads and enables pagination through a set of `EvidenceItem`.
  """
  evidenceItems(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `EvidenceItem`.
    """
    orderBy: [EvidenceItemsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EvidenceItemCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EvidenceItemFilter
  ): EvidenceItemsConnection

  """
  Reads and enables pagination through a set of `Guarantee`.
  """
  guarantees(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `Guarantee`.
    """
    orderBy: [GuaranteesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GuaranteeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: GuaranteeFilter
  ): GuaranteesConnection

  """
  Reads and enables pagination through a set of `Invitation`.
  """
  invitations(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `Invitation`.
    """
    orderBy: [InvitationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: InvitationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: InvitationFilter
  ): InvitationsConnection

  """
  Reads and enables pagination through a set of `Market`.
  """
  markets(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `Market`.
    """
    orderBy: [MarketsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MarketCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MarketFilter
  ): MarketsConnection

  """
  Reads and enables pagination through a set of `Note`.
  """
  notes(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `Note`.
    """
    orderBy: [NotesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: NoteCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: NoteFilter
  ): NotesConnection

  """
  Reads and enables pagination through a set of `Notification`.
  """
  notifications(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `Notification`.
    """
    orderBy: [NotificationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: NotificationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: NotificationFilter
  ): NotificationsConnection

  """
  Reads and enables pagination through a set of `Product`.
  """
  products(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `Product`.
    """
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProductCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProductFilter
  ): ProductsConnection

  """
  Reads and enables pagination through a set of `Project`.
  """
  projects(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `Project`.
    """
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProjectFilter
  ): ProjectsConnection

  """
  Reads and enables pagination through a set of `ProjectMember`.
  """
  projectMembers(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `ProjectMember`.
    """
    orderBy: [ProjectMembersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectMemberCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProjectMemberFilter
  ): ProjectMembersConnection

  """
  Reads and enables pagination through a set of `System`.
  """
  systems(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `System`.
    """
    orderBy: [SystemsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SystemCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SystemFilter
  ): SystemsConnection

  """
  Reads and enables pagination through a set of `SystemMember`.
  """
  systemMembers(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `SystemMember`.
    """
    orderBy: [SystemMembersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SystemMemberCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SystemMemberFilter
  ): SystemMembersConnection
  account(id: Int!): Account
  accountByEmail(email: String!): Account
  accountByDoceboUserId(doceboUserId: Int!): Account
  address(id: Int!): Address
  certification(id: Int!): Certification
  company(id: Int!): Company
  companyByName(name: String!): Company
  companyByReferenceNumber(referenceNumber: String!): Company
  companyDocument(id: Int!): CompanyDocument
  companyMember(id: Int!): CompanyMember
  companyMemberByMarketIdAndAccountIdAndCompanyId(
    marketId: Int!
    accountId: Int!
    companyId: Int!
  ): CompanyMember
  companyOperation(id: Int!): CompanyOperation
  evidenceItem(id: Int!): EvidenceItem
  guarantee(id: Int!): Guarantee
  guaranteeByBmiReferenceId(bmiReferenceId: String!): Guarantee
  invitation(id: Int!): Invitation
  market(id: Int!): Market
  marketByDomain(domain: String!): Market
  marketByDoceboCatalogueId(doceboCatalogueId: Int!): Market
  note(id: Int!): Note
  notification(id: Int!): Notification
  product(id: Int!): Product
  productByBmiRef(bmiRef: String!): Product
  project(id: Int!): Project
  projectMember(id: Int!): ProjectMember
  system(id: Int!): System
  systemByBmiRef(bmiRef: String!): System
  systemMember(id: Int!): SystemMember
  systemMemberBySystemBmiRefAndProductBmiRefAndMarketId(
    systemBmiRef: String!
    productBmiRef: String!
    marketId: Int!
  ): SystemMember
  currentAccountEmail: String
  currentAccountId: Int
  currentCompany: Int
  currentMarket: Int
  invitedByCompanies(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: IntFilter
  ): InvitedByCompaniesConnection
  isPartOfProject(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: IntFilter
  ): IsPartOfProjectConnection
  isProjectEnabledByMarket: Boolean

  """
  Reads and enables pagination through a set of `Product`.
  """
  searchProducts(
    query: String!
    technology: Technology!

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProductFilter
  ): ProductsConnection

  """
  Reads and enables pagination through a set of `System`.
  """
  searchSystems(
    query: String!
    technology: Technology!

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SystemFilter
  ): SystemsConnection

  """
  Reads a single `Account` using its globally unique `ID`.
  """
  accountByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Account`.
    """
    nodeId: ID!
  ): Account

  """
  Reads a single `Address` using its globally unique `ID`.
  """
  addressByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Address`.
    """
    nodeId: ID!
  ): Address

  """
  Reads a single `Certification` using its globally unique `ID`.
  """
  certificationByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Certification`.
    """
    nodeId: ID!
  ): Certification

  """
  Reads a single `Company` using its globally unique `ID`.
  """
  companyByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Company`.
    """
    nodeId: ID!
  ): Company

  """
  Reads a single `CompanyDocument` using its globally unique `ID`.
  """
  companyDocumentByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `CompanyDocument`.
    """
    nodeId: ID!
  ): CompanyDocument

  """
  Reads a single `CompanyMember` using its globally unique `ID`.
  """
  companyMemberByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `CompanyMember`.
    """
    nodeId: ID!
  ): CompanyMember

  """
  Reads a single `CompanyOperation` using its globally unique `ID`.
  """
  companyOperationByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `CompanyOperation`.
    """
    nodeId: ID!
  ): CompanyOperation

  """
  Reads a single `EvidenceItem` using its globally unique `ID`.
  """
  evidenceItemByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `EvidenceItem`.
    """
    nodeId: ID!
  ): EvidenceItem

  """
  Reads a single `Guarantee` using its globally unique `ID`.
  """
  guaranteeByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Guarantee`.
    """
    nodeId: ID!
  ): Guarantee

  """
  Reads a single `Invitation` using its globally unique `ID`.
  """
  invitationByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Invitation`.
    """
    nodeId: ID!
  ): Invitation

  """
  Reads a single `Market` using its globally unique `ID`.
  """
  marketByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Market`.
    """
    nodeId: ID!
  ): Market

  """
  Reads a single `Note` using its globally unique `ID`.
  """
  noteByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Note`.
    """
    nodeId: ID!
  ): Note

  """
  Reads a single `Notification` using its globally unique `ID`.
  """
  notificationByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Notification`.
    """
    nodeId: ID!
  ): Notification

  """
  Reads a single `Product` using its globally unique `ID`.
  """
  productByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Product`.
    """
    nodeId: ID!
  ): Product

  """
  Reads a single `Project` using its globally unique `ID`.
  """
  projectByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Project`.
    """
    nodeId: ID!
  ): Project

  """
  Reads a single `ProjectMember` using its globally unique `ID`.
  """
  projectMemberByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `ProjectMember`.
    """
    nodeId: ID!
  ): ProjectMember

  """
  Reads a single `System` using its globally unique `ID`.
  """
  systemByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `System`.
    """
    nodeId: ID!
  ): System

  """
  Reads a single `SystemMember` using its globally unique `ID`.
  """
  systemMemberByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `SystemMember`.
    """
    nodeId: ID!
  ): SystemMember

  """
  Fetches a list of entities using their representations; used for Apollo
  Federation.
  """
  _entities(representations: [_Any!]!): [_Entity]!
    @deprecated(reason: "Only Apollo Federation should use this")

  """
  Entrypoint for Apollo Federation to determine more information about
  this service.
  """
  _service: _Service!
    @deprecated(reason: "Only Apollo Federation should use this")
}

"""
An object with a globally unique `ID`.
"""
interface Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

"""
A connection to a list of `Account` values.
"""
type AccountsConnection {
  """
  A list of `Account` objects.
  """
  nodes: [Account!]!

  """
  A list of edges which contains the `Account` and cursor to aid in pagination.
  """
  edges: [AccountsEdge!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Account` you could get from the connection.
  """
  totalCount: Int!
}

"""
An InTouch account
"""
type Account implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Primary key
  """
  id: Int!

  """
  ek
  """
  status: AccountStatus

  """
  fk
  """
  marketId: Int

  """
  ek
  """
  role: Role

  """
  The email address associated with the account
  """
  email: String!

  """
  A phone number that can optionally be provided, and is useful for Company Admin people to provide
  """
  phone: String

  """
  First name
  """
  firstName: String!

  """
  Last name
  """
  lastName: String!

  """
  When the account was created
  """
  created: Datetime

  """
  User account in Docebo
  """
  doceboUserId: Int

  """
  Username in Docebo.  Needed to generate the SSO link
  """
  doceboUsername: String

  """
  File reference. A profile picture of the user
  """
  photo: String

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String
  createdAt: Datetime!
  updatedAt: Datetime!

  """
  Reads a single `Market` that is related to this `Account`.
  """
  market: Market

  """
  Reads and enables pagination through a set of `Certification`.
  """
  certificationsByDoceboUserId(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `Certification`.
    """
    orderBy: [CertificationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CertificationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CertificationFilter
  ): CertificationsConnection!

  """
  Reads and enables pagination through a set of `CompanyMember`.
  """
  companyMembers(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `CompanyMember`.
    """
    orderBy: [CompanyMembersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CompanyMemberCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CompanyMemberFilter
  ): CompanyMembersConnection!

  """
  Reads and enables pagination through a set of `Guarantee`.
  """
  guaranteesByRequestorAccountId(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `Guarantee`.
    """
    orderBy: [GuaranteesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GuaranteeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: GuaranteeFilter
  ): GuaranteesConnection!

  """
  Reads and enables pagination through a set of `Guarantee`.
  """
  guaranteesByReviewerAccountId(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `Guarantee`.
    """
    orderBy: [GuaranteesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GuaranteeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: GuaranteeFilter
  ): GuaranteesConnection!

  """
  Reads and enables pagination through a set of `Invitation`.
  """
  invitationsBySenderAccountId(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `Invitation`.
    """
    orderBy: [InvitationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: InvitationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: InvitationFilter
  ): InvitationsConnection!

  """
  Reads and enables pagination through a set of `Note`.
  """
  authoredNotes(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `Note`.
    """
    orderBy: [NotesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: NoteCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: NoteFilter
  ): NotesConnection!

  """
  Reads and enables pagination through a set of `Notification`.
  """
  notifications(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `Notification`.
    """
    orderBy: [NotificationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: NotificationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: NotificationFilter
  ): NotificationsConnection!

  """
  Reads and enables pagination through a set of `ProjectMember`.
  """
  projectMembers(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `ProjectMember`.
    """
    orderBy: [ProjectMembersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectMemberCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProjectMemberFilter
  ): ProjectMembersConnection!
  formattedRole: String
  signedPhotoUrl: String
}

enum AccountStatus {
  NEW
  ACTIVE
  SUSPENDED
}

enum Role {
  SUPER_ADMIN
  MARKET_ADMIN
  INSTALLER
  COMPANY_ADMIN
}

"""
A point in time as described by the [ISO
8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
"""
scalar Datetime

"""
A country that BMI operates in
"""
type Market implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Primary key
  """
  id: Int!

  """
  ek
  """
  language: Language

  """
  the country code used for example as the subdomain
  """
  domain: String!

  """
  The space in Contenful
  """
  cmsSpaceId: String

  """
  A short name for the market, e.g. Italy, Norway, Netherlands
  """
  name: String

  """
  The From name used when sending an email
  """
  sendName: String

  """
  The mailbox on intouch.bmigroup.com that emails will be sent from for this Market
  """
  sendMailbox: String

  """
  The default branch in Docebo that installers go into
  """
  doceboInstallersBranchId: String

  """
  The branch in Docebo that company admins go into
  """
  doceboCompanyAdminBranchId: String

  """
  The default catalogue for the market.  All users in the market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int

  """
  The address of the merchandising site for the market.  CTAs of the MERCHANDISING type will link to this address
  """
  merchandisingUrl: String

  """
  Whether the market supports Projects.  If so then the Projects link should be available in th left hand navigation.
  """
  projectsEnabled: Boolean

  """
  Reference to the Google Analytics tracking ID that is used for the Country GA reports
  """
  gtag: String

  """
  The coordinates of the middle of the Market on a map
  """
  geoMiddle: Point

  """
  The length of the radius in km (from the geo_middle lat/lng), for which the Google Places API biases the search results for address autocomplete. Locations outside of the radius will not be excluded.
  """
  locationBiasRadiusKm: Int
  createdAt: Datetime!
  updatedAt: Datetime!

  """
  Reads and enables pagination through a set of `Account`.
  """
  accounts(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `Account`.
    """
    orderBy: [AccountsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AccountCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AccountFilter
  ): AccountsConnection!

  """
  Reads and enables pagination through a set of `Company`.
  """
  companies(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `Company`.
    """
    orderBy: [CompaniesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CompanyCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CompanyFilter
  ): CompaniesConnection!

  """
  Reads and enables pagination through a set of `CompanyMember`.
  """
  companyMembers(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `CompanyMember`.
    """
    orderBy: [CompanyMembersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CompanyMemberCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CompanyMemberFilter
  ): CompanyMembersConnection!

  """
  Reads and enables pagination through a set of `Product`.
  """
  products(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `Product`.
    """
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProductCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProductFilter
  ): ProductsConnection!

  """
  Reads and enables pagination through a set of `System`.
  """
  systems(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `System`.
    """
    orderBy: [SystemsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SystemCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SystemFilter
  ): SystemsConnection!

  """
  Reads and enables pagination through a set of `SystemMember`.
  """
  systemMembers(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `SystemMember`.
    """
    orderBy: [SystemMembersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SystemMemberCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SystemMemberFilter
  ): SystemMembersConnection!
}

enum Language {
  DA
  NO
  EN
  SV
  PT
  DE
  NL
  SK
  FR
  PL
  ES
  FI
}

type Point {
  x: Float!
  y: Float!
}

"""
A location in a connection that can be used for resuming pagination.
"""
scalar Cursor

"""
Methods to use when ordering `Account`.
"""
enum AccountsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  MARKET_ID_ASC
  MARKET_ID_DESC
  EMAIL_ASC
  EMAIL_DESC
  DOCEBO_USER_ID_ASC
  DOCEBO_USER_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Account` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input AccountCondition {
  """
  Checks for equality with the object’s `id` field.
  """
  id: Int

  """
  Checks for equality with the object’s `marketId` field.
  """
  marketId: Int

  """
  Checks for equality with the object’s `email` field.
  """
  email: String

  """
  Checks for equality with the object’s `doceboUserId` field.
  """
  doceboUserId: Int
}

"""
A filter to be used against `Account` object types. All fields are combined with a logical ‘and.’
"""
input AccountFilter {
  """
  Filter by the object’s `id` field.
  """
  id: IntFilter

  """
  Filter by the object’s `marketId` field.
  """
  marketId: IntFilter

  """
  Filter by the object’s `email` field.
  """
  email: StringFilter

  """
  Filter by the object’s `doceboUserId` field.
  """
  doceboUserId: IntFilter

  """
  Checks for all expressions in this list.
  """
  and: [AccountFilter!]

  """
  Checks for any expressions in this list.
  """
  or: [AccountFilter!]

  """
  Negates the expression.
  """
  not: AccountFilter
}

"""
A filter to be used against Int fields. All fields are combined with a logical ‘and.’
"""
input IntFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """
  Equal to the specified value.
  """
  equalTo: Int

  """
  Not equal to the specified value.
  """
  notEqualTo: Int

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Int

  """
  Equal to the specified value, treating null like an ordinary value.
  """
  notDistinctFrom: Int

  """
  Included in the specified list.
  """
  in: [Int!]

  """
  Not included in the specified list.
  """
  notIn: [Int!]

  """
  Less than the specified value.
  """
  lessThan: Int

  """
  Less than or equal to the specified value.
  """
  lessThanOrEqualTo: Int

  """
  Greater than the specified value.
  """
  greaterThan: Int

  """
  Greater than or equal to the specified value.
  """
  greaterThanOrEqualTo: Int
}

"""
A filter to be used against String fields. All fields are combined with a logical ‘and.’
"""
input StringFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """
  Equal to the specified value.
  """
  equalTo: String

  """
  Not equal to the specified value.
  """
  notEqualTo: String

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: String

  """
  Equal to the specified value, treating null like an ordinary value.
  """
  notDistinctFrom: String

  """
  Included in the specified list.
  """
  in: [String!]

  """
  Not included in the specified list.
  """
  notIn: [String!]

  """
  Less than the specified value.
  """
  lessThan: String

  """
  Less than or equal to the specified value.
  """
  lessThanOrEqualTo: String

  """
  Greater than the specified value.
  """
  greaterThan: String

  """
  Greater than or equal to the specified value.
  """
  greaterThanOrEqualTo: String

  """
  Contains the specified string (case-sensitive).
  """
  includes: String

  """
  Does not contain the specified string (case-sensitive).
  """
  notIncludes: String

  """
  Contains the specified string (case-insensitive).
  """
  includesInsensitive: String

  """
  Does not contain the specified string (case-insensitive).
  """
  notIncludesInsensitive: String

  """
  Starts with the specified string (case-sensitive).
  """
  startsWith: String

  """
  Does not start with the specified string (case-sensitive).
  """
  notStartsWith: String

  """
  Starts with the specified string (case-insensitive).
  """
  startsWithInsensitive: String

  """
  Does not start with the specified string (case-insensitive).
  """
  notStartsWithInsensitive: String

  """
  Ends with the specified string (case-sensitive).
  """
  endsWith: String

  """
  Does not end with the specified string (case-sensitive).
  """
  notEndsWith: String

  """
  Ends with the specified string (case-insensitive).
  """
  endsWithInsensitive: String

  """
  Does not end with the specified string (case-insensitive).
  """
  notEndsWithInsensitive: String

  """
  Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  like: String

  """
  Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  notLike: String

  """
  Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  likeInsensitive: String

  """
  Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  notLikeInsensitive: String

  """
  Equal to the specified value (case-insensitive).
  """
  equalToInsensitive: String

  """
  Not equal to the specified value (case-insensitive).
  """
  notEqualToInsensitive: String

  """
  Not equal to the specified value, treating null like an ordinary value (case-insensitive).
  """
  distinctFromInsensitive: String

  """
  Equal to the specified value, treating null like an ordinary value (case-insensitive).
  """
  notDistinctFromInsensitive: String

  """
  Included in the specified list (case-insensitive).
  """
  inInsensitive: [String!]

  """
  Not included in the specified list (case-insensitive).
  """
  notInInsensitive: [String!]

  """
  Less than the specified value (case-insensitive).
  """
  lessThanInsensitive: String

  """
  Less than or equal to the specified value (case-insensitive).
  """
  lessThanOrEqualToInsensitive: String

  """
  Greater than the specified value (case-insensitive).
  """
  greaterThanInsensitive: String

  """
  Greater than or equal to the specified value (case-insensitive).
  """
  greaterThanOrEqualToInsensitive: String
}

"""
A connection to a list of `Company` values.
"""
type CompaniesConnection {
  """
  A list of `Company` objects.
  """
  nodes: [Company!]!

  """
  A list of edges which contains the `Company` and cursor to aid in pagination.
  """
  edges: [CompaniesEdge!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Company` you could get from the connection.
  """
  totalCount: Int!
}

"""
A company that has been registered in InTouch
"""
type Company implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Primary key
  """
  id: Int!

  """
  fk
  """
  marketId: Int

  """
  fk
  """
  registeredAddressId: Int

  """
  fk
  """
  tradingAddressId: Int

  """
  the name of the owner of the Company
  """
  ownerFullname: String

  """
  the email address to contact the owner
  """
  ownerEmail: String

  """
  the phone number to contact the owner
  """
  ownerPhone: String

  """
  ek
  """
  businessType: BusinessType

  """
  ek
  """
  tier: Tier

  """
  ek
  """
  status: CompanyStatus

  """
  the email address of the person who filled out the company registration form
  """
  registeredBy: String

  """
  the date that the Company registration form was submitted
  """
  registeredDate: Datetime

  """
  The registered name of the Company
  """
  name: String

  """
  The Tax number in that Market, such as the VAT number
  """
  taxNumber: String

  """
  The Company public phone number
  """
  phone: String

  """
  A descirption of the Company intended for Find a Roofer
  """
  aboutUs: String

  """
  The email address that they can be contacted with by the public assuming they are listed
  """
  publicEmail: String

  """
  The Company website URL
  """
  website: String

  """
  The Company facebook website
  """
  facebook: String

  """
  Their Company LinkedIn page URL
  """
  linkedIn: String

  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: String

  """
  A reference to the logo image
  """
  logo: String

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String

  """
  Used for reference when importing data from the legacy system
  """
  tradingAddressMigrationId: String

  """
  Used for reference when importing data from the legacy system
  """
  registeredAddressMigrationId: String
  createdAt: Datetime!
  updatedAt: Datetime!

  """
  Reads a single `Market` that is related to this `Company`.
  """
  market: Market

  """
  Reads a single `Address` that is related to this `Company`.
  """
  registeredAddress: Address

  """
  Reads a single `Address` that is related to this `Company`.
  """
  tradingAddress: Address

  """
  Reads and enables pagination through a set of `CompanyDocument`.
  """
  companyDocuments(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `CompanyDocument`.
    """
    orderBy: [CompanyDocumentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CompanyDocumentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CompanyDocumentFilter
  ): CompanyDocumentsConnection!

  """
  Reads and enables pagination through a set of `CompanyMember`.
  """
  companyMembers(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `CompanyMember`.
    """
    orderBy: [CompanyMembersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CompanyMemberCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CompanyMemberFilter
  ): CompanyMembersConnection!

  """
  Reads and enables pagination through a set of `CompanyOperation`.
  """
  companyOperationsByCompany(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `CompanyOperation`.
    """
    orderBy: [CompanyOperationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CompanyOperationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CompanyOperationFilter
  ): CompanyOperationsConnection!

  """
  Reads and enables pagination through a set of `Invitation`.
  """
  invitations(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `Invitation`.
    """
    orderBy: [InvitationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: InvitationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: InvitationFilter
  ): InvitationsConnection!

  """
  Reads and enables pagination through a set of `Project`.
  """
  projects(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `Project`.
    """
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProjectFilter
  ): ProjectsConnection!
  certifications: [Technology]!
  isProfileComplete: Boolean!
}

enum BusinessType {
  CONTRACTOR
  ARCHITECT
  MERCHANT
  CORP_DEVELOPER
}

enum Tier {
  T1
  T2
  T3
  T4
}

enum CompanyStatus {
  NEW
  ACTIVE
  DEACTIVATED
}

"""
A generic address
"""
type Address implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Primary key
  """
  id: Int!

  """
  First line of this address
  """
  firstLine: String!

  """
  Second line of this address
  """
  secondLine: String

  """
  The postal town
  """
  town: String

  """
  The region if relevant
  """
  region: String

  """
  The country for this address
  """
  country: String

  """
  The postcode for this address
  """
  postcode: String!

  """
  The coordinates on a map of the world
  """
  coordinates: Point

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String
  createdAt: Datetime!
  updatedAt: Datetime!

  """
  Reads and enables pagination through a set of `Company`.
  """
  companiesByRegisteredAddressId(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `Company`.
    """
    orderBy: [CompaniesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CompanyCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CompanyFilter
  ): CompaniesConnection!

  """
  Reads and enables pagination through a set of `Company`.
  """
  companiesByTradingAddressId(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `Company`.
    """
    orderBy: [CompaniesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CompanyCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CompanyFilter
  ): CompaniesConnection!

  """
  Reads and enables pagination through a set of `Project`.
  """
  projectsBySiteAddressId(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `Project`.
    """
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProjectFilter
  ): ProjectsConnection!

  """
  Reads and enables pagination through a set of `Project`.
  """
  projectsByBuildingOwnerAddressId(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `Project`.
    """
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProjectFilter
  ): ProjectsConnection!
}

"""
Methods to use when ordering `Company`.
"""
enum CompaniesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  MARKET_ID_ASC
  MARKET_ID_DESC
  REGISTERED_ADDRESS_ID_ASC
  REGISTERED_ADDRESS_ID_DESC
  TRADING_ADDRESS_ID_ASC
  TRADING_ADDRESS_ID_DESC
  NAME_ASC
  NAME_DESC
  REFERENCE_NUMBER_ASC
  REFERENCE_NUMBER_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Company` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input CompanyCondition {
  """
  Checks for equality with the object’s `id` field.
  """
  id: Int

  """
  Checks for equality with the object’s `marketId` field.
  """
  marketId: Int

  """
  Checks for equality with the object’s `registeredAddressId` field.
  """
  registeredAddressId: Int

  """
  Checks for equality with the object’s `tradingAddressId` field.
  """
  tradingAddressId: Int

  """
  Checks for equality with the object’s `name` field.
  """
  name: String

  """
  Checks for equality with the object’s `referenceNumber` field.
  """
  referenceNumber: String
}

"""
A filter to be used against `Company` object types. All fields are combined with a logical ‘and.’
"""
input CompanyFilter {
  """
  Filter by the object’s `id` field.
  """
  id: IntFilter

  """
  Filter by the object’s `marketId` field.
  """
  marketId: IntFilter

  """
  Filter by the object’s `registeredAddressId` field.
  """
  registeredAddressId: IntFilter

  """
  Filter by the object’s `tradingAddressId` field.
  """
  tradingAddressId: IntFilter

  """
  Filter by the object’s `name` field.
  """
  name: StringFilter

  """
  Filter by the object’s `referenceNumber` field.
  """
  referenceNumber: StringFilter

  """
  Checks for all expressions in this list.
  """
  and: [CompanyFilter!]

  """
  Checks for any expressions in this list.
  """
  or: [CompanyFilter!]

  """
  Negates the expression.
  """
  not: CompanyFilter
}

"""
A connection to a list of `Project` values.
"""
type ProjectsConnection {
  """
  A list of `Project` objects.
  """
  nodes: [Project!]!

  """
  A list of edges which contains the `Project` and cursor to aid in pagination.
  """
  edges: [ProjectsEdge!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Project` you could get from the connection.
  """
  totalCount: Int!
}

"""
A project that has been put into InTouch by a Company Administrator to represent a project being done by that company
"""
type Project implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Primary key
  """
  id: Int!

  """
  fk
  """
  companyId: Int

  """
  fk
  """
  siteAddressId: Int

  """
  fk
  """
  buildingOwnerAddressId: Int

  """
  ek
  """
  technology: Technology

  """
  Short name for the Project
  """
  name: String!

  """
  Short description of what the Project is about.  Sometimes useful to clarify some points to BMI
  """
  description: String

  """
  If this is true then the Project should be hidden from End Users
  """
  hidden: Boolean

  """
  The number of square meters of roof that this project covers
  """
  roofArea: Int!

  """
  Email address of the person who owns the building that the roof is going on.  Not mandatory for a Project, but mandatory when the Company applies for a Guarantee related to the project.
  """
  buildingOwnerMail: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerFirstname: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerLastname: String

  """
  Name of the Building Owner company if there is such a thing.  Not the same as an InTouch Company.
  """
  buildingOwnerCompany: String

  """
  The date that the Project officially starts or started
  """
  startDate: Datetime!

  """
  The date that the Project officially expects to end or ended
  """
  endDate: Datetime!
  createdAt: Datetime!
  updatedAt: Datetime!

  """
  Reads a single `Company` that is related to this `Project`.
  """
  company: Company

  """
  Reads a single `Address` that is related to this `Project`.
  """
  siteAddress: Address

  """
  Reads a single `Address` that is related to this `Project`.
  """
  buildingOwnerAddress: Address

  """
  Reads and enables pagination through a set of `EvidenceItem`.
  """
  evidenceItems(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `EvidenceItem`.
    """
    orderBy: [EvidenceItemsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EvidenceItemCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EvidenceItemFilter
  ): EvidenceItemsConnection!

  """
  Reads and enables pagination through a set of `Guarantee`.
  """
  guarantees(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `Guarantee`.
    """
    orderBy: [GuaranteesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GuaranteeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: GuaranteeFilter
  ): GuaranteesConnection!

  """
  Reads and enables pagination through a set of `Note`.
  """
  notes(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `Note`.
    """
    orderBy: [NotesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: NoteCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: NoteFilter
  ): NotesConnection!

  """
  Reads and enables pagination through a set of `ProjectMember`.
  """
  projectMembers(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `ProjectMember`.
    """
    orderBy: [ProjectMembersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectMemberCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProjectMemberFilter
  ): ProjectMembersConnection!
}

enum Technology {
  FLAT
  PITCHED
  OTHER
}

"""
A connection to a list of `EvidenceItem` values.
"""
type EvidenceItemsConnection {
  """
  A list of `EvidenceItem` objects.
  """
  nodes: [EvidenceItem!]!

  """
  A list of edges which contains the `EvidenceItem` and cursor to aid in pagination.
  """
  edges: [EvidenceItemsEdge!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `EvidenceItem` you could get from the connection.
  """
  totalCount: Int!
}

"""
A file uploaded to a project, usually as evidence to support a guarantee
"""
type EvidenceItem implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Primary key
  """
  id: Int!

  """
  a reference to the evidenceCategory sys id in Contentful
  """
  customEvidenceCategoryId: String

  """
  fk
  """
  projectId: Int

  """
  fk
  """
  guaranteeId: Int

  """
  ek
  """
  evidenceCategoryType: EvidenceCategoryType

  """
  Short name for the item of evidence
  """
  name: String!

  """
  File reference or the file itself. Photo of the evidence
  """
  attachment: String!
  createdAt: Datetime!
  updatedAt: Datetime!

  """
  Reads a single `Project` that is related to this `EvidenceItem`.
  """
  project: Project

  """
  Reads a single `Guarantee` that is related to this `EvidenceItem`.
  """
  guarantee: Guarantee
  customEvidenceCategory: ContentfulEvidenceCategory
}

enum EvidenceCategoryType {
  PROOF_OF_PURCHASE
  MISCELLANEOUS
  CUSTOM
}

"""
Starts life as request for a gurantee and becomes an actual issued guarantee
"""
type Guarantee implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Primary key - starts at 6100
  """
  id: Int!

  """
  The pdf file that is emailed out, or a reference to it, or reference to the service that will generate it on demand
  """
  fileStorageId: String

  """
  fk
  """
  requestorAccountId: Int

  """
  fk
  """
  projectId: Int

  """
  a reference to the guaranteeType sys id in Contentful
  """
  guaranteeTypeId: String!

  """
  fk
  """
  systemBmiRef: String

  """
  fk
  """
  productBmiRef: String

  """
  fk
  """
  reviewerAccountId: Int

  """
  a reference to the guaranteeType sys id in Contentful
  """
  guaranteeTemplateId: String

  """
  ek
  """
  status: RequestStatus

  """
  The date that the Guarantee is approved either automatically or manually
  """
  startDate: Datetime

  """
  When the guarantee will expire.  This should be calculated when the request_status becomes APPROVED. dependent on the StartDate, the Validity of the Product or System and the ValidityOffset in this Tier
  """
  expiryDate: Datetime

  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String
  createdAt: Datetime!
  updatedAt: Datetime!

  """
  Reads a single `Account` that is related to this `Guarantee`.
  """
  requestorAccount: Account

  """
  Reads a single `Project` that is related to this `Guarantee`.
  """
  project: Project

  """
  Reads a single `System` that is related to this `Guarantee`.
  """
  systemBySystemBmiRef: System

  """
  Reads a single `Product` that is related to this `Guarantee`.
  """
  productByProductBmiRef: Product

  """
  Reads a single `Account` that is related to this `Guarantee`.
  """
  reviewerAccount: Account

  """
  Reads and enables pagination through a set of `EvidenceItem`.
  """
  evidenceItems(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `EvidenceItem`.
    """
    orderBy: [EvidenceItemsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EvidenceItemCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EvidenceItemFilter
  ): EvidenceItemsConnection!
  guaranteeType: ContentfulGuaranteeType
}

enum RequestStatus {
  NEW
  SUBMITTED
  REVIEW
  REJECTED
  APPROVED
}

"""
A collection of products that can be guaranteed as a system
"""
type System implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Primary key
  """
  id: Int!

  """
  fk
  """
  marketId: Int

  """
  ek
  """
  technology: Technology

  """
  A unique reference for the system known to BMI
  """
  bmiRef: String!

  """
  Short name for the System
  """
  name: String!

  """
  A description for the System
  """
  description: String

  """
  The maximum number of years that this system can be guaranteed for.  Must be greater than 10.
  """
  maximumValidityYears: Int!

  """
  If true this system is available for users to select when applying for a system or solution guarantee
  """
  published: Boolean!
  createdAt: Datetime!
  updatedAt: Datetime!

  """
  Reads a single `Market` that is related to this `System`.
  """
  market: Market

  """
  Reads and enables pagination through a set of `Guarantee`.
  """
  guaranteesBySystemBmiRef(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `Guarantee`.
    """
    orderBy: [GuaranteesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GuaranteeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: GuaranteeFilter
  ): GuaranteesConnection!

  """
  Reads and enables pagination through a set of `SystemMember`.
  """
  systemMembersBySystemBmiRef(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `SystemMember`.
    """
    orderBy: [SystemMembersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SystemMemberCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SystemMemberFilter
  ): SystemMembersConnection!
}

"""
A connection to a list of `Guarantee` values.
"""
type GuaranteesConnection {
  """
  A list of `Guarantee` objects.
  """
  nodes: [Guarantee!]!

  """
  A list of edges which contains the `Guarantee` and cursor to aid in pagination.
  """
  edges: [GuaranteesEdge!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Guarantee` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `Guarantee` edge in the connection.
"""
type GuaranteesEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Guarantee` at the end of the edge.
  """
  node: Guarantee!
}

"""
Information about pagination in a connection.
"""
type PageInfo {
  """
  When paginating forwards, are there more items?
  """
  hasNextPage: Boolean!

  """
  When paginating backwards, are there more items?
  """
  hasPreviousPage: Boolean!

  """
  When paginating backwards, the cursor to continue.
  """
  startCursor: Cursor

  """
  When paginating forwards, the cursor to continue.
  """
  endCursor: Cursor
}

"""
Methods to use when ordering `Guarantee`.
"""
enum GuaranteesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  REQUESTOR_ACCOUNT_ID_ASC
  REQUESTOR_ACCOUNT_ID_DESC
  PROJECT_ID_ASC
  PROJECT_ID_DESC
  SYSTEM_BMI_REF_ASC
  SYSTEM_BMI_REF_DESC
  PRODUCT_BMI_REF_ASC
  PRODUCT_BMI_REF_DESC
  REVIEWER_ACCOUNT_ID_ASC
  REVIEWER_ACCOUNT_ID_DESC
  BMI_REFERENCE_ID_ASC
  BMI_REFERENCE_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Guarantee` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input GuaranteeCondition {
  """
  Checks for equality with the object’s `id` field.
  """
  id: Int

  """
  Checks for equality with the object’s `requestorAccountId` field.
  """
  requestorAccountId: Int

  """
  Checks for equality with the object’s `projectId` field.
  """
  projectId: Int

  """
  Checks for equality with the object’s `systemBmiRef` field.
  """
  systemBmiRef: String

  """
  Checks for equality with the object’s `productBmiRef` field.
  """
  productBmiRef: String

  """
  Checks for equality with the object’s `reviewerAccountId` field.
  """
  reviewerAccountId: Int

  """
  Checks for equality with the object’s `bmiReferenceId` field.
  """
  bmiReferenceId: String
}

"""
A filter to be used against `Guarantee` object types. All fields are combined with a logical ‘and.’
"""
input GuaranteeFilter {
  """
  Filter by the object’s `id` field.
  """
  id: IntFilter

  """
  Filter by the object’s `requestorAccountId` field.
  """
  requestorAccountId: IntFilter

  """
  Filter by the object’s `projectId` field.
  """
  projectId: IntFilter

  """
  Filter by the object’s `systemBmiRef` field.
  """
  systemBmiRef: StringFilter

  """
  Filter by the object’s `productBmiRef` field.
  """
  productBmiRef: StringFilter

  """
  Filter by the object’s `reviewerAccountId` field.
  """
  reviewerAccountId: IntFilter

  """
  Filter by the object’s `bmiReferenceId` field.
  """
  bmiReferenceId: StringFilter

  """
  Checks for all expressions in this list.
  """
  and: [GuaranteeFilter!]

  """
  Checks for any expressions in this list.
  """
  or: [GuaranteeFilter!]

  """
  Negates the expression.
  """
  not: GuaranteeFilter
}

"""
A connection to a list of `SystemMember` values.
"""
type SystemMembersConnection {
  """
  A list of `SystemMember` objects.
  """
  nodes: [SystemMember!]!

  """
  A list of edges which contains the `SystemMember` and cursor to aid in pagination.
  """
  edges: [SystemMembersEdge!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `SystemMember` you could get from the connection.
  """
  totalCount: Int!
}

"""
A Products that make up a system
"""
type SystemMember implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Primary key
  """
  id: Int!

  """
  fk
  """
  systemBmiRef: String

  """
  fk
  """
  productBmiRef: String

  """
  fk
  """
  marketId: Int
  createdAt: Datetime!
  updatedAt: Datetime!

  """
  Reads a single `System` that is related to this `SystemMember`.
  """
  systemBySystemBmiRef: System

  """
  Reads a single `Product` that is related to this `SystemMember`.
  """
  productByProductBmiRef: Product

  """
  Reads a single `Market` that is related to this `SystemMember`.
  """
  market: Market
}

"""
A product made by BMI
"""
type Product implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Primary key
  """
  id: Int!

  """
  fk
  """
  marketId: Int

  """
  ek
  """
  technology: Technology

  """
  A unique reference for the product known to BMI
  """
  bmiRef: String!

  """
  The Products brand
  """
  brand: String!

  """
  Short name for the Product
  """
  name: String!

  """
  A description of the Product
  """
  description: String

  """
  The family of Products this Product is in
  """
  family: String!

  """
  Whether the Product is avialable for new guarantees
  """
  published: Boolean!

  """
  The number of years that this product can be guaranteed for
  """
  maximumValidityYears: Int!
  createdAt: Datetime!
  updatedAt: Datetime!

  """
  Reads a single `Market` that is related to this `Product`.
  """
  market: Market

  """
  Reads and enables pagination through a set of `Guarantee`.
  """
  guaranteesByProductBmiRef(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `Guarantee`.
    """
    orderBy: [GuaranteesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GuaranteeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: GuaranteeFilter
  ): GuaranteesConnection!

  """
  Reads and enables pagination through a set of `SystemMember`.
  """
  systemMembersByProductBmiRef(
    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    The method to use when ordering `SystemMember`.
    """
    orderBy: [SystemMembersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SystemMemberCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SystemMemberFilter
  ): SystemMembersConnection!
}

"""
Methods to use when ordering `SystemMember`.
"""
enum SystemMembersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  SYSTEM_BMI_REF_ASC
  SYSTEM_BMI_REF_DESC
  PRODUCT_BMI_REF_ASC
  PRODUCT_BMI_REF_DESC
  MARKET_ID_ASC
  MARKET_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `SystemMember` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input SystemMemberCondition {
  """
  Checks for equality with the object’s `id` field.
  """
  id: Int

  """
  Checks for equality with the object’s `systemBmiRef` field.
  """
  systemBmiRef: String

  """
  Checks for equality with the object’s `productBmiRef` field.
  """
  productBmiRef: String

  """
  Checks for equality with the object’s `marketId` field.
  """
  marketId: Int
}

"""
A filter to be used against `SystemMember` object types. All fields are combined with a logical ‘and.’
"""
input SystemMemberFilter {
  """
  Filter by the object’s `id` field.
  """
  id: IntFilter

  """
  Filter by the object’s `systemBmiRef` field.
  """
  systemBmiRef: StringFilter

  """
  Filter by the object’s `productBmiRef` field.
  """
  productBmiRef: StringFilter

  """
  Filter by the object’s `marketId` field.
  """
  marketId: IntFilter

  """
  Checks for all expressions in this list.
  """
  and: [SystemMemberFilter!]

  """
  Checks for any expressions in this list.
  """
  or: [SystemMemberFilter!]

  """
  Negates the expression.
  """
  not: SystemMemberFilter
}

"""
A `SystemMember` edge in the connection.
"""
type SystemMembersEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `SystemMember` at the end of the edge.
  """
  node: SystemMember!
}

"""
Methods to use when ordering `EvidenceItem`.
"""
enum EvidenceItemsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  PROJECT_ID_ASC
  PROJECT_ID_DESC
  GUARANTEE_ID_ASC
  GUARANTEE_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `EvidenceItem` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input EvidenceItemCondition {
  """
  Checks for equality with the object’s `id` field.
  """
  id: Int

  """
  Checks for equality with the object’s `projectId` field.
  """
  projectId: Int

  """
  Checks for equality with the object’s `guaranteeId` field.
  """
  guaranteeId: Int
}

"""
A filter to be used against `EvidenceItem` object types. All fields are combined with a logical ‘and.’
"""
input EvidenceItemFilter {
  """
  Filter by the object’s `id` field.
  """
  id: IntFilter

  """
  Filter by the object’s `projectId` field.
  """
  projectId: IntFilter

  """
  Filter by the object’s `guaranteeId` field.
  """
  guaranteeId: IntFilter

  """
  Checks for all expressions in this list.
  """
  and: [EvidenceItemFilter!]

  """
  Checks for any expressions in this list.
  """
  or: [EvidenceItemFilter!]

  """
  Negates the expression.
  """
  not: EvidenceItemFilter
}

type ContentfulGuaranteeType {
  sys: ContentfulSys!
  displayName: String
  technology: ContentfulTechnologyType
  coverage: ContentfulGuaranteeCoverageType
  guaranteeReferenceCode: String
  name: String
  signature: ContentfulAsset
  maximumValidityYears: Int
  tiersAvailable: [ContentfulTiers]
  ranking: Int
  evidenceCategoriesCollection: ContentfulEvidenceCategoryCollection
  guaranteeTemplatesCollection: ContentfulGuaranteeTemplatesCollection
}

type ContentfulSys {
  id: String!
}

enum ContentfulTechnologyType {
  FLAT
  PITCHED
  OTHER
}

enum ContentfulGuaranteeCoverageType {
  PRODUCT
  SYSTEM
  SOLUTION
}

type ContentfulAsset {
  title: String
  description: String
  contentType: String
  fileName: String
  url: String
}

enum ContentfulTiers {
  T1
  T2
  T3
  T4
}

type ContentfulEvidenceCategoryCollection {
  items: [ContentfulEvidenceCategory]
}

type ContentfulEvidenceCategory {
  sys: ContentfulSys!
  name: String
  description: String
  minimumUploads: Int
  referenceCode: String
}

type ContentfulGuaranteeTemplatesCollection {
  items: [ContentfulGuaranteeTemplate]
}

type ContentfulGuaranteeTemplate {
  coverage: String
  languageCode: String
  languageDescriptor: String
  approvalMessage: ContentfulMessage
  rejectionMessage: ContentfulMessage
  terms: ContentfulAsset
  maintenanceTemplate: ContentfulAsset
  logo: ContentfulAsset
  guaranteeScope: String
  signatory: String
  headingGuarantee: String
  headingScope: String
  headingProducts: String
  headingBeneficiary: String
  headingBuildingOwnerName: String
  headingBuildingAddress: String
  headingRoofArea: String
  headingRoofType: String
  headingContractor: String
  headingContractorName: String
  headingContractorId: String
  headingStartDate: String
  headingGuaranteeId: String
  headingValidity: String
  headingExpiry: String
  footer: String
  mailBody: String
  filenamePrefix: String
  titleLine1: String
  titleLine2: String
  roofType: String
}

type ContentfulMessage {
  event: ContentfulMessageEventType
  format: ContentfulMessageFormat
  subject: String
  notificationBody: String
  emailBody: String
}

enum ContentfulMessageEventType {
  MEMBER_INVITED
  NEWUSER_INVITED
  PROFILE_REMINDER
  ADMIN_INVITED
  ROLE_ASSIGNED
  OWNER_INVITED
  REGISTRATION_CONGRATS
  REGISTRATION_ACTIVATED
  TEAM_JOINED
  CERTIFICATION_EXPIRED
  TIER_ASSIGNED
  REQUEST_REJECTED
  REQUEST_APPROVED
}

enum ContentfulMessageFormat {
  EMAIL
  NOTIFICATION
}

"""
A `EvidenceItem` edge in the connection.
"""
type EvidenceItemsEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `EvidenceItem` at the end of the edge.
  """
  node: EvidenceItem!
}

"""
A connection to a list of `Note` values.
"""
type NotesConnection {
  """
  A list of `Note` objects.
  """
  nodes: [Note!]!

  """
  A list of edges which contains the `Note` and cursor to aid in pagination.
  """
  edges: [NotesEdge!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Note` you could get from the connection.
  """
  totalCount: Int!
}

"""
A note added by a BMI admin. It is likely to be either a short note regarding approval, saying something like, Approved, or Good Job, or a note explaining a rejection, saying  something like, The photographs of the roof are not clear enough.
"""
type Note implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Primary key
  """
  id: Int!

  """
  fk
  """
  authorId: Int

  """
  fk
  """
  projectId: Int

  """
  The body of the Note
  """
  body: String
  createdAt: Datetime!
  updatedAt: Datetime!

  """
  Reads a single `Account` that is related to this `Note`.
  """
  author: Account

  """
  Reads a single `Project` that is related to this `Note`.
  """
  project: Project
}

"""
A `Note` edge in the connection.
"""
type NotesEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Note` at the end of the edge.
  """
  node: Note!
}

"""
Methods to use when ordering `Note`.
"""
enum NotesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  AUTHOR_ID_ASC
  AUTHOR_ID_DESC
  PROJECT_ID_ASC
  PROJECT_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Note` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input NoteCondition {
  """
  Checks for equality with the object’s `id` field.
  """
  id: Int

  """
  Checks for equality with the object’s `authorId` field.
  """
  authorId: Int

  """
  Checks for equality with the object’s `projectId` field.
  """
  projectId: Int
}

"""
A filter to be used against `Note` object types. All fields are combined with a logical ‘and.’
"""
input NoteFilter {
  """
  Filter by the object’s `id` field.
  """
  id: IntFilter

  """
  Filter by the object’s `authorId` field.
  """
  authorId: IntFilter

  """
  Filter by the object’s `projectId` field.
  """
  projectId: IntFilter

  """
  Checks for all expressions in this list.
  """
  and: [NoteFilter!]

  """
  Checks for any expressions in this list.
  """
  or: [NoteFilter!]

  """
  Negates the expression.
  """
  not: NoteFilter
}

"""
A connection to a list of `ProjectMember` values.
"""
type ProjectMembersConnection {
  """
  A list of `ProjectMember` objects.
  """
  nodes: [ProjectMember!]!

  """
  A list of edges which contains the `ProjectMember` and cursor to aid in pagination.
  """
  edges: [ProjectMembersEdge!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `ProjectMember` you could get from the connection.
  """
  totalCount: Int!
}

"""
People who are on a Project
"""
type ProjectMember implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Primary key
  """
  id: Int!

  """
  fk
  """
  projectId: Int

  """
  fk
  """
  accountId: Int

  """
  The responsible installer
  """
  isResponsibleInstaller: Boolean
  createdAt: Datetime!
  updatedAt: Datetime!

  """
  Reads a single `Project` that is related to this `ProjectMember`.
  """
  project: Project

  """
  Reads a single `Account` that is related to this `ProjectMember`.
  """
  account: Account
}

"""
A `ProjectMember` edge in the connection.
"""
type ProjectMembersEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `ProjectMember` at the end of the edge.
  """
  node: ProjectMember!
}

"""
Methods to use when ordering `ProjectMember`.
"""
enum ProjectMembersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  PROJECT_ID_ASC
  PROJECT_ID_DESC
  ACCOUNT_ID_ASC
  ACCOUNT_ID_DESC
  IS_RESPONSIBLE_INSTALLER_ASC
  IS_RESPONSIBLE_INSTALLER_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `ProjectMember` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input ProjectMemberCondition {
  """
  Checks for equality with the object’s `id` field.
  """
  id: Int

  """
  Checks for equality with the object’s `projectId` field.
  """
  projectId: Int

  """
  Checks for equality with the object’s `accountId` field.
  """
  accountId: Int

  """
  Checks for equality with the object’s `isResponsibleInstaller` field.
  """
  isResponsibleInstaller: Boolean
}

"""
A filter to be used against `ProjectMember` object types. All fields are combined with a logical ‘and.’
"""
input ProjectMemberFilter {
  """
  Filter by the object’s `id` field.
  """
  id: IntFilter

  """
  Filter by the object’s `projectId` field.
  """
  projectId: IntFilter

  """
  Filter by the object’s `accountId` field.
  """
  accountId: IntFilter

  """
  Filter by the object’s `isResponsibleInstaller` field.
  """
  isResponsibleInstaller: BooleanFilter

  """
  Checks for all expressions in this list.
  """
  and: [ProjectMemberFilter!]

  """
  Checks for any expressions in this list.
  """
  or: [ProjectMemberFilter!]

  """
  Negates the expression.
  """
  not: ProjectMemberFilter
}

"""
A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’
"""
input BooleanFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """
  Equal to the specified value.
  """
  equalTo: Boolean

  """
  Not equal to the specified value.
  """
  notEqualTo: Boolean

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Boolean

  """
  Equal to the specified value, treating null like an ordinary value.
  """
  notDistinctFrom: Boolean

  """
  Included in the specified list.
  """
  in: [Boolean!]

  """
  Not included in the specified list.
  """
  notIn: [Boolean!]

  """
  Less than the specified value.
  """
  lessThan: Boolean

  """
  Less than or equal to the specified value.
  """
  lessThanOrEqualTo: Boolean

  """
  Greater than the specified value.
  """
  greaterThan: Boolean

  """
  Greater than or equal to the specified value.
  """
  greaterThanOrEqualTo: Boolean
}

"""
A `Project` edge in the connection.
"""
type ProjectsEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Project` at the end of the edge.
  """
  node: Project!
}

"""
Methods to use when ordering `Project`.
"""
enum ProjectsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  COMPANY_ID_ASC
  COMPANY_ID_DESC
  SITE_ADDRESS_ID_ASC
  SITE_ADDRESS_ID_DESC
  BUILDING_OWNER_ADDRESS_ID_ASC
  BUILDING_OWNER_ADDRESS_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Project` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input ProjectCondition {
  """
  Checks for equality with the object’s `id` field.
  """
  id: Int

  """
  Checks for equality with the object’s `companyId` field.
  """
  companyId: Int

  """
  Checks for equality with the object’s `siteAddressId` field.
  """
  siteAddressId: Int

  """
  Checks for equality with the object’s `buildingOwnerAddressId` field.
  """
  buildingOwnerAddressId: Int
}

"""
A filter to be used against `Project` object types. All fields are combined with a logical ‘and.’
"""
input ProjectFilter {
  """
  Filter by the object’s `id` field.
  """
  id: IntFilter

  """
  Filter by the object’s `companyId` field.
  """
  companyId: IntFilter

  """
  Filter by the object’s `siteAddressId` field.
  """
  siteAddressId: IntFilter

  """
  Filter by the object’s `buildingOwnerAddressId` field.
  """
  buildingOwnerAddressId: IntFilter

  """
  Checks for all expressions in this list.
  """
  and: [ProjectFilter!]

  """
  Checks for any expressions in this list.
  """
  or: [ProjectFilter!]

  """
  Negates the expression.
  """
  not: ProjectFilter
}

"""
A connection to a list of `CompanyDocument` values.
"""
type CompanyDocumentsConnection {
  """
  A list of `CompanyDocument` objects.
  """
  nodes: [CompanyDocument!]!

  """
  A list of edges which contains the `CompanyDocument` and cursor to aid in pagination.
  """
  edges: [CompanyDocumentsEdge!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `CompanyDocument` you could get from the connection.
  """
  totalCount: Int!
}

"""
A document uploaded by the Company to InTouch that appears on their Company Profile, for example an insurance certificate
"""
type CompanyDocument implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Primary key
  """
  id: Int!

  """
  fk
  """
  companyId: Int

  """
  The reference to the document
  """
  document: String
  createdAt: Datetime!
  updatedAt: Datetime!

  """
  Reads a single `Company` that is related to this `CompanyDocument`.
  """
  company: Company
}

"""
A `CompanyDocument` edge in the connection.
"""
type CompanyDocumentsEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `CompanyDocument` at the end of the edge.
  """
  node: CompanyDocument!
}

"""
Methods to use when ordering `CompanyDocument`.
"""
enum CompanyDocumentsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  COMPANY_ID_ASC
  COMPANY_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `CompanyDocument` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input CompanyDocumentCondition {
  """
  Checks for equality with the object’s `id` field.
  """
  id: Int

  """
  Checks for equality with the object’s `companyId` field.
  """
  companyId: Int
}

"""
A filter to be used against `CompanyDocument` object types. All fields are combined with a logical ‘and.’
"""
input CompanyDocumentFilter {
  """
  Filter by the object’s `id` field.
  """
  id: IntFilter

  """
  Filter by the object’s `companyId` field.
  """
  companyId: IntFilter

  """
  Checks for all expressions in this list.
  """
  and: [CompanyDocumentFilter!]

  """
  Checks for any expressions in this list.
  """
  or: [CompanyDocumentFilter!]

  """
  Negates the expression.
  """
  not: CompanyDocumentFilter
}

"""
A connection to a list of `CompanyMember` values.
"""
type CompanyMembersConnection {
  """
  A list of `CompanyMember` objects.
  """
  nodes: [CompanyMember!]!

  """
  A list of edges which contains the `CompanyMember` and cursor to aid in pagination.
  """
  edges: [CompanyMembersEdge!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `CompanyMember` you could get from the connection.
  """
  totalCount: Int!
}

"""
A connection between a user and a company
"""
type CompanyMember implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Primary key
  """
  id: Int!

  """
  fk
  """
  marketId: Int

  """
  fk
  """
  accountId: Int

  """
  fk
  """
  companyId: Int
  createdAt: Datetime!
  updatedAt: Datetime!

  """
  Reads a single `Market` that is related to this `CompanyMember`.
  """
  market: Market

  """
  Reads a single `Account` that is related to this `CompanyMember`.
  """
  account: Account

  """
  Reads a single `Company` that is related to this `CompanyMember`.
  """
  company: Company
}

"""
A `CompanyMember` edge in the connection.
"""
type CompanyMembersEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `CompanyMember` at the end of the edge.
  """
  node: CompanyMember!
}

"""
Methods to use when ordering `CompanyMember`.
"""
enum CompanyMembersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  MARKET_ID_ASC
  MARKET_ID_DESC
  ACCOUNT_ID_ASC
  ACCOUNT_ID_DESC
  COMPANY_ID_ASC
  COMPANY_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `CompanyMember` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input CompanyMemberCondition {
  """
  Checks for equality with the object’s `id` field.
  """
  id: Int

  """
  Checks for equality with the object’s `marketId` field.
  """
  marketId: Int

  """
  Checks for equality with the object’s `accountId` field.
  """
  accountId: Int

  """
  Checks for equality with the object’s `companyId` field.
  """
  companyId: Int
}

"""
A filter to be used against `CompanyMember` object types. All fields are combined with a logical ‘and.’
"""
input CompanyMemberFilter {
  """
  Filter by the object’s `id` field.
  """
  id: IntFilter

  """
  Filter by the object’s `marketId` field.
  """
  marketId: IntFilter

  """
  Filter by the object’s `accountId` field.
  """
  accountId: IntFilter

  """
  Filter by the object’s `companyId` field.
  """
  companyId: IntFilter

  """
  Checks for all expressions in this list.
  """
  and: [CompanyMemberFilter!]

  """
  Checks for any expressions in this list.
  """
  or: [CompanyMemberFilter!]

  """
  Negates the expression.
  """
  not: CompanyMemberFilter
}

"""
A connection to a list of `CompanyOperation` values.
"""
type CompanyOperationsConnection {
  """
  A list of `CompanyOperation` objects.
  """
  nodes: [CompanyOperation!]!

  """
  A list of edges which contains the `CompanyOperation` and cursor to aid in pagination.
  """
  edges: [CompanyOperationsEdge!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `CompanyOperation` you could get from the connection.
  """
  totalCount: Int!
}

"""
The assignment of an operation type to a Company by the Market Admin.  A Company can be assigned multiple types from the allowed enums list.  The operation types that a Company has are sent to Find a Roofer.
"""
type CompanyOperation implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Primary key
  """
  id: Int!

  """
  fk
  """
  company: Int

  """
  ek
  """
  operation: Operation
  createdAt: Datetime!
  updatedAt: Datetime!

  """
  Reads a single `Company` that is related to this `CompanyOperation`.
  """
  companyByCompany: Company
}

enum Operation {
  FLAT
  PITCHED
  SOLAR
  BITUMEN
  TILE
  COATER
  GREEN
}

"""
A `CompanyOperation` edge in the connection.
"""
type CompanyOperationsEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `CompanyOperation` at the end of the edge.
  """
  node: CompanyOperation!
}

"""
Methods to use when ordering `CompanyOperation`.
"""
enum CompanyOperationsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  COMPANY_ASC
  COMPANY_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `CompanyOperation` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input CompanyOperationCondition {
  """
  Checks for equality with the object’s `id` field.
  """
  id: Int

  """
  Checks for equality with the object’s `company` field.
  """
  company: Int
}

"""
A filter to be used against `CompanyOperation` object types. All fields are combined with a logical ‘and.’
"""
input CompanyOperationFilter {
  """
  Filter by the object’s `id` field.
  """
  id: IntFilter

  """
  Filter by the object’s `company` field.
  """
  company: IntFilter

  """
  Checks for all expressions in this list.
  """
  and: [CompanyOperationFilter!]

  """
  Checks for any expressions in this list.
  """
  or: [CompanyOperationFilter!]

  """
  Negates the expression.
  """
  not: CompanyOperationFilter
}

"""
A connection to a list of `Invitation` values.
"""
type InvitationsConnection {
  """
  A list of `Invitation` objects.
  """
  nodes: [Invitation!]!

  """
  A list of edges which contains the `Invitation` and cursor to aid in pagination.
  """
  edges: [InvitationsEdge!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Invitation` you could get from the connection.
  """
  totalCount: Int!
}

"""
An invitation to join InTouch
"""
type Invitation implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Primary key
  """
  id: Int!

  """
  fk
  """
  senderAccountId: Int

  """
  fk
  """
  companyId: Int

  """
  ek
  """
  status: InvitationStatus

  """
  An email address
  """
  invitee: String!

  """
  An optional note that can be included in the invitation by the sender
  """
  personalNote: String
  createdAt: Datetime!
  updatedAt: Datetime!

  """
  Reads a single `Account` that is related to this `Invitation`.
  """
  senderAccount: Account

  """
  Reads a single `Company` that is related to this `Invitation`.
  """
  company: Company
}

enum InvitationStatus {
  NEW
  ACCEPTED
  CANCELLED
}

"""
A `Invitation` edge in the connection.
"""
type InvitationsEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Invitation` at the end of the edge.
  """
  node: Invitation!
}

"""
Methods to use when ordering `Invitation`.
"""
enum InvitationsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  SENDER_ACCOUNT_ID_ASC
  SENDER_ACCOUNT_ID_DESC
  COMPANY_ID_ASC
  COMPANY_ID_DESC
  STATUS_ASC
  STATUS_DESC
  INVITEE_ASC
  INVITEE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Invitation` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input InvitationCondition {
  """
  Checks for equality with the object’s `id` field.
  """
  id: Int

  """
  Checks for equality with the object’s `senderAccountId` field.
  """
  senderAccountId: Int

  """
  Checks for equality with the object’s `companyId` field.
  """
  companyId: Int

  """
  Checks for equality with the object’s `status` field.
  """
  status: InvitationStatus

  """
  Checks for equality with the object’s `invitee` field.
  """
  invitee: String
}

"""
A filter to be used against `Invitation` object types. All fields are combined with a logical ‘and.’
"""
input InvitationFilter {
  """
  Filter by the object’s `id` field.
  """
  id: IntFilter

  """
  Filter by the object’s `senderAccountId` field.
  """
  senderAccountId: IntFilter

  """
  Filter by the object’s `companyId` field.
  """
  companyId: IntFilter

  """
  Filter by the object’s `status` field.
  """
  status: InvitationStatusFilter

  """
  Filter by the object’s `invitee` field.
  """
  invitee: StringFilter

  """
  Checks for all expressions in this list.
  """
  and: [InvitationFilter!]

  """
  Checks for any expressions in this list.
  """
  or: [InvitationFilter!]

  """
  Negates the expression.
  """
  not: InvitationFilter
}

"""
A filter to be used against InvitationStatus fields. All fields are combined with a logical ‘and.’
"""
input InvitationStatusFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """
  Equal to the specified value.
  """
  equalTo: InvitationStatus

  """
  Not equal to the specified value.
  """
  notEqualTo: InvitationStatus

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: InvitationStatus

  """
  Equal to the specified value, treating null like an ordinary value.
  """
  notDistinctFrom: InvitationStatus

  """
  Included in the specified list.
  """
  in: [InvitationStatus!]

  """
  Not included in the specified list.
  """
  notIn: [InvitationStatus!]

  """
  Less than the specified value.
  """
  lessThan: InvitationStatus

  """
  Less than or equal to the specified value.
  """
  lessThanOrEqualTo: InvitationStatus

  """
  Greater than the specified value.
  """
  greaterThan: InvitationStatus

  """
  Greater than or equal to the specified value.
  """
  greaterThanOrEqualTo: InvitationStatus
}

"""
A `Company` edge in the connection.
"""
type CompaniesEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Company` at the end of the edge.
  """
  node: Company!
}

"""
A connection to a list of `Product` values.
"""
type ProductsConnection {
  """
  A list of `Product` objects.
  """
  nodes: [Product!]!

  """
  A list of edges which contains the `Product` and cursor to aid in pagination.
  """
  edges: [ProductsEdge!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Product` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `Product` edge in the connection.
"""
type ProductsEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Product` at the end of the edge.
  """
  node: Product!
}

"""
Methods to use when ordering `Product`.
"""
enum ProductsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  MARKET_ID_ASC
  MARKET_ID_DESC
  BMI_REF_ASC
  BMI_REF_DESC
  NAME_ASC
  NAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Product` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input ProductCondition {
  """
  Checks for equality with the object’s `id` field.
  """
  id: Int

  """
  Checks for equality with the object’s `marketId` field.
  """
  marketId: Int

  """
  Checks for equality with the object’s `bmiRef` field.
  """
  bmiRef: String

  """
  Checks for equality with the object’s `name` field.
  """
  name: String
}

"""
A filter to be used against `Product` object types. All fields are combined with a logical ‘and.’
"""
input ProductFilter {
  """
  Filter by the object’s `id` field.
  """
  id: IntFilter

  """
  Filter by the object’s `marketId` field.
  """
  marketId: IntFilter

  """
  Filter by the object’s `bmiRef` field.
  """
  bmiRef: StringFilter

  """
  Filter by the object’s `name` field.
  """
  name: StringFilter

  """
  Checks for all expressions in this list.
  """
  and: [ProductFilter!]

  """
  Checks for any expressions in this list.
  """
  or: [ProductFilter!]

  """
  Negates the expression.
  """
  not: ProductFilter
}

"""
A connection to a list of `System` values.
"""
type SystemsConnection {
  """
  A list of `System` objects.
  """
  nodes: [System!]!

  """
  A list of edges which contains the `System` and cursor to aid in pagination.
  """
  edges: [SystemsEdge!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `System` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `System` edge in the connection.
"""
type SystemsEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `System` at the end of the edge.
  """
  node: System!
}

"""
Methods to use when ordering `System`.
"""
enum SystemsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  MARKET_ID_ASC
  MARKET_ID_DESC
  BMI_REF_ASC
  BMI_REF_DESC
  NAME_ASC
  NAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `System` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input SystemCondition {
  """
  Checks for equality with the object’s `id` field.
  """
  id: Int

  """
  Checks for equality with the object’s `marketId` field.
  """
  marketId: Int

  """
  Checks for equality with the object’s `bmiRef` field.
  """
  bmiRef: String

  """
  Checks for equality with the object’s `name` field.
  """
  name: String
}

"""
A filter to be used against `System` object types. All fields are combined with a logical ‘and.’
"""
input SystemFilter {
  """
  Filter by the object’s `id` field.
  """
  id: IntFilter

  """
  Filter by the object’s `marketId` field.
  """
  marketId: IntFilter

  """
  Filter by the object’s `bmiRef` field.
  """
  bmiRef: StringFilter

  """
  Filter by the object’s `name` field.
  """
  name: StringFilter

  """
  Checks for all expressions in this list.
  """
  and: [SystemFilter!]

  """
  Checks for any expressions in this list.
  """
  or: [SystemFilter!]

  """
  Negates the expression.
  """
  not: SystemFilter
}

"""
A connection to a list of `Certification` values.
"""
type CertificationsConnection {
  """
  A list of `Certification` objects.
  """
  nodes: [Certification!]!

  """
  A list of edges which contains the `Certification` and cursor to aid in pagination.
  """
  edges: [CertificationsEdge!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Certification` you could get from the connection.
  """
  totalCount: Int!
}

"""
A company that has been registered in InTouch
"""
type Certification implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Primary key
  """
  id: Int!

  """
  fk
  """
  doceboUserId: Int

  """
  technology
  """
  technology: String

  """
  The name of the certification according to Docebo
  """
  name: String

  """
  The last day that this certification is valid
  """
  expiryDate: Datetime
  createdAt: Datetime!
  updatedAt: Datetime!

  """
  Reads a single `Account` that is related to this `Certification`.
  """
  doceboUser: Account
}

"""
A `Certification` edge in the connection.
"""
type CertificationsEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Certification` at the end of the edge.
  """
  node: Certification!
}

"""
Methods to use when ordering `Certification`.
"""
enum CertificationsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  DOCEBO_USER_ID_ASC
  DOCEBO_USER_ID_DESC
  TECHNOLOGY_ASC
  TECHNOLOGY_DESC
  EXPIRY_DATE_ASC
  EXPIRY_DATE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Certification` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input CertificationCondition {
  """
  Checks for equality with the object’s `id` field.
  """
  id: Int

  """
  Checks for equality with the object’s `doceboUserId` field.
  """
  doceboUserId: Int

  """
  Checks for equality with the object’s `technology` field.
  """
  technology: String

  """
  Checks for equality with the object’s `expiryDate` field.
  """
  expiryDate: Datetime
}

"""
A filter to be used against `Certification` object types. All fields are combined with a logical ‘and.’
"""
input CertificationFilter {
  """
  Filter by the object’s `id` field.
  """
  id: IntFilter

  """
  Filter by the object’s `doceboUserId` field.
  """
  doceboUserId: IntFilter

  """
  Filter by the object’s `technology` field.
  """
  technology: StringFilter

  """
  Filter by the object’s `expiryDate` field.
  """
  expiryDate: DatetimeFilter

  """
  Checks for all expressions in this list.
  """
  and: [CertificationFilter!]

  """
  Checks for any expressions in this list.
  """
  or: [CertificationFilter!]

  """
  Negates the expression.
  """
  not: CertificationFilter
}

"""
A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’
"""
input DatetimeFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """
  Equal to the specified value.
  """
  equalTo: Datetime

  """
  Not equal to the specified value.
  """
  notEqualTo: Datetime

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Datetime

  """
  Equal to the specified value, treating null like an ordinary value.
  """
  notDistinctFrom: Datetime

  """
  Included in the specified list.
  """
  in: [Datetime!]

  """
  Not included in the specified list.
  """
  notIn: [Datetime!]

  """
  Less than the specified value.
  """
  lessThan: Datetime

  """
  Less than or equal to the specified value.
  """
  lessThanOrEqualTo: Datetime

  """
  Greater than the specified value.
  """
  greaterThan: Datetime

  """
  Greater than or equal to the specified value.
  """
  greaterThanOrEqualTo: Datetime
}

"""
A connection to a list of `Notification` values.
"""
type NotificationsConnection {
  """
  A list of `Notification` objects.
  """
  nodes: [Notification!]!

  """
  A list of edges which contains the `Notification` and cursor to aid in pagination.
  """
  edges: [NotificationsEdge!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Notification` you could get from the connection.
  """
  totalCount: Int!
}

"""
An internal notification available to an end user
"""
type Notification implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Primary key
  """
  id: Int!

  """
  fk
  """
  accountId: Int

  """
  The datetime stamp for when the message was sent
  """
  sendDate: Datetime!

  """
  Whether the message has been read
  """
  read: Boolean!

  """
  The body of the message
  """
  body: String
  createdAt: Datetime!
  updatedAt: Datetime!

  """
  Reads a single `Account` that is related to this `Notification`.
  """
  account: Account
}

"""
A `Notification` edge in the connection.
"""
type NotificationsEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Notification` at the end of the edge.
  """
  node: Notification!
}

"""
Methods to use when ordering `Notification`.
"""
enum NotificationsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  ACCOUNT_ID_ASC
  ACCOUNT_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Notification` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input NotificationCondition {
  """
  Checks for equality with the object’s `id` field.
  """
  id: Int

  """
  Checks for equality with the object’s `accountId` field.
  """
  accountId: Int
}

"""
A filter to be used against `Notification` object types. All fields are combined with a logical ‘and.’
"""
input NotificationFilter {
  """
  Filter by the object’s `id` field.
  """
  id: IntFilter

  """
  Filter by the object’s `accountId` field.
  """
  accountId: IntFilter

  """
  Checks for all expressions in this list.
  """
  and: [NotificationFilter!]

  """
  Checks for any expressions in this list.
  """
  or: [NotificationFilter!]

  """
  Negates the expression.
  """
  not: NotificationFilter
}

"""
A `Account` edge in the connection.
"""
type AccountsEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Account` at the end of the edge.
  """
  node: Account!
}

"""
A connection to a list of `Address` values.
"""
type AddressesConnection {
  """
  A list of `Address` objects.
  """
  nodes: [Address!]!

  """
  A list of edges which contains the `Address` and cursor to aid in pagination.
  """
  edges: [AddressesEdge!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Address` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `Address` edge in the connection.
"""
type AddressesEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Address` at the end of the edge.
  """
  node: Address!
}

"""
Methods to use when ordering `Address`.
"""
enum AddressesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Address` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input AddressCondition {
  """
  Checks for equality with the object’s `id` field.
  """
  id: Int
}

"""
A filter to be used against `Address` object types. All fields are combined with a logical ‘and.’
"""
input AddressFilter {
  """
  Filter by the object’s `id` field.
  """
  id: IntFilter

  """
  Checks for all expressions in this list.
  """
  and: [AddressFilter!]

  """
  Checks for any expressions in this list.
  """
  or: [AddressFilter!]

  """
  Negates the expression.
  """
  not: AddressFilter
}

"""
A connection to a list of `Market` values.
"""
type MarketsConnection {
  """
  A list of `Market` objects.
  """
  nodes: [Market!]!

  """
  A list of edges which contains the `Market` and cursor to aid in pagination.
  """
  edges: [MarketsEdge!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Market` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `Market` edge in the connection.
"""
type MarketsEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Market` at the end of the edge.
  """
  node: Market!
}

"""
Methods to use when ordering `Market`.
"""
enum MarketsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  DOMAIN_ASC
  DOMAIN_DESC
  DOCEBO_CATALOGUE_ID_ASC
  DOCEBO_CATALOGUE_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Market` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input MarketCondition {
  """
  Checks for equality with the object’s `id` field.
  """
  id: Int

  """
  Checks for equality with the object’s `domain` field.
  """
  domain: String

  """
  Checks for equality with the object’s `doceboCatalogueId` field.
  """
  doceboCatalogueId: Int
}

"""
A filter to be used against `Market` object types. All fields are combined with a logical ‘and.’
"""
input MarketFilter {
  """
  Filter by the object’s `id` field.
  """
  id: IntFilter

  """
  Filter by the object’s `domain` field.
  """
  domain: StringFilter

  """
  Filter by the object’s `doceboCatalogueId` field.
  """
  doceboCatalogueId: IntFilter

  """
  Checks for all expressions in this list.
  """
  and: [MarketFilter!]

  """
  Checks for any expressions in this list.
  """
  or: [MarketFilter!]

  """
  Negates the expression.
  """
  not: MarketFilter
}

"""
A connection to a list of `Int` values.
"""
type InvitedByCompaniesConnection {
  """
  A list of `Int` objects.
  """
  nodes: [Int]!

  """
  A list of edges which contains the `Int` and cursor to aid in pagination.
  """
  edges: [InvitedByCompanyEdge!]!

  """
  The count of *all* `Int` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `Int` edge in the connection.
"""
type InvitedByCompanyEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Int` at the end of the edge.
  """
  node: Int
}

"""
A connection to a list of `Int` values.
"""
type IsPartOfProjectConnection {
  """
  A list of `Int` objects.
  """
  nodes: [Int]!

  """
  A list of edges which contains the `Int` and cursor to aid in pagination.
  """
  edges: [IsPartOfProjectEdge!]!

  """
  The count of *all* `Int` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `Int` edge in the connection.
"""
type IsPartOfProjectEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Int` at the end of the edge.
  """
  node: Int
}

"""
A union of all federated types (those that use the @key directive).
"""
union _Entity =
    Account
  | Market
  | Company
  | Address
  | Project
  | EvidenceItem
  | Guarantee
  | System
  | SystemMember
  | Product
  | Note
  | ProjectMember
  | CompanyDocument
  | CompanyMember
  | CompanyOperation
  | Invitation
  | Certification
  | Notification

scalar _Any

"""
Describes our federated service.
"""
type _Service {
  """
  The GraphQL Schema Language definiton of our endpoint including the
  Apollo Federation directives (but not their definitions or the special
  Apollo Federation fields).
  """
  sdl: String @deprecated(reason: "Only Apollo Federation should use this")
}

"""
The root mutation type which contains root level fields which mutate data.
"""
type Mutation {
  """
  Creates a single `Address`.
  """
  createAddress(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateAddressInput!
  ): CreateAddressPayload

  """
  Creates a single `Certification`.
  """
  createCertification(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCertificationInput!
  ): CreateCertificationPayload

  """
  Creates a single `CompanyDocument`.
  """
  createCompanyDocument(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCompanyDocumentInput!
  ): CreateCompanyDocumentPayload

  """
  Creates a single `CompanyMember`.
  """
  createCompanyMember(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCompanyMemberInput!
  ): CreateCompanyMemberPayload

  """
  Creates a single `CompanyOperation`.
  """
  createCompanyOperation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCompanyOperationInput!
  ): CreateCompanyOperationPayload

  """
  Creates a single `EvidenceItem`.
  """
  createEvidenceItem(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateEvidenceItemInput!
  ): CreateEvidenceItemPayload

  """
  Creates a single `Guarantee`.
  """
  createGuarantee(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateGuaranteeInput!
  ): CreateGuaranteePayload

  """
  Creates a single `Market`.
  """
  createMarket(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateMarketInput!
  ): CreateMarketPayload

  """
  Creates a single `Note`.
  """
  createNote(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateNoteInput!
  ): CreateNotePayload

  """
  Creates a single `Notification`.
  """
  createNotification(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateNotificationInput!
  ): CreateNotificationPayload

  """
  Creates a single `Product`.
  """
  createProduct(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateProductInput!
  ): CreateProductPayload

  """
  Creates a single `Project`.
  """
  createProject(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateProjectInput!
  ): CreateProjectPayload

  """
  Creates a single `ProjectMember`.
  """
  createProjectMember(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateProjectMemberInput!
  ): CreateProjectMemberPayload

  """
  Creates a single `System`.
  """
  createSystem(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateSystemInput!
  ): CreateSystemPayload

  """
  Creates a single `SystemMember`.
  """
  createSystemMember(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateSystemMemberInput!
  ): CreateSystemMemberPayload

  """
  Updates a single `Account` using its globally unique id and a patch.
  """
  updateAccountByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAccountByNodeIdInput!
  ): UpdateAccountPayload

  """
  Updates a single `Account` using a unique key and a patch.
  """
  updateAccount(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAccountInput!
  ): UpdateAccountPayload

  """
  Updates a single `Account` using a unique key and a patch.
  """
  updateAccountByEmail(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAccountByEmailInput!
  ): UpdateAccountPayload

  """
  Updates a single `Account` using a unique key and a patch.
  """
  updateAccountByDoceboUserId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAccountByDoceboUserIdInput!
  ): UpdateAccountPayload

  """
  Updates a single `Address` using its globally unique id and a patch.
  """
  updateAddressByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAddressByNodeIdInput!
  ): UpdateAddressPayload

  """
  Updates a single `Address` using a unique key and a patch.
  """
  updateAddress(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAddressInput!
  ): UpdateAddressPayload

  """
  Updates a single `Certification` using its globally unique id and a patch.
  """
  updateCertificationByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCertificationByNodeIdInput!
  ): UpdateCertificationPayload

  """
  Updates a single `Certification` using a unique key and a patch.
  """
  updateCertification(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCertificationInput!
  ): UpdateCertificationPayload

  """
  Updates a single `Company` using its globally unique id and a patch.
  """
  updateCompanyByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCompanyByNodeIdInput!
  ): UpdateCompanyPayload

  """
  Updates a single `Company` using a unique key and a patch.
  """
  updateCompany(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCompanyInput!
  ): UpdateCompanyPayload

  """
  Updates a single `Company` using a unique key and a patch.
  """
  updateCompanyByName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCompanyByNameInput!
  ): UpdateCompanyPayload

  """
  Updates a single `Company` using a unique key and a patch.
  """
  updateCompanyByReferenceNumber(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCompanyByReferenceNumberInput!
  ): UpdateCompanyPayload

  """
  Updates a single `CompanyDocument` using its globally unique id and a patch.
  """
  updateCompanyDocumentByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCompanyDocumentByNodeIdInput!
  ): UpdateCompanyDocumentPayload

  """
  Updates a single `CompanyDocument` using a unique key and a patch.
  """
  updateCompanyDocument(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCompanyDocumentInput!
  ): UpdateCompanyDocumentPayload

  """
  Updates a single `CompanyMember` using its globally unique id and a patch.
  """
  updateCompanyMemberByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCompanyMemberByNodeIdInput!
  ): UpdateCompanyMemberPayload

  """
  Updates a single `CompanyMember` using a unique key and a patch.
  """
  updateCompanyMember(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCompanyMemberInput!
  ): UpdateCompanyMemberPayload

  """
  Updates a single `CompanyMember` using a unique key and a patch.
  """
  updateCompanyMemberByMarketIdAndAccountIdAndCompanyId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCompanyMemberByMarketIdAndAccountIdAndCompanyIdInput!
  ): UpdateCompanyMemberPayload

  """
  Updates a single `CompanyOperation` using its globally unique id and a patch.
  """
  updateCompanyOperationByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCompanyOperationByNodeIdInput!
  ): UpdateCompanyOperationPayload

  """
  Updates a single `CompanyOperation` using a unique key and a patch.
  """
  updateCompanyOperation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCompanyOperationInput!
  ): UpdateCompanyOperationPayload

  """
  Updates a single `EvidenceItem` using its globally unique id and a patch.
  """
  updateEvidenceItemByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateEvidenceItemByNodeIdInput!
  ): UpdateEvidenceItemPayload

  """
  Updates a single `EvidenceItem` using a unique key and a patch.
  """
  updateEvidenceItem(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateEvidenceItemInput!
  ): UpdateEvidenceItemPayload

  """
  Updates a single `Guarantee` using its globally unique id and a patch.
  """
  updateGuaranteeByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateGuaranteeByNodeIdInput!
  ): UpdateGuaranteePayload

  """
  Updates a single `Guarantee` using a unique key and a patch.
  """
  updateGuarantee(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateGuaranteeInput!
  ): UpdateGuaranteePayload

  """
  Updates a single `Guarantee` using a unique key and a patch.
  """
  updateGuaranteeByBmiReferenceId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateGuaranteeByBmiReferenceIdInput!
  ): UpdateGuaranteePayload

  """
  Updates a single `Invitation` using its globally unique id and a patch.
  """
  updateInvitationByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateInvitationByNodeIdInput!
  ): UpdateInvitationPayload

  """
  Updates a single `Invitation` using a unique key and a patch.
  """
  updateInvitation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateInvitationInput!
  ): UpdateInvitationPayload

  """
  Updates a single `Market` using its globally unique id and a patch.
  """
  updateMarketByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateMarketByNodeIdInput!
  ): UpdateMarketPayload

  """
  Updates a single `Market` using a unique key and a patch.
  """
  updateMarket(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateMarketInput!
  ): UpdateMarketPayload

  """
  Updates a single `Market` using a unique key and a patch.
  """
  updateMarketByDomain(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateMarketByDomainInput!
  ): UpdateMarketPayload

  """
  Updates a single `Market` using a unique key and a patch.
  """
  updateMarketByDoceboCatalogueId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateMarketByDoceboCatalogueIdInput!
  ): UpdateMarketPayload

  """
  Updates a single `Note` using its globally unique id and a patch.
  """
  updateNoteByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateNoteByNodeIdInput!
  ): UpdateNotePayload

  """
  Updates a single `Note` using a unique key and a patch.
  """
  updateNote(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateNoteInput!
  ): UpdateNotePayload

  """
  Updates a single `Notification` using its globally unique id and a patch.
  """
  updateNotificationByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateNotificationByNodeIdInput!
  ): UpdateNotificationPayload

  """
  Updates a single `Notification` using a unique key and a patch.
  """
  updateNotification(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateNotificationInput!
  ): UpdateNotificationPayload

  """
  Updates a single `Product` using its globally unique id and a patch.
  """
  updateProductByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProductByNodeIdInput!
  ): UpdateProductPayload

  """
  Updates a single `Product` using a unique key and a patch.
  """
  updateProduct(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProductInput!
  ): UpdateProductPayload

  """
  Updates a single `Product` using a unique key and a patch.
  """
  updateProductByBmiRef(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProductByBmiRefInput!
  ): UpdateProductPayload

  """
  Updates a single `Project` using its globally unique id and a patch.
  """
  updateProjectByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProjectByNodeIdInput!
  ): UpdateProjectPayload

  """
  Updates a single `Project` using a unique key and a patch.
  """
  updateProject(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProjectInput!
  ): UpdateProjectPayload

  """
  Updates a single `ProjectMember` using its globally unique id and a patch.
  """
  updateProjectMemberByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProjectMemberByNodeIdInput!
  ): UpdateProjectMemberPayload

  """
  Updates a single `ProjectMember` using a unique key and a patch.
  """
  updateProjectMember(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProjectMemberInput!
  ): UpdateProjectMemberPayload

  """
  Updates a single `System` using its globally unique id and a patch.
  """
  updateSystemByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSystemByNodeIdInput!
  ): UpdateSystemPayload

  """
  Updates a single `System` using a unique key and a patch.
  """
  updateSystem(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSystemInput!
  ): UpdateSystemPayload

  """
  Updates a single `System` using a unique key and a patch.
  """
  updateSystemByBmiRef(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSystemByBmiRefInput!
  ): UpdateSystemPayload

  """
  Updates a single `SystemMember` using its globally unique id and a patch.
  """
  updateSystemMemberByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSystemMemberByNodeIdInput!
  ): UpdateSystemMemberPayload

  """
  Updates a single `SystemMember` using a unique key and a patch.
  """
  updateSystemMember(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSystemMemberInput!
  ): UpdateSystemMemberPayload

  """
  Updates a single `SystemMember` using a unique key and a patch.
  """
  updateSystemMemberBySystemBmiRefAndProductBmiRefAndMarketId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSystemMemberBySystemBmiRefAndProductBmiRefAndMarketIdInput!
  ): UpdateSystemMemberPayload

  """
  Deletes a single `Account` using its globally unique id.
  """
  deleteAccountByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAccountByNodeIdInput!
  ): DeleteAccountPayload

  """
  Deletes a single `Account` using a unique key.
  """
  deleteAccount(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAccountInput!
  ): DeleteAccountPayload

  """
  Deletes a single `Account` using a unique key.
  """
  deleteAccountByEmail(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAccountByEmailInput!
  ): DeleteAccountPayload

  """
  Deletes a single `Account` using a unique key.
  """
  deleteAccountByDoceboUserId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAccountByDoceboUserIdInput!
  ): DeleteAccountPayload

  """
  Deletes a single `Address` using its globally unique id.
  """
  deleteAddressByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAddressByNodeIdInput!
  ): DeleteAddressPayload

  """
  Deletes a single `Address` using a unique key.
  """
  deleteAddress(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAddressInput!
  ): DeleteAddressPayload

  """
  Deletes a single `Certification` using its globally unique id.
  """
  deleteCertificationByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCertificationByNodeIdInput!
  ): DeleteCertificationPayload

  """
  Deletes a single `Certification` using a unique key.
  """
  deleteCertification(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCertificationInput!
  ): DeleteCertificationPayload

  """
  Deletes a single `Company` using its globally unique id.
  """
  deleteCompanyByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCompanyByNodeIdInput!
  ): DeleteCompanyPayload

  """
  Deletes a single `Company` using a unique key.
  """
  deleteCompany(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCompanyInput!
  ): DeleteCompanyPayload

  """
  Deletes a single `Company` using a unique key.
  """
  deleteCompanyByName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCompanyByNameInput!
  ): DeleteCompanyPayload

  """
  Deletes a single `Company` using a unique key.
  """
  deleteCompanyByReferenceNumber(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCompanyByReferenceNumberInput!
  ): DeleteCompanyPayload

  """
  Deletes a single `CompanyDocument` using its globally unique id.
  """
  deleteCompanyDocumentByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCompanyDocumentByNodeIdInput!
  ): DeleteCompanyDocumentPayload

  """
  Deletes a single `CompanyDocument` using a unique key.
  """
  deleteCompanyDocument(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCompanyDocumentInput!
  ): DeleteCompanyDocumentPayload

  """
  Deletes a single `CompanyMember` using its globally unique id.
  """
  deleteCompanyMemberByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCompanyMemberByNodeIdInput!
  ): DeleteCompanyMemberPayload

  """
  Deletes a single `CompanyMember` using a unique key.
  """
  deleteCompanyMember(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCompanyMemberInput!
  ): DeleteCompanyMemberPayload

  """
  Deletes a single `CompanyMember` using a unique key.
  """
  deleteCompanyMemberByMarketIdAndAccountIdAndCompanyId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCompanyMemberByMarketIdAndAccountIdAndCompanyIdInput!
  ): DeleteCompanyMemberPayload

  """
  Deletes a single `CompanyOperation` using its globally unique id.
  """
  deleteCompanyOperationByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCompanyOperationByNodeIdInput!
  ): DeleteCompanyOperationPayload

  """
  Deletes a single `CompanyOperation` using a unique key.
  """
  deleteCompanyOperation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCompanyOperationInput!
  ): DeleteCompanyOperationPayload

  """
  Deletes a single `EvidenceItem` using its globally unique id.
  """
  deleteEvidenceItemByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteEvidenceItemByNodeIdInput!
  ): DeleteEvidenceItemPayload

  """
  Deletes a single `EvidenceItem` using a unique key.
  """
  deleteEvidenceItem(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteEvidenceItemInput!
  ): DeleteEvidenceItemPayload

  """
  Deletes a single `Guarantee` using its globally unique id.
  """
  deleteGuaranteeByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteGuaranteeByNodeIdInput!
  ): DeleteGuaranteePayload

  """
  Deletes a single `Guarantee` using a unique key.
  """
  deleteGuarantee(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteGuaranteeInput!
  ): DeleteGuaranteePayload

  """
  Deletes a single `Guarantee` using a unique key.
  """
  deleteGuaranteeByBmiReferenceId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteGuaranteeByBmiReferenceIdInput!
  ): DeleteGuaranteePayload

  """
  Deletes a single `Invitation` using its globally unique id.
  """
  deleteInvitationByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteInvitationByNodeIdInput!
  ): DeleteInvitationPayload

  """
  Deletes a single `Invitation` using a unique key.
  """
  deleteInvitation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteInvitationInput!
  ): DeleteInvitationPayload

  """
  Deletes a single `Market` using its globally unique id.
  """
  deleteMarketByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteMarketByNodeIdInput!
  ): DeleteMarketPayload

  """
  Deletes a single `Market` using a unique key.
  """
  deleteMarket(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteMarketInput!
  ): DeleteMarketPayload

  """
  Deletes a single `Market` using a unique key.
  """
  deleteMarketByDomain(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteMarketByDomainInput!
  ): DeleteMarketPayload

  """
  Deletes a single `Market` using a unique key.
  """
  deleteMarketByDoceboCatalogueId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteMarketByDoceboCatalogueIdInput!
  ): DeleteMarketPayload

  """
  Deletes a single `Note` using its globally unique id.
  """
  deleteNoteByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteNoteByNodeIdInput!
  ): DeleteNotePayload

  """
  Deletes a single `Note` using a unique key.
  """
  deleteNote(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteNoteInput!
  ): DeleteNotePayload

  """
  Deletes a single `Notification` using its globally unique id.
  """
  deleteNotificationByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteNotificationByNodeIdInput!
  ): DeleteNotificationPayload

  """
  Deletes a single `Notification` using a unique key.
  """
  deleteNotification(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteNotificationInput!
  ): DeleteNotificationPayload

  """
  Deletes a single `Product` using its globally unique id.
  """
  deleteProductByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProductByNodeIdInput!
  ): DeleteProductPayload

  """
  Deletes a single `Product` using a unique key.
  """
  deleteProduct(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProductInput!
  ): DeleteProductPayload

  """
  Deletes a single `Product` using a unique key.
  """
  deleteProductByBmiRef(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProductByBmiRefInput!
  ): DeleteProductPayload

  """
  Deletes a single `Project` using its globally unique id.
  """
  deleteProjectByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProjectByNodeIdInput!
  ): DeleteProjectPayload

  """
  Deletes a single `Project` using a unique key.
  """
  deleteProject(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProjectInput!
  ): DeleteProjectPayload

  """
  Deletes a single `ProjectMember` using its globally unique id.
  """
  deleteProjectMemberByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProjectMemberByNodeIdInput!
  ): DeleteProjectMemberPayload

  """
  Deletes a single `ProjectMember` using a unique key.
  """
  deleteProjectMember(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProjectMemberInput!
  ): DeleteProjectMemberPayload

  """
  Deletes a single `System` using its globally unique id.
  """
  deleteSystemByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSystemByNodeIdInput!
  ): DeleteSystemPayload

  """
  Deletes a single `System` using a unique key.
  """
  deleteSystem(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSystemInput!
  ): DeleteSystemPayload

  """
  Deletes a single `System` using a unique key.
  """
  deleteSystemByBmiRef(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSystemByBmiRefInput!
  ): DeleteSystemPayload

  """
  Deletes a single `SystemMember` using its globally unique id.
  """
  deleteSystemMemberByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSystemMemberByNodeIdInput!
  ): DeleteSystemMemberPayload

  """
  Deletes a single `SystemMember` using a unique key.
  """
  deleteSystemMember(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSystemMemberInput!
  ): DeleteSystemMemberPayload

  """
  Deletes a single `SystemMember` using a unique key.
  """
  deleteSystemMemberBySystemBmiRefAndProductBmiRefAndMarketId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSystemMemberBySystemBmiRefAndProductBmiRefAndMarketIdInput!
  ): DeleteSystemMemberPayload
  createAccount(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateAccountInput!
  ): CreateAccountPayload
  createCompany(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCompanyInput!
  ): CreateCompanyPayload
  evidenceItemsAdd(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: EvidenceItemsAddInput!
  ): EvidenceItemsAddPayload
  linkAccountToCompany(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: LinkAccountToCompanyInput!
  ): LinkAccountToCompanyPayload
  projectMembersAdd(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: ProjectMembersAddInput!
  ): ProjectMembersAddPayload
  resetPassword: String
  publishMessage(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: PublishInput!
  ): Publish
  createGuaranteePdf(id: Int!): PublishOutput
  invite(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: InviteInput!
  ): [Invitation]
  completeInvitation(companyId: Int!): Account
  bulkImport(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: BulkImportInput!
  ): ImportOutput
}

"""
The output of our create `Address` mutation.
"""
type CreateAddressPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Address` that was created by this mutation.
  """
  address: Address

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  An edge for our `Address`. May be used by Relay 1.
  """
  addressEdge(
    """
    The method to use when ordering `Address`.
    """
    orderBy: [AddressesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AddressesEdge
}

"""
All input for the create `Address` mutation.
"""
input CreateAddressInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `Address` to be created by this mutation.
  """
  address: AddressInput!
}

"""
An input for mutations affecting `Address`
"""
input AddressInput {
  """
  Primary key
  """
  id: Int

  """
  First line of this address
  """
  firstLine: String!

  """
  Second line of this address
  """
  secondLine: String

  """
  The postal town
  """
  town: String

  """
  The region if relevant
  """
  region: String

  """
  The country for this address
  """
  country: String

  """
  The postcode for this address
  """
  postcode: String!

  """
  The coordinates on a map of the world
  """
  coordinates: PointInput

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String
  createdAt: Datetime
  updatedAt: Datetime
  companiesToRegisteredAddressIdUsingId: CompanyRegisteredAddressIdFkeyInverseInput
  companiesToTradingAddressIdUsingId: CompanyTradingAddressIdFkeyInverseInput
  projectsToSiteAddressIdUsingId: ProjectSiteAddressIdFkeyInverseInput
  projectsToBuildingOwnerAddressIdUsingId: ProjectBuildingOwnerAddressIdFkeyInverseInput
}

input PointInput {
  x: Float!
  y: Float!
}

"""
Input for the nested mutation of `company` in the `AddressInput` mutation.
"""
input CompanyRegisteredAddressIdFkeyInverseInput {
  """
  Flag indicating whether all other `company` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectById: [CompanyCompanyPkeyConnect!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByName: [CompanyCompanyNameKeyConnect!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByReferenceNumber: [CompanyCompanyReferenceNumberKeyConnect!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByNodeId: [CompanyNodeIdConnect!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteById: [CompanyCompanyPkeyDelete!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByName: [CompanyCompanyNameKeyDelete!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByReferenceNumber: [CompanyCompanyReferenceNumberKeyDelete!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByNodeId: [CompanyNodeIdDelete!]

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateById: [CompanyOnCompanyForCompanyRegisteredAddressIdFkeyUsingCompanyPkeyUpdate!]

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByName: [CompanyOnCompanyForCompanyRegisteredAddressIdFkeyUsingCompanyNameKeyUpdate!]

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByReferenceNumber: [CompanyOnCompanyForCompanyRegisteredAddressIdFkeyUsingCompanyReferenceNumberKeyUpdate!]

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByNodeId: [AddressOnCompanyForCompanyRegisteredAddressIdFkeyNodeIdUpdate!]
}

"""
The fields on `company` to look up the row to connect.
"""
input CompanyCompanyPkeyConnect {
  """
  Primary key
  """
  id: Int!
}

"""
The fields on `company` to look up the row to connect.
"""
input CompanyCompanyNameKeyConnect {
  """
  The registered name of the Company
  """
  name: String!
}

"""
The fields on `company` to look up the row to connect.
"""
input CompanyCompanyReferenceNumberKeyConnect {
  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: String!
}

"""
The globally unique `ID` look up for the row to connect.
"""
input CompanyNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `company` to be connected.
  """
  nodeId: ID!
}

"""
The fields on `company` to look up the row to delete.
"""
input CompanyCompanyPkeyDelete {
  """
  Primary key
  """
  id: Int!
}

"""
The fields on `company` to look up the row to delete.
"""
input CompanyCompanyNameKeyDelete {
  """
  The registered name of the Company
  """
  name: String!
}

"""
The fields on `company` to look up the row to delete.
"""
input CompanyCompanyReferenceNumberKeyDelete {
  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: String!
}

"""
The globally unique `ID` look up for the row to delete.
"""
input CompanyNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `company` to be deleted.
  """
  nodeId: ID!
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnCompanyForCompanyRegisteredAddressIdFkeyUsingCompanyPkeyUpdate {
  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnCompanyForCompanyRegisteredAddressIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `company` being updated.
"""
input updateCompanyOnCompanyForCompanyRegisteredAddressIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int

  """
  fk
  """
  tradingAddressId: Int

  """
  the name of the owner of the Company
  """
  ownerFullname: String

  """
  the email address to contact the owner
  """
  ownerEmail: String

  """
  the phone number to contact the owner
  """
  ownerPhone: String

  """
  ek
  """
  businessType: BusinessType

  """
  ek
  """
  tier: Tier

  """
  ek
  """
  status: CompanyStatus

  """
  the email address of the person who filled out the company registration form
  """
  registeredBy: String

  """
  the date that the Company registration form was submitted
  """
  registeredDate: Datetime

  """
  The registered name of the Company
  """
  name: String

  """
  The Tax number in that Market, such as the VAT number
  """
  taxNumber: String

  """
  The Company public phone number
  """
  phone: String

  """
  A descirption of the Company intended for Find a Roofer
  """
  aboutUs: String

  """
  The email address that they can be contacted with by the public assuming they are listed
  """
  publicEmail: String

  """
  The Company website URL
  """
  website: String

  """
  The Company facebook website
  """
  facebook: String

  """
  Their Company LinkedIn page URL
  """
  linkedIn: String

  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: String

  """
  A reference to the logo image
  """
  logo: String

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String

  """
  Used for reference when importing data from the legacy system
  """
  tradingAddressMigrationId: String

  """
  Used for reference when importing data from the legacy system
  """
  registeredAddressMigrationId: String
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: CompanyMarketIdFkeyInput
  addressToRegisteredAddressId: CompanyRegisteredAddressIdFkeyInput
  addressToTradingAddressId: CompanyTradingAddressIdFkeyInput
  companyDocumentsUsingId: CompanyDocumentCompanyIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberCompanyIdFkeyInverseInput
  companyOperationsUsingId: CompanyOperationCompanyFkeyInverseInput
  invitationsUsingId: InvitationCompanyIdFkeyInverseInput
  projectsUsingId: ProjectCompanyIdFkeyInverseInput
  logoUpload: Upload
  shouldRemoveLogo: Boolean
}

"""
Input for the nested mutation of `market` in the `CompanyInput` mutation.
"""
input CompanyMarketIdFkeyInput {
  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectById: MarketMarketPkeyConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectByDomain: MarketMarketDomainKeyConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectByDoceboCatalogueId: MarketMarketDoceboCatalogueIdKeyConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectByNodeId: MarketNodeIdConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteById: MarketMarketPkeyDelete

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteByDomain: MarketMarketDomainKeyDelete

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteByDoceboCatalogueId: MarketMarketDoceboCatalogueIdKeyDelete

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteByNodeId: MarketNodeIdDelete

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateById: MarketOnCompanyForCompanyMarketIdFkeyUsingMarketPkeyUpdate

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateByDomain: MarketOnCompanyForCompanyMarketIdFkeyUsingMarketDomainKeyUpdate

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateByDoceboCatalogueId: MarketOnCompanyForCompanyMarketIdFkeyUsingMarketDoceboCatalogueIdKeyUpdate

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateByNodeId: CompanyOnCompanyForCompanyMarketIdFkeyNodeIdUpdate

  """
  A `MarketInput` object that will be created and connected to this object.
  """
  create: CompanyMarketIdFkeyMarketCreateInput
}

"""
The fields on `market` to look up the row to connect.
"""
input MarketMarketPkeyConnect {
  """
  Primary key
  """
  id: Int!
}

"""
The fields on `market` to look up the row to connect.
"""
input MarketMarketDomainKeyConnect {
  """
  the country code used for example as the subdomain
  """
  domain: String!
}

"""
The fields on `market` to look up the row to connect.
"""
input MarketMarketDoceboCatalogueIdKeyConnect {
  """
  The default catalogue for the market.  All users in the market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int!
}

"""
The globally unique `ID` look up for the row to connect.
"""
input MarketNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `market` to be connected.
  """
  nodeId: ID!
}

"""
The fields on `market` to look up the row to delete.
"""
input MarketMarketPkeyDelete {
  """
  Primary key
  """
  id: Int!
}

"""
The fields on `market` to look up the row to delete.
"""
input MarketMarketDomainKeyDelete {
  """
  the country code used for example as the subdomain
  """
  domain: String!
}

"""
The fields on `market` to look up the row to delete.
"""
input MarketMarketDoceboCatalogueIdKeyDelete {
  """
  The default catalogue for the market.  All users in the market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int!
}

"""
The globally unique `ID` look up for the row to delete.
"""
input MarketNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `market` to be deleted.
  """
  nodeId: ID!
}

"""
The fields on `market` to look up the row to update.
"""
input MarketOnCompanyForCompanyMarketIdFkeyUsingMarketPkeyUpdate {
  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: updateMarketOnCompanyForCompanyMarketIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `market` being updated.
"""
input updateMarketOnCompanyForCompanyMarketIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  ek
  """
  language: Language

  """
  the country code used for example as the subdomain
  """
  domain: String

  """
  The space in Contenful
  """
  cmsSpaceId: String

  """
  A short name for the market, e.g. Italy, Norway, Netherlands
  """
  name: String

  """
  The From name used when sending an email
  """
  sendName: String

  """
  The mailbox on intouch.bmigroup.com that emails will be sent from for this Market
  """
  sendMailbox: String

  """
  The default branch in Docebo that installers go into
  """
  doceboInstallersBranchId: String

  """
  The branch in Docebo that company admins go into
  """
  doceboCompanyAdminBranchId: String

  """
  The default catalogue for the market.  All users in the market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int

  """
  The address of the merchandising site for the market.  CTAs of the MERCHANDISING type will link to this address
  """
  merchandisingUrl: String

  """
  Whether the market supports Projects.  If so then the Projects link should be available in th left hand navigation.
  """
  projectsEnabled: Boolean

  """
  Reference to the Google Analytics tracking ID that is used for the Country GA reports
  """
  gtag: String

  """
  The coordinates of the middle of the Market on a map
  """
  geoMiddle: PointInput

  """
  The length of the radius in km (from the geo_middle lat/lng), for which the Google Places API biases the search results for address autocomplete. Locations outside of the radius will not be excluded.
  """
  locationBiasRadiusKm: Int
  createdAt: Datetime
  updatedAt: Datetime
  accountsUsingId: AccountMarketIdFkeyInverseInput
  companiesUsingId: CompanyMarketIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberMarketIdFkeyInverseInput
  productsUsingId: ProductMarketIdFkeyInverseInput
  systemsUsingId: SystemMarketIdFkeyInverseInput
  systemMembersUsingId: SystemMemberMarketIdFkeyInverseInput
}

"""
Input for the nested mutation of `account` in the `MarketInput` mutation.
"""
input AccountMarketIdFkeyInverseInput {
  """
  Flag indicating whether all other `account` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectById: [AccountAccountPkeyConnect!]

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByEmail: [AccountAccountEmailKeyConnect!]

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByDoceboUserId: [AccountAccountDoceboUserIdKeyConnect!]

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByNodeId: [AccountNodeIdConnect!]

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteById: [AccountAccountPkeyDelete!]

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByEmail: [AccountAccountEmailKeyDelete!]

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByDoceboUserId: [AccountAccountDoceboUserIdKeyDelete!]

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByNodeId: [AccountNodeIdDelete!]

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateById: [AccountOnAccountForAccountMarketIdFkeyUsingAccountPkeyUpdate!]

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByEmail: [AccountOnAccountForAccountMarketIdFkeyUsingAccountEmailKeyUpdate!]

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByDoceboUserId: [AccountOnAccountForAccountMarketIdFkeyUsingAccountDoceboUserIdKeyUpdate!]

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByNodeId: [MarketOnAccountForAccountMarketIdFkeyNodeIdUpdate!]
}

"""
The fields on `account` to look up the row to connect.
"""
input AccountAccountPkeyConnect {
  """
  Primary key
  """
  id: Int!
}

"""
The fields on `account` to look up the row to connect.
"""
input AccountAccountEmailKeyConnect {
  """
  The email address associated with the account
  """
  email: String!
}

"""
The fields on `account` to look up the row to connect.
"""
input AccountAccountDoceboUserIdKeyConnect {
  """
  User account in Docebo
  """
  doceboUserId: Int!
}

"""
The globally unique `ID` look up for the row to connect.
"""
input AccountNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `account` to be connected.
  """
  nodeId: ID!
}

"""
The fields on `account` to look up the row to delete.
"""
input AccountAccountPkeyDelete {
  """
  Primary key
  """
  id: Int!
}

"""
The fields on `account` to look up the row to delete.
"""
input AccountAccountEmailKeyDelete {
  """
  The email address associated with the account
  """
  email: String!
}

"""
The fields on `account` to look up the row to delete.
"""
input AccountAccountDoceboUserIdKeyDelete {
  """
  User account in Docebo
  """
  doceboUserId: Int!
}

"""
The globally unique `ID` look up for the row to delete.
"""
input AccountNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `account` to be deleted.
  """
  nodeId: ID!
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnAccountForAccountMarketIdFkeyUsingAccountPkeyUpdate {
  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnAccountForAccountMarketIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `account` being updated.
"""
input updateAccountOnAccountForAccountMarketIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  ek
  """
  status: AccountStatus

  """
  ek
  """
  role: Role

  """
  The email address associated with the account
  """
  email: String

  """
  A phone number that can optionally be provided, and is useful for Company Admin people to provide
  """
  phone: String

  """
  First name
  """
  firstName: String

  """
  Last name
  """
  lastName: String

  """
  When the account was created
  """
  created: Datetime

  """
  User account in Docebo
  """
  doceboUserId: Int

  """
  Username in Docebo.  Needed to generate the SSO link
  """
  doceboUsername: String

  """
  File reference. A profile picture of the user
  """
  photo: String

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: AccountMarketIdFkeyInput
  certificationsUsingDoceboUserId: CertificationDoceboUserIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberAccountIdFkeyInverseInput
  guaranteesToRequestorAccountIdUsingId: GuaranteeRequestorAccountIdFkeyInverseInput
  guaranteesToReviewerAccountIdUsingId: GuaranteeReviewerAccountIdFkeyInverseInput
  invitationsUsingId: InvitationSenderAccountIdFkeyInverseInput
  notesUsingId: NoteAuthorIdFkeyInverseInput
  notificationsUsingId: NotificationAccountIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberAccountIdFkeyInverseInput
  photoUpload: Upload
  shouldRemovePhoto: Boolean
}

"""
Input for the nested mutation of `market` in the `AccountInput` mutation.
"""
input AccountMarketIdFkeyInput {
  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectById: MarketMarketPkeyConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectByDomain: MarketMarketDomainKeyConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectByDoceboCatalogueId: MarketMarketDoceboCatalogueIdKeyConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectByNodeId: MarketNodeIdConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteById: MarketMarketPkeyDelete

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteByDomain: MarketMarketDomainKeyDelete

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteByDoceboCatalogueId: MarketMarketDoceboCatalogueIdKeyDelete

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteByNodeId: MarketNodeIdDelete

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateById: MarketOnAccountForAccountMarketIdFkeyUsingMarketPkeyUpdate

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateByDomain: MarketOnAccountForAccountMarketIdFkeyUsingMarketDomainKeyUpdate

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateByDoceboCatalogueId: MarketOnAccountForAccountMarketIdFkeyUsingMarketDoceboCatalogueIdKeyUpdate

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateByNodeId: AccountOnAccountForAccountMarketIdFkeyNodeIdUpdate

  """
  A `MarketInput` object that will be created and connected to this object.
  """
  create: AccountMarketIdFkeyMarketCreateInput
}

"""
The fields on `market` to look up the row to update.
"""
input MarketOnAccountForAccountMarketIdFkeyUsingMarketPkeyUpdate {
  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: updateMarketOnAccountForAccountMarketIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `market` being updated.
"""
input updateMarketOnAccountForAccountMarketIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  ek
  """
  language: Language

  """
  the country code used for example as the subdomain
  """
  domain: String

  """
  The space in Contenful
  """
  cmsSpaceId: String

  """
  A short name for the market, e.g. Italy, Norway, Netherlands
  """
  name: String

  """
  The From name used when sending an email
  """
  sendName: String

  """
  The mailbox on intouch.bmigroup.com that emails will be sent from for this Market
  """
  sendMailbox: String

  """
  The default branch in Docebo that installers go into
  """
  doceboInstallersBranchId: String

  """
  The branch in Docebo that company admins go into
  """
  doceboCompanyAdminBranchId: String

  """
  The default catalogue for the market.  All users in the market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int

  """
  The address of the merchandising site for the market.  CTAs of the MERCHANDISING type will link to this address
  """
  merchandisingUrl: String

  """
  Whether the market supports Projects.  If so then the Projects link should be available in th left hand navigation.
  """
  projectsEnabled: Boolean

  """
  Reference to the Google Analytics tracking ID that is used for the Country GA reports
  """
  gtag: String

  """
  The coordinates of the middle of the Market on a map
  """
  geoMiddle: PointInput

  """
  The length of the radius in km (from the geo_middle lat/lng), for which the Google Places API biases the search results for address autocomplete. Locations outside of the radius will not be excluded.
  """
  locationBiasRadiusKm: Int
  createdAt: Datetime
  updatedAt: Datetime
  accountsUsingId: AccountMarketIdFkeyInverseInput
  companiesUsingId: CompanyMarketIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberMarketIdFkeyInverseInput
  productsUsingId: ProductMarketIdFkeyInverseInput
  systemsUsingId: SystemMarketIdFkeyInverseInput
  systemMembersUsingId: SystemMemberMarketIdFkeyInverseInput
}

"""
Input for the nested mutation of `company` in the `MarketInput` mutation.
"""
input CompanyMarketIdFkeyInverseInput {
  """
  Flag indicating whether all other `company` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectById: [CompanyCompanyPkeyConnect!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByName: [CompanyCompanyNameKeyConnect!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByReferenceNumber: [CompanyCompanyReferenceNumberKeyConnect!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByNodeId: [CompanyNodeIdConnect!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteById: [CompanyCompanyPkeyDelete!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByName: [CompanyCompanyNameKeyDelete!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByReferenceNumber: [CompanyCompanyReferenceNumberKeyDelete!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByNodeId: [CompanyNodeIdDelete!]

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateById: [CompanyOnCompanyForCompanyMarketIdFkeyUsingCompanyPkeyUpdate!]

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByName: [CompanyOnCompanyForCompanyMarketIdFkeyUsingCompanyNameKeyUpdate!]

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByReferenceNumber: [CompanyOnCompanyForCompanyMarketIdFkeyUsingCompanyReferenceNumberKeyUpdate!]

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByNodeId: [MarketOnCompanyForCompanyMarketIdFkeyNodeIdUpdate!]
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnCompanyForCompanyMarketIdFkeyUsingCompanyPkeyUpdate {
  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnCompanyForCompanyMarketIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `company` being updated.
"""
input updateCompanyOnCompanyForCompanyMarketIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  registeredAddressId: Int

  """
  fk
  """
  tradingAddressId: Int

  """
  the name of the owner of the Company
  """
  ownerFullname: String

  """
  the email address to contact the owner
  """
  ownerEmail: String

  """
  the phone number to contact the owner
  """
  ownerPhone: String

  """
  ek
  """
  businessType: BusinessType

  """
  ek
  """
  tier: Tier

  """
  ek
  """
  status: CompanyStatus

  """
  the email address of the person who filled out the company registration form
  """
  registeredBy: String

  """
  the date that the Company registration form was submitted
  """
  registeredDate: Datetime

  """
  The registered name of the Company
  """
  name: String

  """
  The Tax number in that Market, such as the VAT number
  """
  taxNumber: String

  """
  The Company public phone number
  """
  phone: String

  """
  A descirption of the Company intended for Find a Roofer
  """
  aboutUs: String

  """
  The email address that they can be contacted with by the public assuming they are listed
  """
  publicEmail: String

  """
  The Company website URL
  """
  website: String

  """
  The Company facebook website
  """
  facebook: String

  """
  Their Company LinkedIn page URL
  """
  linkedIn: String

  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: String

  """
  A reference to the logo image
  """
  logo: String

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String

  """
  Used for reference when importing data from the legacy system
  """
  tradingAddressMigrationId: String

  """
  Used for reference when importing data from the legacy system
  """
  registeredAddressMigrationId: String
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: CompanyMarketIdFkeyInput
  addressToRegisteredAddressId: CompanyRegisteredAddressIdFkeyInput
  addressToTradingAddressId: CompanyTradingAddressIdFkeyInput
  companyDocumentsUsingId: CompanyDocumentCompanyIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberCompanyIdFkeyInverseInput
  companyOperationsUsingId: CompanyOperationCompanyFkeyInverseInput
  invitationsUsingId: InvitationCompanyIdFkeyInverseInput
  projectsUsingId: ProjectCompanyIdFkeyInverseInput
  logoUpload: Upload
  shouldRemoveLogo: Boolean
}

"""
Input for the nested mutation of `address` in the `CompanyInput` mutation.
"""
input CompanyRegisteredAddressIdFkeyInput {
  """
  The primary key(s) for `address` for the far side of the relationship.
  """
  connectById: AddressAddressPkeyConnect

  """
  The primary key(s) for `address` for the far side of the relationship.
  """
  connectByNodeId: AddressNodeIdConnect

  """
  The primary key(s) for `address` for the far side of the relationship.
  """
  deleteById: AddressAddressPkeyDelete

  """
  The primary key(s) for `address` for the far side of the relationship.
  """
  deleteByNodeId: AddressNodeIdDelete

  """
  The primary key(s) and patch data for `address` for the far side of the relationship.
  """
  updateById: AddressOnCompanyForCompanyRegisteredAddressIdFkeyUsingAddressPkeyUpdate

  """
  The primary key(s) and patch data for `address` for the far side of the relationship.
  """
  updateByNodeId: CompanyOnCompanyForCompanyRegisteredAddressIdFkeyNodeIdUpdate

  """
  A `AddressInput` object that will be created and connected to this object.
  """
  create: CompanyRegisteredAddressIdFkeyAddressCreateInput
}

"""
The fields on `address` to look up the row to connect.
"""
input AddressAddressPkeyConnect {
  """
  Primary key
  """
  id: Int!
}

"""
The globally unique `ID` look up for the row to connect.
"""
input AddressNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `address` to be connected.
  """
  nodeId: ID!
}

"""
The fields on `address` to look up the row to delete.
"""
input AddressAddressPkeyDelete {
  """
  Primary key
  """
  id: Int!
}

"""
The globally unique `ID` look up for the row to delete.
"""
input AddressNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `address` to be deleted.
  """
  nodeId: ID!
}

"""
The fields on `address` to look up the row to update.
"""
input AddressOnCompanyForCompanyRegisteredAddressIdFkeyUsingAddressPkeyUpdate {
  """
  An object where the defined keys will be set on the `address` being updated.
  """
  patch: updateAddressOnCompanyForCompanyRegisteredAddressIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `address` being updated.
"""
input updateAddressOnCompanyForCompanyRegisteredAddressIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  First line of this address
  """
  firstLine: String

  """
  Second line of this address
  """
  secondLine: String

  """
  The postal town
  """
  town: String

  """
  The region if relevant
  """
  region: String

  """
  The country for this address
  """
  country: String

  """
  The postcode for this address
  """
  postcode: String

  """
  The coordinates on a map of the world
  """
  coordinates: PointInput

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String
  createdAt: Datetime
  updatedAt: Datetime
  companiesToRegisteredAddressIdUsingId: CompanyRegisteredAddressIdFkeyInverseInput
  companiesToTradingAddressIdUsingId: CompanyTradingAddressIdFkeyInverseInput
  projectsToSiteAddressIdUsingId: ProjectSiteAddressIdFkeyInverseInput
  projectsToBuildingOwnerAddressIdUsingId: ProjectBuildingOwnerAddressIdFkeyInverseInput
}

"""
Input for the nested mutation of `company` in the `AddressInput` mutation.
"""
input CompanyTradingAddressIdFkeyInverseInput {
  """
  Flag indicating whether all other `company` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectById: [CompanyCompanyPkeyConnect!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByName: [CompanyCompanyNameKeyConnect!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByReferenceNumber: [CompanyCompanyReferenceNumberKeyConnect!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByNodeId: [CompanyNodeIdConnect!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteById: [CompanyCompanyPkeyDelete!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByName: [CompanyCompanyNameKeyDelete!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByReferenceNumber: [CompanyCompanyReferenceNumberKeyDelete!]

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByNodeId: [CompanyNodeIdDelete!]

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateById: [CompanyOnCompanyForCompanyTradingAddressIdFkeyUsingCompanyPkeyUpdate!]

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByName: [CompanyOnCompanyForCompanyTradingAddressIdFkeyUsingCompanyNameKeyUpdate!]

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByReferenceNumber: [CompanyOnCompanyForCompanyTradingAddressIdFkeyUsingCompanyReferenceNumberKeyUpdate!]

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByNodeId: [AddressOnCompanyForCompanyTradingAddressIdFkeyNodeIdUpdate!]
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnCompanyForCompanyTradingAddressIdFkeyUsingCompanyPkeyUpdate {
  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnCompanyForCompanyTradingAddressIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `company` being updated.
"""
input updateCompanyOnCompanyForCompanyTradingAddressIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int

  """
  fk
  """
  registeredAddressId: Int

  """
  the name of the owner of the Company
  """
  ownerFullname: String

  """
  the email address to contact the owner
  """
  ownerEmail: String

  """
  the phone number to contact the owner
  """
  ownerPhone: String

  """
  ek
  """
  businessType: BusinessType

  """
  ek
  """
  tier: Tier

  """
  ek
  """
  status: CompanyStatus

  """
  the email address of the person who filled out the company registration form
  """
  registeredBy: String

  """
  the date that the Company registration form was submitted
  """
  registeredDate: Datetime

  """
  The registered name of the Company
  """
  name: String

  """
  The Tax number in that Market, such as the VAT number
  """
  taxNumber: String

  """
  The Company public phone number
  """
  phone: String

  """
  A descirption of the Company intended for Find a Roofer
  """
  aboutUs: String

  """
  The email address that they can be contacted with by the public assuming they are listed
  """
  publicEmail: String

  """
  The Company website URL
  """
  website: String

  """
  The Company facebook website
  """
  facebook: String

  """
  Their Company LinkedIn page URL
  """
  linkedIn: String

  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: String

  """
  A reference to the logo image
  """
  logo: String

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String

  """
  Used for reference when importing data from the legacy system
  """
  tradingAddressMigrationId: String

  """
  Used for reference when importing data from the legacy system
  """
  registeredAddressMigrationId: String
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: CompanyMarketIdFkeyInput
  addressToRegisteredAddressId: CompanyRegisteredAddressIdFkeyInput
  addressToTradingAddressId: CompanyTradingAddressIdFkeyInput
  companyDocumentsUsingId: CompanyDocumentCompanyIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberCompanyIdFkeyInverseInput
  companyOperationsUsingId: CompanyOperationCompanyFkeyInverseInput
  invitationsUsingId: InvitationCompanyIdFkeyInverseInput
  projectsUsingId: ProjectCompanyIdFkeyInverseInput
  logoUpload: Upload
  shouldRemoveLogo: Boolean
}

"""
Input for the nested mutation of `address` in the `CompanyInput` mutation.
"""
input CompanyTradingAddressIdFkeyInput {
  """
  The primary key(s) for `address` for the far side of the relationship.
  """
  connectById: AddressAddressPkeyConnect

  """
  The primary key(s) for `address` for the far side of the relationship.
  """
  connectByNodeId: AddressNodeIdConnect

  """
  The primary key(s) for `address` for the far side of the relationship.
  """
  deleteById: AddressAddressPkeyDelete

  """
  The primary key(s) for `address` for the far side of the relationship.
  """
  deleteByNodeId: AddressNodeIdDelete

  """
  The primary key(s) and patch data for `address` for the far side of the relationship.
  """
  updateById: AddressOnCompanyForCompanyTradingAddressIdFkeyUsingAddressPkeyUpdate

  """
  The primary key(s) and patch data for `address` for the far side of the relationship.
  """
  updateByNodeId: CompanyOnCompanyForCompanyTradingAddressIdFkeyNodeIdUpdate

  """
  A `AddressInput` object that will be created and connected to this object.
  """
  create: CompanyTradingAddressIdFkeyAddressCreateInput
}

"""
The fields on `address` to look up the row to update.
"""
input AddressOnCompanyForCompanyTradingAddressIdFkeyUsingAddressPkeyUpdate {
  """
  An object where the defined keys will be set on the `address` being updated.
  """
  patch: updateAddressOnCompanyForCompanyTradingAddressIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `address` being updated.
"""
input updateAddressOnCompanyForCompanyTradingAddressIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  First line of this address
  """
  firstLine: String

  """
  Second line of this address
  """
  secondLine: String

  """
  The postal town
  """
  town: String

  """
  The region if relevant
  """
  region: String

  """
  The country for this address
  """
  country: String

  """
  The postcode for this address
  """
  postcode: String

  """
  The coordinates on a map of the world
  """
  coordinates: PointInput

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String
  createdAt: Datetime
  updatedAt: Datetime
  companiesToRegisteredAddressIdUsingId: CompanyRegisteredAddressIdFkeyInverseInput
  companiesToTradingAddressIdUsingId: CompanyTradingAddressIdFkeyInverseInput
  projectsToSiteAddressIdUsingId: ProjectSiteAddressIdFkeyInverseInput
  projectsToBuildingOwnerAddressIdUsingId: ProjectBuildingOwnerAddressIdFkeyInverseInput
}

"""
Input for the nested mutation of `project` in the `AddressInput` mutation.
"""
input ProjectSiteAddressIdFkeyInverseInput {
  """
  Flag indicating whether all other `project` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  connectById: [ProjectProjectPkeyConnect!]

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  connectByNodeId: [ProjectNodeIdConnect!]

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  deleteById: [ProjectProjectPkeyDelete!]

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  deleteByNodeId: [ProjectNodeIdDelete!]

  """
  The primary key(s) and patch data for `project` for the far side of the relationship.
  """
  updateById: [ProjectOnProjectForProjectSiteAddressIdFkeyUsingProjectPkeyUpdate!]

  """
  The primary key(s) and patch data for `project` for the far side of the relationship.
  """
  updateByNodeId: [AddressOnProjectForProjectSiteAddressIdFkeyNodeIdUpdate!]

  """
  A `ProjectInput` object that will be created and connected to this object.
  """
  create: [ProjectSiteAddressIdFkeyProjectCreateInput!]
}

"""
The fields on `project` to look up the row to connect.
"""
input ProjectProjectPkeyConnect {
  """
  Primary key
  """
  id: Int!
}

"""
The globally unique `ID` look up for the row to connect.
"""
input ProjectNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `project` to be connected.
  """
  nodeId: ID!
}

"""
The fields on `project` to look up the row to delete.
"""
input ProjectProjectPkeyDelete {
  """
  Primary key
  """
  id: Int!
}

"""
The globally unique `ID` look up for the row to delete.
"""
input ProjectNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `project` to be deleted.
  """
  nodeId: ID!
}

"""
The fields on `project` to look up the row to update.
"""
input ProjectOnProjectForProjectSiteAddressIdFkeyUsingProjectPkeyUpdate {
  """
  An object where the defined keys will be set on the `project` being updated.
  """
  patch: updateProjectOnProjectForProjectSiteAddressIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `project` being updated.
"""
input updateProjectOnProjectForProjectSiteAddressIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  companyId: Int

  """
  fk
  """
  buildingOwnerAddressId: Int

  """
  ek
  """
  technology: Technology

  """
  Short name for the Project
  """
  name: String

  """
  Short description of what the Project is about.  Sometimes useful to clarify some points to BMI
  """
  description: String

  """
  If this is true then the Project should be hidden from End Users
  """
  hidden: Boolean

  """
  The number of square meters of roof that this project covers
  """
  roofArea: Int

  """
  Email address of the person who owns the building that the roof is going on.  Not mandatory for a Project, but mandatory when the Company applies for a Guarantee related to the project.
  """
  buildingOwnerMail: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerFirstname: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerLastname: String

  """
  Name of the Building Owner company if there is such a thing.  Not the same as an InTouch Company.
  """
  buildingOwnerCompany: String

  """
  The date that the Project officially starts or started
  """
  startDate: Datetime

  """
  The date that the Project officially expects to end or ended
  """
  endDate: Datetime
  createdAt: Datetime
  updatedAt: Datetime
  companyToCompanyId: ProjectCompanyIdFkeyInput
  addressToSiteAddressId: ProjectSiteAddressIdFkeyInput
  addressToBuildingOwnerAddressId: ProjectBuildingOwnerAddressIdFkeyInput
  evidenceItemsUsingId: EvidenceItemProjectIdFkeyInverseInput
  guaranteesUsingId: GuaranteeProjectIdFkeyInverseInput
  notesUsingId: NoteProjectIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberProjectIdFkeyInverseInput
}

"""
Input for the nested mutation of `company` in the `ProjectInput` mutation.
"""
input ProjectCompanyIdFkeyInput {
  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectById: CompanyCompanyPkeyConnect

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByName: CompanyCompanyNameKeyConnect

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByReferenceNumber: CompanyCompanyReferenceNumberKeyConnect

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByNodeId: CompanyNodeIdConnect

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteById: CompanyCompanyPkeyDelete

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByName: CompanyCompanyNameKeyDelete

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByReferenceNumber: CompanyCompanyReferenceNumberKeyDelete

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByNodeId: CompanyNodeIdDelete

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateById: CompanyOnProjectForProjectCompanyIdFkeyUsingCompanyPkeyUpdate

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByName: CompanyOnProjectForProjectCompanyIdFkeyUsingCompanyNameKeyUpdate

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByReferenceNumber: CompanyOnProjectForProjectCompanyIdFkeyUsingCompanyReferenceNumberKeyUpdate

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByNodeId: ProjectOnProjectForProjectCompanyIdFkeyNodeIdUpdate
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnProjectForProjectCompanyIdFkeyUsingCompanyPkeyUpdate {
  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnProjectForProjectCompanyIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `company` being updated.
"""
input updateCompanyOnProjectForProjectCompanyIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int

  """
  fk
  """
  registeredAddressId: Int

  """
  fk
  """
  tradingAddressId: Int

  """
  the name of the owner of the Company
  """
  ownerFullname: String

  """
  the email address to contact the owner
  """
  ownerEmail: String

  """
  the phone number to contact the owner
  """
  ownerPhone: String

  """
  ek
  """
  businessType: BusinessType

  """
  ek
  """
  tier: Tier

  """
  ek
  """
  status: CompanyStatus

  """
  the email address of the person who filled out the company registration form
  """
  registeredBy: String

  """
  the date that the Company registration form was submitted
  """
  registeredDate: Datetime

  """
  The registered name of the Company
  """
  name: String

  """
  The Tax number in that Market, such as the VAT number
  """
  taxNumber: String

  """
  The Company public phone number
  """
  phone: String

  """
  A descirption of the Company intended for Find a Roofer
  """
  aboutUs: String

  """
  The email address that they can be contacted with by the public assuming they are listed
  """
  publicEmail: String

  """
  The Company website URL
  """
  website: String

  """
  The Company facebook website
  """
  facebook: String

  """
  Their Company LinkedIn page URL
  """
  linkedIn: String

  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: String

  """
  A reference to the logo image
  """
  logo: String

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String

  """
  Used for reference when importing data from the legacy system
  """
  tradingAddressMigrationId: String

  """
  Used for reference when importing data from the legacy system
  """
  registeredAddressMigrationId: String
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: CompanyMarketIdFkeyInput
  addressToRegisteredAddressId: CompanyRegisteredAddressIdFkeyInput
  addressToTradingAddressId: CompanyTradingAddressIdFkeyInput
  companyDocumentsUsingId: CompanyDocumentCompanyIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberCompanyIdFkeyInverseInput
  companyOperationsUsingId: CompanyOperationCompanyFkeyInverseInput
  invitationsUsingId: InvitationCompanyIdFkeyInverseInput
  projectsUsingId: ProjectCompanyIdFkeyInverseInput
  logoUpload: Upload
  shouldRemoveLogo: Boolean
}

"""
Input for the nested mutation of `companyDocument` in the `CompanyInput` mutation.
"""
input CompanyDocumentCompanyIdFkeyInverseInput {
  """
  Flag indicating whether all other `companyDocument` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `companyDocument` for the far side of the relationship.
  """
  connectById: [CompanyDocumentCompanyDocumentPkeyConnect!]

  """
  The primary key(s) for `companyDocument` for the far side of the relationship.
  """
  connectByNodeId: [CompanyDocumentNodeIdConnect!]

  """
  The primary key(s) for `companyDocument` for the far side of the relationship.
  """
  deleteById: [CompanyDocumentCompanyDocumentPkeyDelete!]

  """
  The primary key(s) for `companyDocument` for the far side of the relationship.
  """
  deleteByNodeId: [CompanyDocumentNodeIdDelete!]

  """
  The primary key(s) and patch data for `companyDocument` for the far side of the relationship.
  """
  updateById: [CompanyDocumentOnCompanyDocumentForCompanyDocumentCompanyIdFkeyUsingCompanyDocumentPkeyUpdate!]

  """
  The primary key(s) and patch data for `companyDocument` for the far side of the relationship.
  """
  updateByNodeId: [CompanyOnCompanyDocumentForCompanyDocumentCompanyIdFkeyNodeIdUpdate!]

  """
  A `CompanyDocumentInput` object that will be created and connected to this object.
  """
  create: [CompanyDocumentCompanyIdFkeyCompanyDocumentCreateInput!]
}

"""
The fields on `companyDocument` to look up the row to connect.
"""
input CompanyDocumentCompanyDocumentPkeyConnect {
  """
  Primary key
  """
  id: Int!
}

"""
The globally unique `ID` look up for the row to connect.
"""
input CompanyDocumentNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `companyDocument` to be connected.
  """
  nodeId: ID!
}

"""
The fields on `companyDocument` to look up the row to delete.
"""
input CompanyDocumentCompanyDocumentPkeyDelete {
  """
  Primary key
  """
  id: Int!
}

"""
The globally unique `ID` look up for the row to delete.
"""
input CompanyDocumentNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `companyDocument` to be deleted.
  """
  nodeId: ID!
}

"""
The fields on `companyDocument` to look up the row to update.
"""
input CompanyDocumentOnCompanyDocumentForCompanyDocumentCompanyIdFkeyUsingCompanyDocumentPkeyUpdate {
  """
  An object where the defined keys will be set on the `companyDocument` being updated.
  """
  patch: updateCompanyDocumentOnCompanyDocumentForCompanyDocumentCompanyIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `companyDocument` being updated.
"""
input updateCompanyDocumentOnCompanyDocumentForCompanyDocumentCompanyIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  The reference to the document
  """
  document: String
  createdAt: Datetime
  updatedAt: Datetime
  companyToCompanyId: CompanyDocumentCompanyIdFkeyInput
}

"""
Input for the nested mutation of `company` in the `CompanyDocumentInput` mutation.
"""
input CompanyDocumentCompanyIdFkeyInput {
  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectById: CompanyCompanyPkeyConnect

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByName: CompanyCompanyNameKeyConnect

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByReferenceNumber: CompanyCompanyReferenceNumberKeyConnect

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByNodeId: CompanyNodeIdConnect

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteById: CompanyCompanyPkeyDelete

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByName: CompanyCompanyNameKeyDelete

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByReferenceNumber: CompanyCompanyReferenceNumberKeyDelete

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByNodeId: CompanyNodeIdDelete

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateById: CompanyOnCompanyDocumentForCompanyDocumentCompanyIdFkeyUsingCompanyPkeyUpdate

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByName: CompanyOnCompanyDocumentForCompanyDocumentCompanyIdFkeyUsingCompanyNameKeyUpdate

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByReferenceNumber: CompanyOnCompanyDocumentForCompanyDocumentCompanyIdFkeyUsingCompanyReferenceNumberKeyUpdate

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByNodeId: CompanyDocumentOnCompanyDocumentForCompanyDocumentCompanyIdFkeyNodeIdUpdate
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnCompanyDocumentForCompanyDocumentCompanyIdFkeyUsingCompanyPkeyUpdate {
  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnCompanyDocumentForCompanyDocumentCompanyIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `company` being updated.
"""
input updateCompanyOnCompanyDocumentForCompanyDocumentCompanyIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int

  """
  fk
  """
  registeredAddressId: Int

  """
  fk
  """
  tradingAddressId: Int

  """
  the name of the owner of the Company
  """
  ownerFullname: String

  """
  the email address to contact the owner
  """
  ownerEmail: String

  """
  the phone number to contact the owner
  """
  ownerPhone: String

  """
  ek
  """
  businessType: BusinessType

  """
  ek
  """
  tier: Tier

  """
  ek
  """
  status: CompanyStatus

  """
  the email address of the person who filled out the company registration form
  """
  registeredBy: String

  """
  the date that the Company registration form was submitted
  """
  registeredDate: Datetime

  """
  The registered name of the Company
  """
  name: String

  """
  The Tax number in that Market, such as the VAT number
  """
  taxNumber: String

  """
  The Company public phone number
  """
  phone: String

  """
  A descirption of the Company intended for Find a Roofer
  """
  aboutUs: String

  """
  The email address that they can be contacted with by the public assuming they are listed
  """
  publicEmail: String

  """
  The Company website URL
  """
  website: String

  """
  The Company facebook website
  """
  facebook: String

  """
  Their Company LinkedIn page URL
  """
  linkedIn: String

  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: String

  """
  A reference to the logo image
  """
  logo: String

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String

  """
  Used for reference when importing data from the legacy system
  """
  tradingAddressMigrationId: String

  """
  Used for reference when importing data from the legacy system
  """
  registeredAddressMigrationId: String
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: CompanyMarketIdFkeyInput
  addressToRegisteredAddressId: CompanyRegisteredAddressIdFkeyInput
  addressToTradingAddressId: CompanyTradingAddressIdFkeyInput
  companyDocumentsUsingId: CompanyDocumentCompanyIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberCompanyIdFkeyInverseInput
  companyOperationsUsingId: CompanyOperationCompanyFkeyInverseInput
  invitationsUsingId: InvitationCompanyIdFkeyInverseInput
  projectsUsingId: ProjectCompanyIdFkeyInverseInput
  logoUpload: Upload
  shouldRemoveLogo: Boolean
}

"""
Input for the nested mutation of `companyMember` in the `CompanyInput` mutation.
"""
input CompanyMemberCompanyIdFkeyInverseInput {
  """
  Flag indicating whether all other `companyMember` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `companyMember` for the far side of the relationship.
  """
  connectById: [CompanyMemberCompanyMemberPkeyConnect!]

  """
  The primary key(s) for `companyMember` for the far side of the relationship.
  """
  connectByMarketIdAndAccountIdAndCompanyId: [CompanyMemberCompanyMemberMarketIdAccountIdCompanyIdKeyConnect!]

  """
  The primary key(s) for `companyMember` for the far side of the relationship.
  """
  connectByNodeId: [CompanyMemberNodeIdConnect!]

  """
  The primary key(s) for `companyMember` for the far side of the relationship.
  """
  deleteById: [CompanyMemberCompanyMemberPkeyDelete!]

  """
  The primary key(s) for `companyMember` for the far side of the relationship.
  """
  deleteByMarketIdAndAccountIdAndCompanyId: [CompanyMemberCompanyMemberMarketIdAccountIdCompanyIdKeyDelete!]

  """
  The primary key(s) for `companyMember` for the far side of the relationship.
  """
  deleteByNodeId: [CompanyMemberNodeIdDelete!]

  """
  The primary key(s) and patch data for `companyMember` for the far side of the relationship.
  """
  updateById: [CompanyMemberOnCompanyMemberForCompanyMemberCompanyIdFkeyUsingCompanyMemberPkeyUpdate!]

  """
  The primary key(s) and patch data for `companyMember` for the far side of the relationship.
  """
  updateByMarketIdAndAccountIdAndCompanyId: [CompanyMemberOnCompanyMemberForCompanyMemberCompanyIdFkeyUsingCompanyMemberMarketIdAccountIdCompanyIdKeyUpdate!]

  """
  The primary key(s) and patch data for `companyMember` for the far side of the relationship.
  """
  updateByNodeId: [CompanyOnCompanyMemberForCompanyMemberCompanyIdFkeyNodeIdUpdate!]

  """
  A `CompanyMemberInput` object that will be created and connected to this object.
  """
  create: [CompanyMemberCompanyIdFkeyCompanyMemberCreateInput!]
}

"""
The fields on `companyMember` to look up the row to connect.
"""
input CompanyMemberCompanyMemberPkeyConnect {
  """
  Primary key
  """
  id: Int!
}

"""
The fields on `companyMember` to look up the row to connect.
"""
input CompanyMemberCompanyMemberMarketIdAccountIdCompanyIdKeyConnect {
  """
  fk
  """
  marketId: Int!

  """
  fk
  """
  accountId: Int!

  """
  fk
  """
  companyId: Int!
}

"""
The globally unique `ID` look up for the row to connect.
"""
input CompanyMemberNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `companyMember` to be connected.
  """
  nodeId: ID!
}

"""
The fields on `companyMember` to look up the row to delete.
"""
input CompanyMemberCompanyMemberPkeyDelete {
  """
  Primary key
  """
  id: Int!
}

"""
The fields on `companyMember` to look up the row to delete.
"""
input CompanyMemberCompanyMemberMarketIdAccountIdCompanyIdKeyDelete {
  """
  fk
  """
  marketId: Int!

  """
  fk
  """
  accountId: Int!

  """
  fk
  """
  companyId: Int!
}

"""
The globally unique `ID` look up for the row to delete.
"""
input CompanyMemberNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `companyMember` to be deleted.
  """
  nodeId: ID!
}

"""
The fields on `companyMember` to look up the row to update.
"""
input CompanyMemberOnCompanyMemberForCompanyMemberCompanyIdFkeyUsingCompanyMemberPkeyUpdate {
  """
  An object where the defined keys will be set on the `companyMember` being updated.
  """
  patch: updateCompanyMemberOnCompanyMemberForCompanyMemberCompanyIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `companyMember` being updated.
"""
input updateCompanyMemberOnCompanyMemberForCompanyMemberCompanyIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int

  """
  fk
  """
  accountId: Int
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: CompanyMemberMarketIdFkeyInput
  accountToAccountId: CompanyMemberAccountIdFkeyInput
  companyToCompanyId: CompanyMemberCompanyIdFkeyInput
}

"""
Input for the nested mutation of `market` in the `CompanyMemberInput` mutation.
"""
input CompanyMemberMarketIdFkeyInput {
  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectById: MarketMarketPkeyConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectByDomain: MarketMarketDomainKeyConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectByDoceboCatalogueId: MarketMarketDoceboCatalogueIdKeyConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectByNodeId: MarketNodeIdConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteById: MarketMarketPkeyDelete

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteByDomain: MarketMarketDomainKeyDelete

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteByDoceboCatalogueId: MarketMarketDoceboCatalogueIdKeyDelete

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteByNodeId: MarketNodeIdDelete

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateById: MarketOnCompanyMemberForCompanyMemberMarketIdFkeyUsingMarketPkeyUpdate

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateByDomain: MarketOnCompanyMemberForCompanyMemberMarketIdFkeyUsingMarketDomainKeyUpdate

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateByDoceboCatalogueId: MarketOnCompanyMemberForCompanyMemberMarketIdFkeyUsingMarketDoceboCatalogueIdKeyUpdate

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateByNodeId: CompanyMemberOnCompanyMemberForCompanyMemberMarketIdFkeyNodeIdUpdate

  """
  A `MarketInput` object that will be created and connected to this object.
  """
  create: CompanyMemberMarketIdFkeyMarketCreateInput
}

"""
The fields on `market` to look up the row to update.
"""
input MarketOnCompanyMemberForCompanyMemberMarketIdFkeyUsingMarketPkeyUpdate {
  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: updateMarketOnCompanyMemberForCompanyMemberMarketIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `market` being updated.
"""
input updateMarketOnCompanyMemberForCompanyMemberMarketIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  ek
  """
  language: Language

  """
  the country code used for example as the subdomain
  """
  domain: String

  """
  The space in Contenful
  """
  cmsSpaceId: String

  """
  A short name for the market, e.g. Italy, Norway, Netherlands
  """
  name: String

  """
  The From name used when sending an email
  """
  sendName: String

  """
  The mailbox on intouch.bmigroup.com that emails will be sent from for this Market
  """
  sendMailbox: String

  """
  The default branch in Docebo that installers go into
  """
  doceboInstallersBranchId: String

  """
  The branch in Docebo that company admins go into
  """
  doceboCompanyAdminBranchId: String

  """
  The default catalogue for the market.  All users in the market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int

  """
  The address of the merchandising site for the market.  CTAs of the MERCHANDISING type will link to this address
  """
  merchandisingUrl: String

  """
  Whether the market supports Projects.  If so then the Projects link should be available in th left hand navigation.
  """
  projectsEnabled: Boolean

  """
  Reference to the Google Analytics tracking ID that is used for the Country GA reports
  """
  gtag: String

  """
  The coordinates of the middle of the Market on a map
  """
  geoMiddle: PointInput

  """
  The length of the radius in km (from the geo_middle lat/lng), for which the Google Places API biases the search results for address autocomplete. Locations outside of the radius will not be excluded.
  """
  locationBiasRadiusKm: Int
  createdAt: Datetime
  updatedAt: Datetime
  accountsUsingId: AccountMarketIdFkeyInverseInput
  companiesUsingId: CompanyMarketIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberMarketIdFkeyInverseInput
  productsUsingId: ProductMarketIdFkeyInverseInput
  systemsUsingId: SystemMarketIdFkeyInverseInput
  systemMembersUsingId: SystemMemberMarketIdFkeyInverseInput
}

"""
Input for the nested mutation of `companyMember` in the `MarketInput` mutation.
"""
input CompanyMemberMarketIdFkeyInverseInput {
  """
  Flag indicating whether all other `companyMember` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `companyMember` for the far side of the relationship.
  """
  connectById: [CompanyMemberCompanyMemberPkeyConnect!]

  """
  The primary key(s) for `companyMember` for the far side of the relationship.
  """
  connectByMarketIdAndAccountIdAndCompanyId: [CompanyMemberCompanyMemberMarketIdAccountIdCompanyIdKeyConnect!]

  """
  The primary key(s) for `companyMember` for the far side of the relationship.
  """
  connectByNodeId: [CompanyMemberNodeIdConnect!]

  """
  The primary key(s) for `companyMember` for the far side of the relationship.
  """
  deleteById: [CompanyMemberCompanyMemberPkeyDelete!]

  """
  The primary key(s) for `companyMember` for the far side of the relationship.
  """
  deleteByMarketIdAndAccountIdAndCompanyId: [CompanyMemberCompanyMemberMarketIdAccountIdCompanyIdKeyDelete!]

  """
  The primary key(s) for `companyMember` for the far side of the relationship.
  """
  deleteByNodeId: [CompanyMemberNodeIdDelete!]

  """
  The primary key(s) and patch data for `companyMember` for the far side of the relationship.
  """
  updateById: [CompanyMemberOnCompanyMemberForCompanyMemberMarketIdFkeyUsingCompanyMemberPkeyUpdate!]

  """
  The primary key(s) and patch data for `companyMember` for the far side of the relationship.
  """
  updateByMarketIdAndAccountIdAndCompanyId: [CompanyMemberOnCompanyMemberForCompanyMemberMarketIdFkeyUsingCompanyMemberMarketIdAccountIdCompanyIdKeyUpdate!]

  """
  The primary key(s) and patch data for `companyMember` for the far side of the relationship.
  """
  updateByNodeId: [MarketOnCompanyMemberForCompanyMemberMarketIdFkeyNodeIdUpdate!]

  """
  A `CompanyMemberInput` object that will be created and connected to this object.
  """
  create: [CompanyMemberMarketIdFkeyCompanyMemberCreateInput!]
}

"""
The fields on `companyMember` to look up the row to update.
"""
input CompanyMemberOnCompanyMemberForCompanyMemberMarketIdFkeyUsingCompanyMemberPkeyUpdate {
  """
  An object where the defined keys will be set on the `companyMember` being updated.
  """
  patch: updateCompanyMemberOnCompanyMemberForCompanyMemberMarketIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `companyMember` being updated.
"""
input updateCompanyMemberOnCompanyMemberForCompanyMemberMarketIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  accountId: Int

  """
  fk
  """
  companyId: Int
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: CompanyMemberMarketIdFkeyInput
  accountToAccountId: CompanyMemberAccountIdFkeyInput
  companyToCompanyId: CompanyMemberCompanyIdFkeyInput
}

"""
Input for the nested mutation of `account` in the `CompanyMemberInput` mutation.
"""
input CompanyMemberAccountIdFkeyInput {
  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectById: AccountAccountPkeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByEmail: AccountAccountEmailKeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByDoceboUserId: AccountAccountDoceboUserIdKeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByNodeId: AccountNodeIdConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteById: AccountAccountPkeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByEmail: AccountAccountEmailKeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByDoceboUserId: AccountAccountDoceboUserIdKeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByNodeId: AccountNodeIdDelete

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateById: AccountOnCompanyMemberForCompanyMemberAccountIdFkeyUsingAccountPkeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByEmail: AccountOnCompanyMemberForCompanyMemberAccountIdFkeyUsingAccountEmailKeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByDoceboUserId: AccountOnCompanyMemberForCompanyMemberAccountIdFkeyUsingAccountDoceboUserIdKeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByNodeId: CompanyMemberOnCompanyMemberForCompanyMemberAccountIdFkeyNodeIdUpdate
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnCompanyMemberForCompanyMemberAccountIdFkeyUsingAccountPkeyUpdate {
  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnCompanyMemberForCompanyMemberAccountIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `account` being updated.
"""
input updateAccountOnCompanyMemberForCompanyMemberAccountIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  ek
  """
  status: AccountStatus

  """
  fk
  """
  marketId: Int

  """
  ek
  """
  role: Role

  """
  The email address associated with the account
  """
  email: String

  """
  A phone number that can optionally be provided, and is useful for Company Admin people to provide
  """
  phone: String

  """
  First name
  """
  firstName: String

  """
  Last name
  """
  lastName: String

  """
  When the account was created
  """
  created: Datetime

  """
  User account in Docebo
  """
  doceboUserId: Int

  """
  Username in Docebo.  Needed to generate the SSO link
  """
  doceboUsername: String

  """
  File reference. A profile picture of the user
  """
  photo: String

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: AccountMarketIdFkeyInput
  certificationsUsingDoceboUserId: CertificationDoceboUserIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberAccountIdFkeyInverseInput
  guaranteesToRequestorAccountIdUsingId: GuaranteeRequestorAccountIdFkeyInverseInput
  guaranteesToReviewerAccountIdUsingId: GuaranteeReviewerAccountIdFkeyInverseInput
  invitationsUsingId: InvitationSenderAccountIdFkeyInverseInput
  notesUsingId: NoteAuthorIdFkeyInverseInput
  notificationsUsingId: NotificationAccountIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberAccountIdFkeyInverseInput
  photoUpload: Upload
  shouldRemovePhoto: Boolean
}

"""
Input for the nested mutation of `certification` in the `AccountInput` mutation.
"""
input CertificationDoceboUserIdFkeyInverseInput {
  """
  Flag indicating whether all other `certification` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `certification` for the far side of the relationship.
  """
  connectById: [CertificationCertificationPkeyConnect!]

  """
  The primary key(s) for `certification` for the far side of the relationship.
  """
  connectByNodeId: [CertificationNodeIdConnect!]

  """
  The primary key(s) for `certification` for the far side of the relationship.
  """
  deleteById: [CertificationCertificationPkeyDelete!]

  """
  The primary key(s) for `certification` for the far side of the relationship.
  """
  deleteByNodeId: [CertificationNodeIdDelete!]

  """
  The primary key(s) and patch data for `certification` for the far side of the relationship.
  """
  updateById: [CertificationOnCertificationForCertificationDoceboUserIdFkeyUsingCertificationPkeyUpdate!]

  """
  The primary key(s) and patch data for `certification` for the far side of the relationship.
  """
  updateByNodeId: [AccountOnCertificationForCertificationDoceboUserIdFkeyNodeIdUpdate!]

  """
  A `CertificationInput` object that will be created and connected to this object.
  """
  create: [CertificationDoceboUserIdFkeyCertificationCreateInput!]
}

"""
The fields on `certification` to look up the row to connect.
"""
input CertificationCertificationPkeyConnect {
  """
  Primary key
  """
  id: Int!
}

"""
The globally unique `ID` look up for the row to connect.
"""
input CertificationNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `certification` to be connected.
  """
  nodeId: ID!
}

"""
The fields on `certification` to look up the row to delete.
"""
input CertificationCertificationPkeyDelete {
  """
  Primary key
  """
  id: Int!
}

"""
The globally unique `ID` look up for the row to delete.
"""
input CertificationNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `certification` to be deleted.
  """
  nodeId: ID!
}

"""
The fields on `certification` to look up the row to update.
"""
input CertificationOnCertificationForCertificationDoceboUserIdFkeyUsingCertificationPkeyUpdate {
  """
  An object where the defined keys will be set on the `certification` being updated.
  """
  patch: updateCertificationOnCertificationForCertificationDoceboUserIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `certification` being updated.
"""
input updateCertificationOnCertificationForCertificationDoceboUserIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  technology
  """
  technology: String

  """
  The name of the certification according to Docebo
  """
  name: String

  """
  The last day that this certification is valid
  """
  expiryDate: Datetime
  createdAt: Datetime
  updatedAt: Datetime
  accountToDoceboUserId: CertificationDoceboUserIdFkeyInput
}

"""
Input for the nested mutation of `account` in the `CertificationInput` mutation.
"""
input CertificationDoceboUserIdFkeyInput {
  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectById: AccountAccountPkeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByEmail: AccountAccountEmailKeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByDoceboUserId: AccountAccountDoceboUserIdKeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByNodeId: AccountNodeIdConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteById: AccountAccountPkeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByEmail: AccountAccountEmailKeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByDoceboUserId: AccountAccountDoceboUserIdKeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByNodeId: AccountNodeIdDelete

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateById: AccountOnCertificationForCertificationDoceboUserIdFkeyUsingAccountPkeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByEmail: AccountOnCertificationForCertificationDoceboUserIdFkeyUsingAccountEmailKeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByDoceboUserId: AccountOnCertificationForCertificationDoceboUserIdFkeyUsingAccountDoceboUserIdKeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByNodeId: CertificationOnCertificationForCertificationDoceboUserIdFkeyNodeIdUpdate
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnCertificationForCertificationDoceboUserIdFkeyUsingAccountPkeyUpdate {
  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnCertificationForCertificationDoceboUserIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `account` being updated.
"""
input updateAccountOnCertificationForCertificationDoceboUserIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  ek
  """
  status: AccountStatus

  """
  fk
  """
  marketId: Int

  """
  ek
  """
  role: Role

  """
  The email address associated with the account
  """
  email: String

  """
  A phone number that can optionally be provided, and is useful for Company Admin people to provide
  """
  phone: String

  """
  First name
  """
  firstName: String

  """
  Last name
  """
  lastName: String

  """
  When the account was created
  """
  created: Datetime

  """
  Username in Docebo.  Needed to generate the SSO link
  """
  doceboUsername: String

  """
  File reference. A profile picture of the user
  """
  photo: String

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: AccountMarketIdFkeyInput
  certificationsUsingDoceboUserId: CertificationDoceboUserIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberAccountIdFkeyInverseInput
  guaranteesToRequestorAccountIdUsingId: GuaranteeRequestorAccountIdFkeyInverseInput
  guaranteesToReviewerAccountIdUsingId: GuaranteeReviewerAccountIdFkeyInverseInput
  invitationsUsingId: InvitationSenderAccountIdFkeyInverseInput
  notesUsingId: NoteAuthorIdFkeyInverseInput
  notificationsUsingId: NotificationAccountIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberAccountIdFkeyInverseInput
  photoUpload: Upload
  shouldRemovePhoto: Boolean
}

"""
Input for the nested mutation of `companyMember` in the `AccountInput` mutation.
"""
input CompanyMemberAccountIdFkeyInverseInput {
  """
  Flag indicating whether all other `companyMember` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `companyMember` for the far side of the relationship.
  """
  connectById: [CompanyMemberCompanyMemberPkeyConnect!]

  """
  The primary key(s) for `companyMember` for the far side of the relationship.
  """
  connectByMarketIdAndAccountIdAndCompanyId: [CompanyMemberCompanyMemberMarketIdAccountIdCompanyIdKeyConnect!]

  """
  The primary key(s) for `companyMember` for the far side of the relationship.
  """
  connectByNodeId: [CompanyMemberNodeIdConnect!]

  """
  The primary key(s) for `companyMember` for the far side of the relationship.
  """
  deleteById: [CompanyMemberCompanyMemberPkeyDelete!]

  """
  The primary key(s) for `companyMember` for the far side of the relationship.
  """
  deleteByMarketIdAndAccountIdAndCompanyId: [CompanyMemberCompanyMemberMarketIdAccountIdCompanyIdKeyDelete!]

  """
  The primary key(s) for `companyMember` for the far side of the relationship.
  """
  deleteByNodeId: [CompanyMemberNodeIdDelete!]

  """
  The primary key(s) and patch data for `companyMember` for the far side of the relationship.
  """
  updateById: [CompanyMemberOnCompanyMemberForCompanyMemberAccountIdFkeyUsingCompanyMemberPkeyUpdate!]

  """
  The primary key(s) and patch data for `companyMember` for the far side of the relationship.
  """
  updateByMarketIdAndAccountIdAndCompanyId: [CompanyMemberOnCompanyMemberForCompanyMemberAccountIdFkeyUsingCompanyMemberMarketIdAccountIdCompanyIdKeyUpdate!]

  """
  The primary key(s) and patch data for `companyMember` for the far side of the relationship.
  """
  updateByNodeId: [AccountOnCompanyMemberForCompanyMemberAccountIdFkeyNodeIdUpdate!]

  """
  A `CompanyMemberInput` object that will be created and connected to this object.
  """
  create: [CompanyMemberAccountIdFkeyCompanyMemberCreateInput!]
}

"""
The fields on `companyMember` to look up the row to update.
"""
input CompanyMemberOnCompanyMemberForCompanyMemberAccountIdFkeyUsingCompanyMemberPkeyUpdate {
  """
  An object where the defined keys will be set on the `companyMember` being updated.
  """
  patch: updateCompanyMemberOnCompanyMemberForCompanyMemberAccountIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `companyMember` being updated.
"""
input updateCompanyMemberOnCompanyMemberForCompanyMemberAccountIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int

  """
  fk
  """
  companyId: Int
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: CompanyMemberMarketIdFkeyInput
  accountToAccountId: CompanyMemberAccountIdFkeyInput
  companyToCompanyId: CompanyMemberCompanyIdFkeyInput
}

"""
Input for the nested mutation of `company` in the `CompanyMemberInput` mutation.
"""
input CompanyMemberCompanyIdFkeyInput {
  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectById: CompanyCompanyPkeyConnect

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByName: CompanyCompanyNameKeyConnect

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByReferenceNumber: CompanyCompanyReferenceNumberKeyConnect

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByNodeId: CompanyNodeIdConnect

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteById: CompanyCompanyPkeyDelete

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByName: CompanyCompanyNameKeyDelete

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByReferenceNumber: CompanyCompanyReferenceNumberKeyDelete

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByNodeId: CompanyNodeIdDelete

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateById: CompanyOnCompanyMemberForCompanyMemberCompanyIdFkeyUsingCompanyPkeyUpdate

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByName: CompanyOnCompanyMemberForCompanyMemberCompanyIdFkeyUsingCompanyNameKeyUpdate

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByReferenceNumber: CompanyOnCompanyMemberForCompanyMemberCompanyIdFkeyUsingCompanyReferenceNumberKeyUpdate

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByNodeId: CompanyMemberOnCompanyMemberForCompanyMemberCompanyIdFkeyNodeIdUpdate
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnCompanyMemberForCompanyMemberCompanyIdFkeyUsingCompanyPkeyUpdate {
  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnCompanyMemberForCompanyMemberCompanyIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `company` being updated.
"""
input updateCompanyOnCompanyMemberForCompanyMemberCompanyIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int

  """
  fk
  """
  registeredAddressId: Int

  """
  fk
  """
  tradingAddressId: Int

  """
  the name of the owner of the Company
  """
  ownerFullname: String

  """
  the email address to contact the owner
  """
  ownerEmail: String

  """
  the phone number to contact the owner
  """
  ownerPhone: String

  """
  ek
  """
  businessType: BusinessType

  """
  ek
  """
  tier: Tier

  """
  ek
  """
  status: CompanyStatus

  """
  the email address of the person who filled out the company registration form
  """
  registeredBy: String

  """
  the date that the Company registration form was submitted
  """
  registeredDate: Datetime

  """
  The registered name of the Company
  """
  name: String

  """
  The Tax number in that Market, such as the VAT number
  """
  taxNumber: String

  """
  The Company public phone number
  """
  phone: String

  """
  A descirption of the Company intended for Find a Roofer
  """
  aboutUs: String

  """
  The email address that they can be contacted with by the public assuming they are listed
  """
  publicEmail: String

  """
  The Company website URL
  """
  website: String

  """
  The Company facebook website
  """
  facebook: String

  """
  Their Company LinkedIn page URL
  """
  linkedIn: String

  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: String

  """
  A reference to the logo image
  """
  logo: String

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String

  """
  Used for reference when importing data from the legacy system
  """
  tradingAddressMigrationId: String

  """
  Used for reference when importing data from the legacy system
  """
  registeredAddressMigrationId: String
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: CompanyMarketIdFkeyInput
  addressToRegisteredAddressId: CompanyRegisteredAddressIdFkeyInput
  addressToTradingAddressId: CompanyTradingAddressIdFkeyInput
  companyDocumentsUsingId: CompanyDocumentCompanyIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberCompanyIdFkeyInverseInput
  companyOperationsUsingId: CompanyOperationCompanyFkeyInverseInput
  invitationsUsingId: InvitationCompanyIdFkeyInverseInput
  projectsUsingId: ProjectCompanyIdFkeyInverseInput
  logoUpload: Upload
  shouldRemoveLogo: Boolean
}

"""
Input for the nested mutation of `companyOperation` in the `CompanyInput` mutation.
"""
input CompanyOperationCompanyFkeyInverseInput {
  """
  Flag indicating whether all other `companyOperation` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `companyOperation` for the far side of the relationship.
  """
  connectById: [CompanyOperationCompanyOperationPkeyConnect!]

  """
  The primary key(s) for `companyOperation` for the far side of the relationship.
  """
  connectByNodeId: [CompanyOperationNodeIdConnect!]

  """
  The primary key(s) for `companyOperation` for the far side of the relationship.
  """
  deleteById: [CompanyOperationCompanyOperationPkeyDelete!]

  """
  The primary key(s) for `companyOperation` for the far side of the relationship.
  """
  deleteByNodeId: [CompanyOperationNodeIdDelete!]

  """
  The primary key(s) and patch data for `companyOperation` for the far side of the relationship.
  """
  updateById: [CompanyOperationOnCompanyOperationForCompanyOperationCompanyFkeyUsingCompanyOperationPkeyUpdate!]

  """
  The primary key(s) and patch data for `companyOperation` for the far side of the relationship.
  """
  updateByNodeId: [CompanyOnCompanyOperationForCompanyOperationCompanyFkeyNodeIdUpdate!]

  """
  A `CompanyOperationInput` object that will be created and connected to this object.
  """
  create: [CompanyOperationCompanyFkeyCompanyOperationCreateInput!]
}

"""
The fields on `companyOperation` to look up the row to connect.
"""
input CompanyOperationCompanyOperationPkeyConnect {
  """
  Primary key
  """
  id: Int!
}

"""
The globally unique `ID` look up for the row to connect.
"""
input CompanyOperationNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `companyOperation` to be connected.
  """
  nodeId: ID!
}

"""
The fields on `companyOperation` to look up the row to delete.
"""
input CompanyOperationCompanyOperationPkeyDelete {
  """
  Primary key
  """
  id: Int!
}

"""
The globally unique `ID` look up for the row to delete.
"""
input CompanyOperationNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `companyOperation` to be deleted.
  """
  nodeId: ID!
}

"""
The fields on `companyOperation` to look up the row to update.
"""
input CompanyOperationOnCompanyOperationForCompanyOperationCompanyFkeyUsingCompanyOperationPkeyUpdate {
  """
  An object where the defined keys will be set on the `companyOperation` being updated.
  """
  patch: updateCompanyOperationOnCompanyOperationForCompanyOperationCompanyFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `companyOperation` being updated.
"""
input updateCompanyOperationOnCompanyOperationForCompanyOperationCompanyFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  ek
  """
  operation: Operation
  createdAt: Datetime
  updatedAt: Datetime
  companyToCompany: CompanyOperationCompanyFkeyInput
}

"""
Input for the nested mutation of `company` in the `CompanyOperationInput` mutation.
"""
input CompanyOperationCompanyFkeyInput {
  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectById: CompanyCompanyPkeyConnect

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByName: CompanyCompanyNameKeyConnect

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByReferenceNumber: CompanyCompanyReferenceNumberKeyConnect

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByNodeId: CompanyNodeIdConnect

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteById: CompanyCompanyPkeyDelete

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByName: CompanyCompanyNameKeyDelete

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByReferenceNumber: CompanyCompanyReferenceNumberKeyDelete

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByNodeId: CompanyNodeIdDelete

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateById: CompanyOnCompanyOperationForCompanyOperationCompanyFkeyUsingCompanyPkeyUpdate

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByName: CompanyOnCompanyOperationForCompanyOperationCompanyFkeyUsingCompanyNameKeyUpdate

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByReferenceNumber: CompanyOnCompanyOperationForCompanyOperationCompanyFkeyUsingCompanyReferenceNumberKeyUpdate

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByNodeId: CompanyOperationOnCompanyOperationForCompanyOperationCompanyFkeyNodeIdUpdate
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnCompanyOperationForCompanyOperationCompanyFkeyUsingCompanyPkeyUpdate {
  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnCompanyOperationForCompanyOperationCompanyFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `company` being updated.
"""
input updateCompanyOnCompanyOperationForCompanyOperationCompanyFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int

  """
  fk
  """
  registeredAddressId: Int

  """
  fk
  """
  tradingAddressId: Int

  """
  the name of the owner of the Company
  """
  ownerFullname: String

  """
  the email address to contact the owner
  """
  ownerEmail: String

  """
  the phone number to contact the owner
  """
  ownerPhone: String

  """
  ek
  """
  businessType: BusinessType

  """
  ek
  """
  tier: Tier

  """
  ek
  """
  status: CompanyStatus

  """
  the email address of the person who filled out the company registration form
  """
  registeredBy: String

  """
  the date that the Company registration form was submitted
  """
  registeredDate: Datetime

  """
  The registered name of the Company
  """
  name: String

  """
  The Tax number in that Market, such as the VAT number
  """
  taxNumber: String

  """
  The Company public phone number
  """
  phone: String

  """
  A descirption of the Company intended for Find a Roofer
  """
  aboutUs: String

  """
  The email address that they can be contacted with by the public assuming they are listed
  """
  publicEmail: String

  """
  The Company website URL
  """
  website: String

  """
  The Company facebook website
  """
  facebook: String

  """
  Their Company LinkedIn page URL
  """
  linkedIn: String

  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: String

  """
  A reference to the logo image
  """
  logo: String

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String

  """
  Used for reference when importing data from the legacy system
  """
  tradingAddressMigrationId: String

  """
  Used for reference when importing data from the legacy system
  """
  registeredAddressMigrationId: String
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: CompanyMarketIdFkeyInput
  addressToRegisteredAddressId: CompanyRegisteredAddressIdFkeyInput
  addressToTradingAddressId: CompanyTradingAddressIdFkeyInput
  companyDocumentsUsingId: CompanyDocumentCompanyIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberCompanyIdFkeyInverseInput
  companyOperationsUsingId: CompanyOperationCompanyFkeyInverseInput
  invitationsUsingId: InvitationCompanyIdFkeyInverseInput
  projectsUsingId: ProjectCompanyIdFkeyInverseInput
  logoUpload: Upload
  shouldRemoveLogo: Boolean
}

"""
Input for the nested mutation of `invitation` in the `CompanyInput` mutation.
"""
input InvitationCompanyIdFkeyInverseInput {
  """
  Flag indicating whether all other `invitation` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `invitation` for the far side of the relationship.
  """
  connectById: [InvitationInvitationPkeyConnect!]

  """
  The primary key(s) for `invitation` for the far side of the relationship.
  """
  connectByNodeId: [InvitationNodeIdConnect!]

  """
  The primary key(s) for `invitation` for the far side of the relationship.
  """
  deleteById: [InvitationInvitationPkeyDelete!]

  """
  The primary key(s) for `invitation` for the far side of the relationship.
  """
  deleteByNodeId: [InvitationNodeIdDelete!]

  """
  The primary key(s) and patch data for `invitation` for the far side of the relationship.
  """
  updateById: [InvitationOnInvitationForInvitationCompanyIdFkeyUsingInvitationPkeyUpdate!]

  """
  The primary key(s) and patch data for `invitation` for the far side of the relationship.
  """
  updateByNodeId: [CompanyOnInvitationForInvitationCompanyIdFkeyNodeIdUpdate!]
}

"""
The fields on `invitation` to look up the row to connect.
"""
input InvitationInvitationPkeyConnect {
  """
  Primary key
  """
  id: Int!
}

"""
The globally unique `ID` look up for the row to connect.
"""
input InvitationNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `invitation` to be connected.
  """
  nodeId: ID!
}

"""
The fields on `invitation` to look up the row to delete.
"""
input InvitationInvitationPkeyDelete {
  """
  Primary key
  """
  id: Int!
}

"""
The globally unique `ID` look up for the row to delete.
"""
input InvitationNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `invitation` to be deleted.
  """
  nodeId: ID!
}

"""
The fields on `invitation` to look up the row to update.
"""
input InvitationOnInvitationForInvitationCompanyIdFkeyUsingInvitationPkeyUpdate {
  """
  An object where the defined keys will be set on the `invitation` being updated.
  """
  patch: updateInvitationOnInvitationForInvitationCompanyIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `invitation` being updated.
"""
input updateInvitationOnInvitationForInvitationCompanyIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  senderAccountId: Int

  """
  ek
  """
  status: InvitationStatus

  """
  An email address
  """
  invitee: String

  """
  An optional note that can be included in the invitation by the sender
  """
  personalNote: String
  createdAt: Datetime
  updatedAt: Datetime
  accountToSenderAccountId: InvitationSenderAccountIdFkeyInput
  companyToCompanyId: InvitationCompanyIdFkeyInput
}

"""
Input for the nested mutation of `account` in the `InvitationInput` mutation.
"""
input InvitationSenderAccountIdFkeyInput {
  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectById: AccountAccountPkeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByEmail: AccountAccountEmailKeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByDoceboUserId: AccountAccountDoceboUserIdKeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByNodeId: AccountNodeIdConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteById: AccountAccountPkeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByEmail: AccountAccountEmailKeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByDoceboUserId: AccountAccountDoceboUserIdKeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByNodeId: AccountNodeIdDelete

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateById: AccountOnInvitationForInvitationSenderAccountIdFkeyUsingAccountPkeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByEmail: AccountOnInvitationForInvitationSenderAccountIdFkeyUsingAccountEmailKeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByDoceboUserId: AccountOnInvitationForInvitationSenderAccountIdFkeyUsingAccountDoceboUserIdKeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByNodeId: InvitationOnInvitationForInvitationSenderAccountIdFkeyNodeIdUpdate
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnInvitationForInvitationSenderAccountIdFkeyUsingAccountPkeyUpdate {
  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnInvitationForInvitationSenderAccountIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `account` being updated.
"""
input updateAccountOnInvitationForInvitationSenderAccountIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  ek
  """
  status: AccountStatus

  """
  fk
  """
  marketId: Int

  """
  ek
  """
  role: Role

  """
  The email address associated with the account
  """
  email: String

  """
  A phone number that can optionally be provided, and is useful for Company Admin people to provide
  """
  phone: String

  """
  First name
  """
  firstName: String

  """
  Last name
  """
  lastName: String

  """
  When the account was created
  """
  created: Datetime

  """
  User account in Docebo
  """
  doceboUserId: Int

  """
  Username in Docebo.  Needed to generate the SSO link
  """
  doceboUsername: String

  """
  File reference. A profile picture of the user
  """
  photo: String

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: AccountMarketIdFkeyInput
  certificationsUsingDoceboUserId: CertificationDoceboUserIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberAccountIdFkeyInverseInput
  guaranteesToRequestorAccountIdUsingId: GuaranteeRequestorAccountIdFkeyInverseInput
  guaranteesToReviewerAccountIdUsingId: GuaranteeReviewerAccountIdFkeyInverseInput
  invitationsUsingId: InvitationSenderAccountIdFkeyInverseInput
  notesUsingId: NoteAuthorIdFkeyInverseInput
  notificationsUsingId: NotificationAccountIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberAccountIdFkeyInverseInput
  photoUpload: Upload
  shouldRemovePhoto: Boolean
}

"""
Input for the nested mutation of `guarantee` in the `AccountInput` mutation.
"""
input GuaranteeRequestorAccountIdFkeyInverseInput {
  """
  Flag indicating whether all other `guarantee` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  connectById: [GuaranteeGuaranteePkeyConnect!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  connectByBmiReferenceId: [GuaranteeGuaranteeBmiReferenceIdKeyConnect!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  connectByNodeId: [GuaranteeNodeIdConnect!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  deleteById: [GuaranteeGuaranteePkeyDelete!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  deleteByBmiReferenceId: [GuaranteeGuaranteeBmiReferenceIdKeyDelete!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  deleteByNodeId: [GuaranteeNodeIdDelete!]

  """
  The primary key(s) and patch data for `guarantee` for the far side of the relationship.
  """
  updateById: [GuaranteeOnGuaranteeForGuaranteeRequestorAccountIdFkeyUsingGuaranteePkeyUpdate!]

  """
  The primary key(s) and patch data for `guarantee` for the far side of the relationship.
  """
  updateByBmiReferenceId: [GuaranteeOnGuaranteeForGuaranteeRequestorAccountIdFkeyUsingGuaranteeBmiReferenceIdKeyUpdate!]

  """
  The primary key(s) and patch data for `guarantee` for the far side of the relationship.
  """
  updateByNodeId: [AccountOnGuaranteeForGuaranteeRequestorAccountIdFkeyNodeIdUpdate!]

  """
  A `GuaranteeInput` object that will be created and connected to this object.
  """
  create: [GuaranteeRequestorAccountIdFkeyGuaranteeCreateInput!]
}

"""
The fields on `guarantee` to look up the row to connect.
"""
input GuaranteeGuaranteePkeyConnect {
  """
  Primary key - starts at 6100
  """
  id: Int!
}

"""
The fields on `guarantee` to look up the row to connect.
"""
input GuaranteeGuaranteeBmiReferenceIdKeyConnect {
  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String!
}

"""
The globally unique `ID` look up for the row to connect.
"""
input GuaranteeNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `guarantee` to be connected.
  """
  nodeId: ID!
}

"""
The fields on `guarantee` to look up the row to delete.
"""
input GuaranteeGuaranteePkeyDelete {
  """
  Primary key - starts at 6100
  """
  id: Int!
}

"""
The fields on `guarantee` to look up the row to delete.
"""
input GuaranteeGuaranteeBmiReferenceIdKeyDelete {
  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String!
}

"""
The globally unique `ID` look up for the row to delete.
"""
input GuaranteeNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `guarantee` to be deleted.
  """
  nodeId: ID!
}

"""
The fields on `guarantee` to look up the row to update.
"""
input GuaranteeOnGuaranteeForGuaranteeRequestorAccountIdFkeyUsingGuaranteePkeyUpdate {
  """
  An object where the defined keys will be set on the `guarantee` being updated.
  """
  patch: updateGuaranteeOnGuaranteeForGuaranteeRequestorAccountIdFkeyPatch!

  """
  Primary key - starts at 6100
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `guarantee` being updated.
"""
input updateGuaranteeOnGuaranteeForGuaranteeRequestorAccountIdFkeyPatch {
  """
  Primary key - starts at 6100
  """
  id: Int

  """
  The pdf file that is emailed out, or a reference to it, or reference to the service that will generate it on demand
  """
  fileStorageId: String

  """
  fk
  """
  projectId: Int

  """
  a reference to the guaranteeType sys id in Contentful
  """
  guaranteeTypeId: String

  """
  fk
  """
  systemBmiRef: String

  """
  fk
  """
  productBmiRef: String

  """
  fk
  """
  reviewerAccountId: Int

  """
  a reference to the guaranteeType sys id in Contentful
  """
  guaranteeTemplateId: String

  """
  ek
  """
  status: RequestStatus

  """
  The date that the Guarantee is approved either automatically or manually
  """
  startDate: Datetime

  """
  When the guarantee will expire.  This should be calculated when the request_status becomes APPROVED. dependent on the StartDate, the Validity of the Product or System and the ValidityOffset in this Tier
  """
  expiryDate: Datetime

  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String
  createdAt: Datetime
  updatedAt: Datetime
  accountToRequestorAccountId: GuaranteeRequestorAccountIdFkeyInput
  projectToProjectId: GuaranteeProjectIdFkeyInput
  systemToSystemBmiRef: GuaranteeSystemBmiRefFkeyInput
  productToProductBmiRef: GuaranteeProductBmiRefFkeyInput
  accountToReviewerAccountId: GuaranteeReviewerAccountIdFkeyInput
  evidenceItemsUsingId: EvidenceItemGuaranteeIdFkeyInverseInput
}

"""
Input for the nested mutation of `account` in the `GuaranteeInput` mutation.
"""
input GuaranteeRequestorAccountIdFkeyInput {
  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectById: AccountAccountPkeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByEmail: AccountAccountEmailKeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByDoceboUserId: AccountAccountDoceboUserIdKeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByNodeId: AccountNodeIdConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteById: AccountAccountPkeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByEmail: AccountAccountEmailKeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByDoceboUserId: AccountAccountDoceboUserIdKeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByNodeId: AccountNodeIdDelete

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateById: AccountOnGuaranteeForGuaranteeRequestorAccountIdFkeyUsingAccountPkeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByEmail: AccountOnGuaranteeForGuaranteeRequestorAccountIdFkeyUsingAccountEmailKeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByDoceboUserId: AccountOnGuaranteeForGuaranteeRequestorAccountIdFkeyUsingAccountDoceboUserIdKeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByNodeId: GuaranteeOnGuaranteeForGuaranteeRequestorAccountIdFkeyNodeIdUpdate
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnGuaranteeForGuaranteeRequestorAccountIdFkeyUsingAccountPkeyUpdate {
  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnGuaranteeForGuaranteeRequestorAccountIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `account` being updated.
"""
input updateAccountOnGuaranteeForGuaranteeRequestorAccountIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  ek
  """
  status: AccountStatus

  """
  fk
  """
  marketId: Int

  """
  ek
  """
  role: Role

  """
  The email address associated with the account
  """
  email: String

  """
  A phone number that can optionally be provided, and is useful for Company Admin people to provide
  """
  phone: String

  """
  First name
  """
  firstName: String

  """
  Last name
  """
  lastName: String

  """
  When the account was created
  """
  created: Datetime

  """
  User account in Docebo
  """
  doceboUserId: Int

  """
  Username in Docebo.  Needed to generate the SSO link
  """
  doceboUsername: String

  """
  File reference. A profile picture of the user
  """
  photo: String

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: AccountMarketIdFkeyInput
  certificationsUsingDoceboUserId: CertificationDoceboUserIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberAccountIdFkeyInverseInput
  guaranteesToRequestorAccountIdUsingId: GuaranteeRequestorAccountIdFkeyInverseInput
  guaranteesToReviewerAccountIdUsingId: GuaranteeReviewerAccountIdFkeyInverseInput
  invitationsUsingId: InvitationSenderAccountIdFkeyInverseInput
  notesUsingId: NoteAuthorIdFkeyInverseInput
  notificationsUsingId: NotificationAccountIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberAccountIdFkeyInverseInput
  photoUpload: Upload
  shouldRemovePhoto: Boolean
}

"""
Input for the nested mutation of `guarantee` in the `AccountInput` mutation.
"""
input GuaranteeReviewerAccountIdFkeyInverseInput {
  """
  Flag indicating whether all other `guarantee` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  connectById: [GuaranteeGuaranteePkeyConnect!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  connectByBmiReferenceId: [GuaranteeGuaranteeBmiReferenceIdKeyConnect!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  connectByNodeId: [GuaranteeNodeIdConnect!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  deleteById: [GuaranteeGuaranteePkeyDelete!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  deleteByBmiReferenceId: [GuaranteeGuaranteeBmiReferenceIdKeyDelete!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  deleteByNodeId: [GuaranteeNodeIdDelete!]

  """
  The primary key(s) and patch data for `guarantee` for the far side of the relationship.
  """
  updateById: [GuaranteeOnGuaranteeForGuaranteeReviewerAccountIdFkeyUsingGuaranteePkeyUpdate!]

  """
  The primary key(s) and patch data for `guarantee` for the far side of the relationship.
  """
  updateByBmiReferenceId: [GuaranteeOnGuaranteeForGuaranteeReviewerAccountIdFkeyUsingGuaranteeBmiReferenceIdKeyUpdate!]

  """
  The primary key(s) and patch data for `guarantee` for the far side of the relationship.
  """
  updateByNodeId: [AccountOnGuaranteeForGuaranteeReviewerAccountIdFkeyNodeIdUpdate!]

  """
  A `GuaranteeInput` object that will be created and connected to this object.
  """
  create: [GuaranteeReviewerAccountIdFkeyGuaranteeCreateInput!]
}

"""
The fields on `guarantee` to look up the row to update.
"""
input GuaranteeOnGuaranteeForGuaranteeReviewerAccountIdFkeyUsingGuaranteePkeyUpdate {
  """
  An object where the defined keys will be set on the `guarantee` being updated.
  """
  patch: updateGuaranteeOnGuaranteeForGuaranteeReviewerAccountIdFkeyPatch!

  """
  Primary key - starts at 6100
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `guarantee` being updated.
"""
input updateGuaranteeOnGuaranteeForGuaranteeReviewerAccountIdFkeyPatch {
  """
  Primary key - starts at 6100
  """
  id: Int

  """
  The pdf file that is emailed out, or a reference to it, or reference to the service that will generate it on demand
  """
  fileStorageId: String

  """
  fk
  """
  requestorAccountId: Int

  """
  fk
  """
  projectId: Int

  """
  a reference to the guaranteeType sys id in Contentful
  """
  guaranteeTypeId: String

  """
  fk
  """
  systemBmiRef: String

  """
  fk
  """
  productBmiRef: String

  """
  a reference to the guaranteeType sys id in Contentful
  """
  guaranteeTemplateId: String

  """
  ek
  """
  status: RequestStatus

  """
  The date that the Guarantee is approved either automatically or manually
  """
  startDate: Datetime

  """
  When the guarantee will expire.  This should be calculated when the request_status becomes APPROVED. dependent on the StartDate, the Validity of the Product or System and the ValidityOffset in this Tier
  """
  expiryDate: Datetime

  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String
  createdAt: Datetime
  updatedAt: Datetime
  accountToRequestorAccountId: GuaranteeRequestorAccountIdFkeyInput
  projectToProjectId: GuaranteeProjectIdFkeyInput
  systemToSystemBmiRef: GuaranteeSystemBmiRefFkeyInput
  productToProductBmiRef: GuaranteeProductBmiRefFkeyInput
  accountToReviewerAccountId: GuaranteeReviewerAccountIdFkeyInput
  evidenceItemsUsingId: EvidenceItemGuaranteeIdFkeyInverseInput
}

"""
Input for the nested mutation of `project` in the `GuaranteeInput` mutation.
"""
input GuaranteeProjectIdFkeyInput {
  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  connectById: ProjectProjectPkeyConnect

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  connectByNodeId: ProjectNodeIdConnect

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  deleteById: ProjectProjectPkeyDelete

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  deleteByNodeId: ProjectNodeIdDelete

  """
  The primary key(s) and patch data for `project` for the far side of the relationship.
  """
  updateById: ProjectOnGuaranteeForGuaranteeProjectIdFkeyUsingProjectPkeyUpdate

  """
  The primary key(s) and patch data for `project` for the far side of the relationship.
  """
  updateByNodeId: GuaranteeOnGuaranteeForGuaranteeProjectIdFkeyNodeIdUpdate

  """
  A `ProjectInput` object that will be created and connected to this object.
  """
  create: GuaranteeProjectIdFkeyProjectCreateInput
}

"""
The fields on `project` to look up the row to update.
"""
input ProjectOnGuaranteeForGuaranteeProjectIdFkeyUsingProjectPkeyUpdate {
  """
  An object where the defined keys will be set on the `project` being updated.
  """
  patch: updateProjectOnGuaranteeForGuaranteeProjectIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `project` being updated.
"""
input updateProjectOnGuaranteeForGuaranteeProjectIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  companyId: Int

  """
  fk
  """
  siteAddressId: Int

  """
  fk
  """
  buildingOwnerAddressId: Int

  """
  ek
  """
  technology: Technology

  """
  Short name for the Project
  """
  name: String

  """
  Short description of what the Project is about.  Sometimes useful to clarify some points to BMI
  """
  description: String

  """
  If this is true then the Project should be hidden from End Users
  """
  hidden: Boolean

  """
  The number of square meters of roof that this project covers
  """
  roofArea: Int

  """
  Email address of the person who owns the building that the roof is going on.  Not mandatory for a Project, but mandatory when the Company applies for a Guarantee related to the project.
  """
  buildingOwnerMail: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerFirstname: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerLastname: String

  """
  Name of the Building Owner company if there is such a thing.  Not the same as an InTouch Company.
  """
  buildingOwnerCompany: String

  """
  The date that the Project officially starts or started
  """
  startDate: Datetime

  """
  The date that the Project officially expects to end or ended
  """
  endDate: Datetime
  createdAt: Datetime
  updatedAt: Datetime
  companyToCompanyId: ProjectCompanyIdFkeyInput
  addressToSiteAddressId: ProjectSiteAddressIdFkeyInput
  addressToBuildingOwnerAddressId: ProjectBuildingOwnerAddressIdFkeyInput
  evidenceItemsUsingId: EvidenceItemProjectIdFkeyInverseInput
  guaranteesUsingId: GuaranteeProjectIdFkeyInverseInput
  notesUsingId: NoteProjectIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberProjectIdFkeyInverseInput
}

"""
Input for the nested mutation of `address` in the `ProjectInput` mutation.
"""
input ProjectSiteAddressIdFkeyInput {
  """
  The primary key(s) for `address` for the far side of the relationship.
  """
  connectById: AddressAddressPkeyConnect

  """
  The primary key(s) for `address` for the far side of the relationship.
  """
  connectByNodeId: AddressNodeIdConnect

  """
  The primary key(s) for `address` for the far side of the relationship.
  """
  deleteById: AddressAddressPkeyDelete

  """
  The primary key(s) for `address` for the far side of the relationship.
  """
  deleteByNodeId: AddressNodeIdDelete

  """
  The primary key(s) and patch data for `address` for the far side of the relationship.
  """
  updateById: AddressOnProjectForProjectSiteAddressIdFkeyUsingAddressPkeyUpdate

  """
  The primary key(s) and patch data for `address` for the far side of the relationship.
  """
  updateByNodeId: ProjectOnProjectForProjectSiteAddressIdFkeyNodeIdUpdate

  """
  A `AddressInput` object that will be created and connected to this object.
  """
  create: ProjectSiteAddressIdFkeyAddressCreateInput
}

"""
The fields on `address` to look up the row to update.
"""
input AddressOnProjectForProjectSiteAddressIdFkeyUsingAddressPkeyUpdate {
  """
  An object where the defined keys will be set on the `address` being updated.
  """
  patch: updateAddressOnProjectForProjectSiteAddressIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `address` being updated.
"""
input updateAddressOnProjectForProjectSiteAddressIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  First line of this address
  """
  firstLine: String

  """
  Second line of this address
  """
  secondLine: String

  """
  The postal town
  """
  town: String

  """
  The region if relevant
  """
  region: String

  """
  The country for this address
  """
  country: String

  """
  The postcode for this address
  """
  postcode: String

  """
  The coordinates on a map of the world
  """
  coordinates: PointInput

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String
  createdAt: Datetime
  updatedAt: Datetime
  companiesToRegisteredAddressIdUsingId: CompanyRegisteredAddressIdFkeyInverseInput
  companiesToTradingAddressIdUsingId: CompanyTradingAddressIdFkeyInverseInput
  projectsToSiteAddressIdUsingId: ProjectSiteAddressIdFkeyInverseInput
  projectsToBuildingOwnerAddressIdUsingId: ProjectBuildingOwnerAddressIdFkeyInverseInput
}

"""
Input for the nested mutation of `project` in the `AddressInput` mutation.
"""
input ProjectBuildingOwnerAddressIdFkeyInverseInput {
  """
  Flag indicating whether all other `project` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  connectById: [ProjectProjectPkeyConnect!]

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  connectByNodeId: [ProjectNodeIdConnect!]

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  deleteById: [ProjectProjectPkeyDelete!]

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  deleteByNodeId: [ProjectNodeIdDelete!]

  """
  The primary key(s) and patch data for `project` for the far side of the relationship.
  """
  updateById: [ProjectOnProjectForProjectBuildingOwnerAddressIdFkeyUsingProjectPkeyUpdate!]

  """
  The primary key(s) and patch data for `project` for the far side of the relationship.
  """
  updateByNodeId: [AddressOnProjectForProjectBuildingOwnerAddressIdFkeyNodeIdUpdate!]

  """
  A `ProjectInput` object that will be created and connected to this object.
  """
  create: [ProjectBuildingOwnerAddressIdFkeyProjectCreateInput!]
}

"""
The fields on `project` to look up the row to update.
"""
input ProjectOnProjectForProjectBuildingOwnerAddressIdFkeyUsingProjectPkeyUpdate {
  """
  An object where the defined keys will be set on the `project` being updated.
  """
  patch: updateProjectOnProjectForProjectBuildingOwnerAddressIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `project` being updated.
"""
input updateProjectOnProjectForProjectBuildingOwnerAddressIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  companyId: Int

  """
  fk
  """
  siteAddressId: Int

  """
  ek
  """
  technology: Technology

  """
  Short name for the Project
  """
  name: String

  """
  Short description of what the Project is about.  Sometimes useful to clarify some points to BMI
  """
  description: String

  """
  If this is true then the Project should be hidden from End Users
  """
  hidden: Boolean

  """
  The number of square meters of roof that this project covers
  """
  roofArea: Int

  """
  Email address of the person who owns the building that the roof is going on.  Not mandatory for a Project, but mandatory when the Company applies for a Guarantee related to the project.
  """
  buildingOwnerMail: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerFirstname: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerLastname: String

  """
  Name of the Building Owner company if there is such a thing.  Not the same as an InTouch Company.
  """
  buildingOwnerCompany: String

  """
  The date that the Project officially starts or started
  """
  startDate: Datetime

  """
  The date that the Project officially expects to end or ended
  """
  endDate: Datetime
  createdAt: Datetime
  updatedAt: Datetime
  companyToCompanyId: ProjectCompanyIdFkeyInput
  addressToSiteAddressId: ProjectSiteAddressIdFkeyInput
  addressToBuildingOwnerAddressId: ProjectBuildingOwnerAddressIdFkeyInput
  evidenceItemsUsingId: EvidenceItemProjectIdFkeyInverseInput
  guaranteesUsingId: GuaranteeProjectIdFkeyInverseInput
  notesUsingId: NoteProjectIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberProjectIdFkeyInverseInput
}

"""
Input for the nested mutation of `address` in the `ProjectInput` mutation.
"""
input ProjectBuildingOwnerAddressIdFkeyInput {
  """
  The primary key(s) for `address` for the far side of the relationship.
  """
  connectById: AddressAddressPkeyConnect

  """
  The primary key(s) for `address` for the far side of the relationship.
  """
  connectByNodeId: AddressNodeIdConnect

  """
  The primary key(s) for `address` for the far side of the relationship.
  """
  deleteById: AddressAddressPkeyDelete

  """
  The primary key(s) for `address` for the far side of the relationship.
  """
  deleteByNodeId: AddressNodeIdDelete

  """
  The primary key(s) and patch data for `address` for the far side of the relationship.
  """
  updateById: AddressOnProjectForProjectBuildingOwnerAddressIdFkeyUsingAddressPkeyUpdate

  """
  The primary key(s) and patch data for `address` for the far side of the relationship.
  """
  updateByNodeId: ProjectOnProjectForProjectBuildingOwnerAddressIdFkeyNodeIdUpdate

  """
  A `AddressInput` object that will be created and connected to this object.
  """
  create: ProjectBuildingOwnerAddressIdFkeyAddressCreateInput
}

"""
The fields on `address` to look up the row to update.
"""
input AddressOnProjectForProjectBuildingOwnerAddressIdFkeyUsingAddressPkeyUpdate {
  """
  An object where the defined keys will be set on the `address` being updated.
  """
  patch: updateAddressOnProjectForProjectBuildingOwnerAddressIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `address` being updated.
"""
input updateAddressOnProjectForProjectBuildingOwnerAddressIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  First line of this address
  """
  firstLine: String

  """
  Second line of this address
  """
  secondLine: String

  """
  The postal town
  """
  town: String

  """
  The region if relevant
  """
  region: String

  """
  The country for this address
  """
  country: String

  """
  The postcode for this address
  """
  postcode: String

  """
  The coordinates on a map of the world
  """
  coordinates: PointInput

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String
  createdAt: Datetime
  updatedAt: Datetime
  companiesToRegisteredAddressIdUsingId: CompanyRegisteredAddressIdFkeyInverseInput
  companiesToTradingAddressIdUsingId: CompanyTradingAddressIdFkeyInverseInput
  projectsToSiteAddressIdUsingId: ProjectSiteAddressIdFkeyInverseInput
  projectsToBuildingOwnerAddressIdUsingId: ProjectBuildingOwnerAddressIdFkeyInverseInput
}

"""
The globally unique `ID` look up for the row to update.
"""
input ProjectOnProjectForProjectBuildingOwnerAddressIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `address` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `address` being updated.
  """
  patch: AddressPatch!
}

"""
Represents an update to a `Address`. Fields that are set will be updated.
"""
input AddressPatch {
  """
  Primary key
  """
  id: Int

  """
  First line of this address
  """
  firstLine: String

  """
  Second line of this address
  """
  secondLine: String

  """
  The postal town
  """
  town: String

  """
  The region if relevant
  """
  region: String

  """
  The country for this address
  """
  country: String

  """
  The postcode for this address
  """
  postcode: String

  """
  The coordinates on a map of the world
  """
  coordinates: PointInput

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String
  createdAt: Datetime
  updatedAt: Datetime
  companiesToRegisteredAddressIdUsingId: CompanyRegisteredAddressIdFkeyInverseInput
  companiesToTradingAddressIdUsingId: CompanyTradingAddressIdFkeyInverseInput
  projectsToSiteAddressIdUsingId: ProjectSiteAddressIdFkeyInverseInput
  projectsToBuildingOwnerAddressIdUsingId: ProjectBuildingOwnerAddressIdFkeyInverseInput
}

"""
The `address` to be created by this mutation.
"""
input ProjectBuildingOwnerAddressIdFkeyAddressCreateInput {
  """
  Primary key
  """
  id: Int

  """
  First line of this address
  """
  firstLine: String!

  """
  Second line of this address
  """
  secondLine: String

  """
  The postal town
  """
  town: String

  """
  The region if relevant
  """
  region: String

  """
  The country for this address
  """
  country: String

  """
  The postcode for this address
  """
  postcode: String!

  """
  The coordinates on a map of the world
  """
  coordinates: PointInput

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String
  createdAt: Datetime
  updatedAt: Datetime
  companiesToRegisteredAddressIdUsingId: CompanyRegisteredAddressIdFkeyInverseInput
  companiesToTradingAddressIdUsingId: CompanyTradingAddressIdFkeyInverseInput
  projectsToSiteAddressIdUsingId: ProjectSiteAddressIdFkeyInverseInput
  projectsToBuildingOwnerAddressIdUsingId: ProjectBuildingOwnerAddressIdFkeyInverseInput
}

"""
Input for the nested mutation of `evidenceItem` in the `ProjectInput` mutation.
"""
input EvidenceItemProjectIdFkeyInverseInput {
  """
  Flag indicating whether all other `evidenceItem` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `evidenceItem` for the far side of the relationship.
  """
  connectById: [EvidenceItemEvidenceItemPkeyConnect!]

  """
  The primary key(s) for `evidenceItem` for the far side of the relationship.
  """
  connectByNodeId: [EvidenceItemNodeIdConnect!]

  """
  The primary key(s) for `evidenceItem` for the far side of the relationship.
  """
  deleteById: [EvidenceItemEvidenceItemPkeyDelete!]

  """
  The primary key(s) for `evidenceItem` for the far side of the relationship.
  """
  deleteByNodeId: [EvidenceItemNodeIdDelete!]

  """
  The primary key(s) and patch data for `evidenceItem` for the far side of the relationship.
  """
  updateById: [EvidenceItemOnEvidenceItemForEvidenceItemProjectIdFkeyUsingEvidenceItemPkeyUpdate!]

  """
  The primary key(s) and patch data for `evidenceItem` for the far side of the relationship.
  """
  updateByNodeId: [ProjectOnEvidenceItemForEvidenceItemProjectIdFkeyNodeIdUpdate!]

  """
  A `EvidenceItemInput` object that will be created and connected to this object.
  """
  create: [EvidenceItemProjectIdFkeyEvidenceItemCreateInput!]
}

"""
The fields on `evidenceItem` to look up the row to connect.
"""
input EvidenceItemEvidenceItemPkeyConnect {
  """
  Primary key
  """
  id: Int!
}

"""
The globally unique `ID` look up for the row to connect.
"""
input EvidenceItemNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `evidenceItem` to be connected.
  """
  nodeId: ID!
}

"""
The fields on `evidenceItem` to look up the row to delete.
"""
input EvidenceItemEvidenceItemPkeyDelete {
  """
  Primary key
  """
  id: Int!
}

"""
The globally unique `ID` look up for the row to delete.
"""
input EvidenceItemNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `evidenceItem` to be deleted.
  """
  nodeId: ID!
}

"""
The fields on `evidenceItem` to look up the row to update.
"""
input EvidenceItemOnEvidenceItemForEvidenceItemProjectIdFkeyUsingEvidenceItemPkeyUpdate {
  """
  An object where the defined keys will be set on the `evidenceItem` being updated.
  """
  patch: updateEvidenceItemOnEvidenceItemForEvidenceItemProjectIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `evidenceItem` being updated.
"""
input updateEvidenceItemOnEvidenceItemForEvidenceItemProjectIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  a reference to the evidenceCategory sys id in Contentful
  """
  customEvidenceCategoryId: String

  """
  fk
  """
  guaranteeId: Int

  """
  ek
  """
  evidenceCategoryType: EvidenceCategoryType

  """
  Short name for the item of evidence
  """
  name: String

  """
  File reference or the file itself. Photo of the evidence
  """
  attachment: String
  createdAt: Datetime
  updatedAt: Datetime
  projectToProjectId: EvidenceItemProjectIdFkeyInput
  guaranteeToGuaranteeId: EvidenceItemGuaranteeIdFkeyInput
}

"""
Input for the nested mutation of `project` in the `EvidenceItemInput` mutation.
"""
input EvidenceItemProjectIdFkeyInput {
  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  connectById: ProjectProjectPkeyConnect

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  connectByNodeId: ProjectNodeIdConnect

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  deleteById: ProjectProjectPkeyDelete

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  deleteByNodeId: ProjectNodeIdDelete

  """
  The primary key(s) and patch data for `project` for the far side of the relationship.
  """
  updateById: ProjectOnEvidenceItemForEvidenceItemProjectIdFkeyUsingProjectPkeyUpdate

  """
  The primary key(s) and patch data for `project` for the far side of the relationship.
  """
  updateByNodeId: EvidenceItemOnEvidenceItemForEvidenceItemProjectIdFkeyNodeIdUpdate

  """
  A `ProjectInput` object that will be created and connected to this object.
  """
  create: EvidenceItemProjectIdFkeyProjectCreateInput
}

"""
The fields on `project` to look up the row to update.
"""
input ProjectOnEvidenceItemForEvidenceItemProjectIdFkeyUsingProjectPkeyUpdate {
  """
  An object where the defined keys will be set on the `project` being updated.
  """
  patch: updateProjectOnEvidenceItemForEvidenceItemProjectIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `project` being updated.
"""
input updateProjectOnEvidenceItemForEvidenceItemProjectIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  companyId: Int

  """
  fk
  """
  siteAddressId: Int

  """
  fk
  """
  buildingOwnerAddressId: Int

  """
  ek
  """
  technology: Technology

  """
  Short name for the Project
  """
  name: String

  """
  Short description of what the Project is about.  Sometimes useful to clarify some points to BMI
  """
  description: String

  """
  If this is true then the Project should be hidden from End Users
  """
  hidden: Boolean

  """
  The number of square meters of roof that this project covers
  """
  roofArea: Int

  """
  Email address of the person who owns the building that the roof is going on.  Not mandatory for a Project, but mandatory when the Company applies for a Guarantee related to the project.
  """
  buildingOwnerMail: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerFirstname: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerLastname: String

  """
  Name of the Building Owner company if there is such a thing.  Not the same as an InTouch Company.
  """
  buildingOwnerCompany: String

  """
  The date that the Project officially starts or started
  """
  startDate: Datetime

  """
  The date that the Project officially expects to end or ended
  """
  endDate: Datetime
  createdAt: Datetime
  updatedAt: Datetime
  companyToCompanyId: ProjectCompanyIdFkeyInput
  addressToSiteAddressId: ProjectSiteAddressIdFkeyInput
  addressToBuildingOwnerAddressId: ProjectBuildingOwnerAddressIdFkeyInput
  evidenceItemsUsingId: EvidenceItemProjectIdFkeyInverseInput
  guaranteesUsingId: GuaranteeProjectIdFkeyInverseInput
  notesUsingId: NoteProjectIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberProjectIdFkeyInverseInput
}

"""
Input for the nested mutation of `guarantee` in the `ProjectInput` mutation.
"""
input GuaranteeProjectIdFkeyInverseInput {
  """
  Flag indicating whether all other `guarantee` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  connectById: [GuaranteeGuaranteePkeyConnect!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  connectByBmiReferenceId: [GuaranteeGuaranteeBmiReferenceIdKeyConnect!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  connectByNodeId: [GuaranteeNodeIdConnect!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  deleteById: [GuaranteeGuaranteePkeyDelete!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  deleteByBmiReferenceId: [GuaranteeGuaranteeBmiReferenceIdKeyDelete!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  deleteByNodeId: [GuaranteeNodeIdDelete!]

  """
  The primary key(s) and patch data for `guarantee` for the far side of the relationship.
  """
  updateById: [GuaranteeOnGuaranteeForGuaranteeProjectIdFkeyUsingGuaranteePkeyUpdate!]

  """
  The primary key(s) and patch data for `guarantee` for the far side of the relationship.
  """
  updateByBmiReferenceId: [GuaranteeOnGuaranteeForGuaranteeProjectIdFkeyUsingGuaranteeBmiReferenceIdKeyUpdate!]

  """
  The primary key(s) and patch data for `guarantee` for the far side of the relationship.
  """
  updateByNodeId: [ProjectOnGuaranteeForGuaranteeProjectIdFkeyNodeIdUpdate!]

  """
  A `GuaranteeInput` object that will be created and connected to this object.
  """
  create: [GuaranteeProjectIdFkeyGuaranteeCreateInput!]
}

"""
The fields on `guarantee` to look up the row to update.
"""
input GuaranteeOnGuaranteeForGuaranteeProjectIdFkeyUsingGuaranteePkeyUpdate {
  """
  An object where the defined keys will be set on the `guarantee` being updated.
  """
  patch: updateGuaranteeOnGuaranteeForGuaranteeProjectIdFkeyPatch!

  """
  Primary key - starts at 6100
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `guarantee` being updated.
"""
input updateGuaranteeOnGuaranteeForGuaranteeProjectIdFkeyPatch {
  """
  Primary key - starts at 6100
  """
  id: Int

  """
  The pdf file that is emailed out, or a reference to it, or reference to the service that will generate it on demand
  """
  fileStorageId: String

  """
  fk
  """
  requestorAccountId: Int

  """
  a reference to the guaranteeType sys id in Contentful
  """
  guaranteeTypeId: String

  """
  fk
  """
  systemBmiRef: String

  """
  fk
  """
  productBmiRef: String

  """
  fk
  """
  reviewerAccountId: Int

  """
  a reference to the guaranteeType sys id in Contentful
  """
  guaranteeTemplateId: String

  """
  ek
  """
  status: RequestStatus

  """
  The date that the Guarantee is approved either automatically or manually
  """
  startDate: Datetime

  """
  When the guarantee will expire.  This should be calculated when the request_status becomes APPROVED. dependent on the StartDate, the Validity of the Product or System and the ValidityOffset in this Tier
  """
  expiryDate: Datetime

  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String
  createdAt: Datetime
  updatedAt: Datetime
  accountToRequestorAccountId: GuaranteeRequestorAccountIdFkeyInput
  projectToProjectId: GuaranteeProjectIdFkeyInput
  systemToSystemBmiRef: GuaranteeSystemBmiRefFkeyInput
  productToProductBmiRef: GuaranteeProductBmiRefFkeyInput
  accountToReviewerAccountId: GuaranteeReviewerAccountIdFkeyInput
  evidenceItemsUsingId: EvidenceItemGuaranteeIdFkeyInverseInput
}

"""
Input for the nested mutation of `system` in the `GuaranteeInput` mutation.
"""
input GuaranteeSystemBmiRefFkeyInput {
  """
  The primary key(s) for `system` for the far side of the relationship.
  """
  connectById: SystemSystemPkeyConnect

  """
  The primary key(s) for `system` for the far side of the relationship.
  """
  connectByBmiRef: SystemSystemBmiRefKeyConnect

  """
  The primary key(s) for `system` for the far side of the relationship.
  """
  connectByNodeId: SystemNodeIdConnect

  """
  The primary key(s) for `system` for the far side of the relationship.
  """
  deleteById: SystemSystemPkeyDelete

  """
  The primary key(s) for `system` for the far side of the relationship.
  """
  deleteByBmiRef: SystemSystemBmiRefKeyDelete

  """
  The primary key(s) for `system` for the far side of the relationship.
  """
  deleteByNodeId: SystemNodeIdDelete

  """
  The primary key(s) and patch data for `system` for the far side of the relationship.
  """
  updateById: SystemOnGuaranteeForGuaranteeSystemBmiRefFkeyUsingSystemPkeyUpdate

  """
  The primary key(s) and patch data for `system` for the far side of the relationship.
  """
  updateByBmiRef: SystemOnGuaranteeForGuaranteeSystemBmiRefFkeyUsingSystemBmiRefKeyUpdate

  """
  The primary key(s) and patch data for `system` for the far side of the relationship.
  """
  updateByNodeId: GuaranteeOnGuaranteeForGuaranteeSystemBmiRefFkeyNodeIdUpdate

  """
  A `SystemInput` object that will be created and connected to this object.
  """
  create: GuaranteeSystemBmiRefFkeySystemCreateInput
}

"""
The fields on `system` to look up the row to connect.
"""
input SystemSystemPkeyConnect {
  """
  Primary key
  """
  id: Int!
}

"""
The fields on `system` to look up the row to connect.
"""
input SystemSystemBmiRefKeyConnect {
  """
  A unique reference for the system known to BMI
  """
  bmiRef: String!
}

"""
The globally unique `ID` look up for the row to connect.
"""
input SystemNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `system` to be connected.
  """
  nodeId: ID!
}

"""
The fields on `system` to look up the row to delete.
"""
input SystemSystemPkeyDelete {
  """
  Primary key
  """
  id: Int!
}

"""
The fields on `system` to look up the row to delete.
"""
input SystemSystemBmiRefKeyDelete {
  """
  A unique reference for the system known to BMI
  """
  bmiRef: String!
}

"""
The globally unique `ID` look up for the row to delete.
"""
input SystemNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `system` to be deleted.
  """
  nodeId: ID!
}

"""
The fields on `system` to look up the row to update.
"""
input SystemOnGuaranteeForGuaranteeSystemBmiRefFkeyUsingSystemPkeyUpdate {
  """
  An object where the defined keys will be set on the `system` being updated.
  """
  patch: updateSystemOnGuaranteeForGuaranteeSystemBmiRefFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `system` being updated.
"""
input updateSystemOnGuaranteeForGuaranteeSystemBmiRefFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int

  """
  ek
  """
  technology: Technology

  """
  A unique reference for the system known to BMI
  """
  bmiRef: String

  """
  Short name for the System
  """
  name: String

  """
  A description for the System
  """
  description: String

  """
  The maximum number of years that this system can be guaranteed for.  Must be greater than 10.
  """
  maximumValidityYears: Int

  """
  If true this system is available for users to select when applying for a system or solution guarantee
  """
  published: Boolean
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: SystemMarketIdFkeyInput
  guaranteesUsingBmiRef: GuaranteeSystemBmiRefFkeyInverseInput
  systemMembersUsingBmiRef: SystemMemberSystemBmiRefFkeyInverseInput
}

"""
Input for the nested mutation of `market` in the `SystemInput` mutation.
"""
input SystemMarketIdFkeyInput {
  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectById: MarketMarketPkeyConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectByDomain: MarketMarketDomainKeyConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectByDoceboCatalogueId: MarketMarketDoceboCatalogueIdKeyConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectByNodeId: MarketNodeIdConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteById: MarketMarketPkeyDelete

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteByDomain: MarketMarketDomainKeyDelete

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteByDoceboCatalogueId: MarketMarketDoceboCatalogueIdKeyDelete

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteByNodeId: MarketNodeIdDelete

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateById: MarketOnSystemForSystemMarketIdFkeyUsingMarketPkeyUpdate

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateByDomain: MarketOnSystemForSystemMarketIdFkeyUsingMarketDomainKeyUpdate

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateByDoceboCatalogueId: MarketOnSystemForSystemMarketIdFkeyUsingMarketDoceboCatalogueIdKeyUpdate

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateByNodeId: SystemOnSystemForSystemMarketIdFkeyNodeIdUpdate

  """
  A `MarketInput` object that will be created and connected to this object.
  """
  create: SystemMarketIdFkeyMarketCreateInput
}

"""
The fields on `market` to look up the row to update.
"""
input MarketOnSystemForSystemMarketIdFkeyUsingMarketPkeyUpdate {
  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: updateMarketOnSystemForSystemMarketIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `market` being updated.
"""
input updateMarketOnSystemForSystemMarketIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  ek
  """
  language: Language

  """
  the country code used for example as the subdomain
  """
  domain: String

  """
  The space in Contenful
  """
  cmsSpaceId: String

  """
  A short name for the market, e.g. Italy, Norway, Netherlands
  """
  name: String

  """
  The From name used when sending an email
  """
  sendName: String

  """
  The mailbox on intouch.bmigroup.com that emails will be sent from for this Market
  """
  sendMailbox: String

  """
  The default branch in Docebo that installers go into
  """
  doceboInstallersBranchId: String

  """
  The branch in Docebo that company admins go into
  """
  doceboCompanyAdminBranchId: String

  """
  The default catalogue for the market.  All users in the market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int

  """
  The address of the merchandising site for the market.  CTAs of the MERCHANDISING type will link to this address
  """
  merchandisingUrl: String

  """
  Whether the market supports Projects.  If so then the Projects link should be available in th left hand navigation.
  """
  projectsEnabled: Boolean

  """
  Reference to the Google Analytics tracking ID that is used for the Country GA reports
  """
  gtag: String

  """
  The coordinates of the middle of the Market on a map
  """
  geoMiddle: PointInput

  """
  The length of the radius in km (from the geo_middle lat/lng), for which the Google Places API biases the search results for address autocomplete. Locations outside of the radius will not be excluded.
  """
  locationBiasRadiusKm: Int
  createdAt: Datetime
  updatedAt: Datetime
  accountsUsingId: AccountMarketIdFkeyInverseInput
  companiesUsingId: CompanyMarketIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberMarketIdFkeyInverseInput
  productsUsingId: ProductMarketIdFkeyInverseInput
  systemsUsingId: SystemMarketIdFkeyInverseInput
  systemMembersUsingId: SystemMemberMarketIdFkeyInverseInput
}

"""
Input for the nested mutation of `product` in the `MarketInput` mutation.
"""
input ProductMarketIdFkeyInverseInput {
  """
  Flag indicating whether all other `product` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `product` for the far side of the relationship.
  """
  connectById: [ProductProductPkeyConnect!]

  """
  The primary key(s) for `product` for the far side of the relationship.
  """
  connectByBmiRef: [ProductProductBmiRefKeyConnect!]

  """
  The primary key(s) for `product` for the far side of the relationship.
  """
  connectByNodeId: [ProductNodeIdConnect!]

  """
  The primary key(s) for `product` for the far side of the relationship.
  """
  deleteById: [ProductProductPkeyDelete!]

  """
  The primary key(s) for `product` for the far side of the relationship.
  """
  deleteByBmiRef: [ProductProductBmiRefKeyDelete!]

  """
  The primary key(s) for `product` for the far side of the relationship.
  """
  deleteByNodeId: [ProductNodeIdDelete!]

  """
  The primary key(s) and patch data for `product` for the far side of the relationship.
  """
  updateById: [ProductOnProductForProductMarketIdFkeyUsingProductPkeyUpdate!]

  """
  The primary key(s) and patch data for `product` for the far side of the relationship.
  """
  updateByBmiRef: [ProductOnProductForProductMarketIdFkeyUsingProductBmiRefKeyUpdate!]

  """
  The primary key(s) and patch data for `product` for the far side of the relationship.
  """
  updateByNodeId: [MarketOnProductForProductMarketIdFkeyNodeIdUpdate!]

  """
  A `ProductInput` object that will be created and connected to this object.
  """
  create: [ProductMarketIdFkeyProductCreateInput!]
}

"""
The fields on `product` to look up the row to connect.
"""
input ProductProductPkeyConnect {
  """
  Primary key
  """
  id: Int!
}

"""
The fields on `product` to look up the row to connect.
"""
input ProductProductBmiRefKeyConnect {
  """
  A unique reference for the product known to BMI
  """
  bmiRef: String!
}

"""
The globally unique `ID` look up for the row to connect.
"""
input ProductNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `product` to be connected.
  """
  nodeId: ID!
}

"""
The fields on `product` to look up the row to delete.
"""
input ProductProductPkeyDelete {
  """
  Primary key
  """
  id: Int!
}

"""
The fields on `product` to look up the row to delete.
"""
input ProductProductBmiRefKeyDelete {
  """
  A unique reference for the product known to BMI
  """
  bmiRef: String!
}

"""
The globally unique `ID` look up for the row to delete.
"""
input ProductNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `product` to be deleted.
  """
  nodeId: ID!
}

"""
The fields on `product` to look up the row to update.
"""
input ProductOnProductForProductMarketIdFkeyUsingProductPkeyUpdate {
  """
  An object where the defined keys will be set on the `product` being updated.
  """
  patch: updateProductOnProductForProductMarketIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `product` being updated.
"""
input updateProductOnProductForProductMarketIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  ek
  """
  technology: Technology

  """
  A unique reference for the product known to BMI
  """
  bmiRef: String

  """
  The Products brand
  """
  brand: String

  """
  Short name for the Product
  """
  name: String

  """
  A description of the Product
  """
  description: String

  """
  The family of Products this Product is in
  """
  family: String

  """
  Whether the Product is avialable for new guarantees
  """
  published: Boolean

  """
  The number of years that this product can be guaranteed for
  """
  maximumValidityYears: Int
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: ProductMarketIdFkeyInput
  guaranteesUsingBmiRef: GuaranteeProductBmiRefFkeyInverseInput
  systemMembersUsingBmiRef: SystemMemberProductBmiRefFkeyInverseInput
}

"""
Input for the nested mutation of `market` in the `ProductInput` mutation.
"""
input ProductMarketIdFkeyInput {
  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectById: MarketMarketPkeyConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectByDomain: MarketMarketDomainKeyConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectByDoceboCatalogueId: MarketMarketDoceboCatalogueIdKeyConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectByNodeId: MarketNodeIdConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteById: MarketMarketPkeyDelete

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteByDomain: MarketMarketDomainKeyDelete

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteByDoceboCatalogueId: MarketMarketDoceboCatalogueIdKeyDelete

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteByNodeId: MarketNodeIdDelete

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateById: MarketOnProductForProductMarketIdFkeyUsingMarketPkeyUpdate

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateByDomain: MarketOnProductForProductMarketIdFkeyUsingMarketDomainKeyUpdate

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateByDoceboCatalogueId: MarketOnProductForProductMarketIdFkeyUsingMarketDoceboCatalogueIdKeyUpdate

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateByNodeId: ProductOnProductForProductMarketIdFkeyNodeIdUpdate

  """
  A `MarketInput` object that will be created and connected to this object.
  """
  create: ProductMarketIdFkeyMarketCreateInput
}

"""
The fields on `market` to look up the row to update.
"""
input MarketOnProductForProductMarketIdFkeyUsingMarketPkeyUpdate {
  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: updateMarketOnProductForProductMarketIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `market` being updated.
"""
input updateMarketOnProductForProductMarketIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  ek
  """
  language: Language

  """
  the country code used for example as the subdomain
  """
  domain: String

  """
  The space in Contenful
  """
  cmsSpaceId: String

  """
  A short name for the market, e.g. Italy, Norway, Netherlands
  """
  name: String

  """
  The From name used when sending an email
  """
  sendName: String

  """
  The mailbox on intouch.bmigroup.com that emails will be sent from for this Market
  """
  sendMailbox: String

  """
  The default branch in Docebo that installers go into
  """
  doceboInstallersBranchId: String

  """
  The branch in Docebo that company admins go into
  """
  doceboCompanyAdminBranchId: String

  """
  The default catalogue for the market.  All users in the market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int

  """
  The address of the merchandising site for the market.  CTAs of the MERCHANDISING type will link to this address
  """
  merchandisingUrl: String

  """
  Whether the market supports Projects.  If so then the Projects link should be available in th left hand navigation.
  """
  projectsEnabled: Boolean

  """
  Reference to the Google Analytics tracking ID that is used for the Country GA reports
  """
  gtag: String

  """
  The coordinates of the middle of the Market on a map
  """
  geoMiddle: PointInput

  """
  The length of the radius in km (from the geo_middle lat/lng), for which the Google Places API biases the search results for address autocomplete. Locations outside of the radius will not be excluded.
  """
  locationBiasRadiusKm: Int
  createdAt: Datetime
  updatedAt: Datetime
  accountsUsingId: AccountMarketIdFkeyInverseInput
  companiesUsingId: CompanyMarketIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberMarketIdFkeyInverseInput
  productsUsingId: ProductMarketIdFkeyInverseInput
  systemsUsingId: SystemMarketIdFkeyInverseInput
  systemMembersUsingId: SystemMemberMarketIdFkeyInverseInput
}

"""
Input for the nested mutation of `system` in the `MarketInput` mutation.
"""
input SystemMarketIdFkeyInverseInput {
  """
  Flag indicating whether all other `system` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `system` for the far side of the relationship.
  """
  connectById: [SystemSystemPkeyConnect!]

  """
  The primary key(s) for `system` for the far side of the relationship.
  """
  connectByBmiRef: [SystemSystemBmiRefKeyConnect!]

  """
  The primary key(s) for `system` for the far side of the relationship.
  """
  connectByNodeId: [SystemNodeIdConnect!]

  """
  The primary key(s) for `system` for the far side of the relationship.
  """
  deleteById: [SystemSystemPkeyDelete!]

  """
  The primary key(s) for `system` for the far side of the relationship.
  """
  deleteByBmiRef: [SystemSystemBmiRefKeyDelete!]

  """
  The primary key(s) for `system` for the far side of the relationship.
  """
  deleteByNodeId: [SystemNodeIdDelete!]

  """
  The primary key(s) and patch data for `system` for the far side of the relationship.
  """
  updateById: [SystemOnSystemForSystemMarketIdFkeyUsingSystemPkeyUpdate!]

  """
  The primary key(s) and patch data for `system` for the far side of the relationship.
  """
  updateByBmiRef: [SystemOnSystemForSystemMarketIdFkeyUsingSystemBmiRefKeyUpdate!]

  """
  The primary key(s) and patch data for `system` for the far side of the relationship.
  """
  updateByNodeId: [MarketOnSystemForSystemMarketIdFkeyNodeIdUpdate!]

  """
  A `SystemInput` object that will be created and connected to this object.
  """
  create: [SystemMarketIdFkeySystemCreateInput!]
}

"""
The fields on `system` to look up the row to update.
"""
input SystemOnSystemForSystemMarketIdFkeyUsingSystemPkeyUpdate {
  """
  An object where the defined keys will be set on the `system` being updated.
  """
  patch: updateSystemOnSystemForSystemMarketIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `system` being updated.
"""
input updateSystemOnSystemForSystemMarketIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  ek
  """
  technology: Technology

  """
  A unique reference for the system known to BMI
  """
  bmiRef: String

  """
  Short name for the System
  """
  name: String

  """
  A description for the System
  """
  description: String

  """
  The maximum number of years that this system can be guaranteed for.  Must be greater than 10.
  """
  maximumValidityYears: Int

  """
  If true this system is available for users to select when applying for a system or solution guarantee
  """
  published: Boolean
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: SystemMarketIdFkeyInput
  guaranteesUsingBmiRef: GuaranteeSystemBmiRefFkeyInverseInput
  systemMembersUsingBmiRef: SystemMemberSystemBmiRefFkeyInverseInput
}

"""
Input for the nested mutation of `guarantee` in the `SystemInput` mutation.
"""
input GuaranteeSystemBmiRefFkeyInverseInput {
  """
  Flag indicating whether all other `guarantee` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  connectById: [GuaranteeGuaranteePkeyConnect!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  connectByBmiReferenceId: [GuaranteeGuaranteeBmiReferenceIdKeyConnect!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  connectByNodeId: [GuaranteeNodeIdConnect!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  deleteById: [GuaranteeGuaranteePkeyDelete!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  deleteByBmiReferenceId: [GuaranteeGuaranteeBmiReferenceIdKeyDelete!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  deleteByNodeId: [GuaranteeNodeIdDelete!]

  """
  The primary key(s) and patch data for `guarantee` for the far side of the relationship.
  """
  updateById: [GuaranteeOnGuaranteeForGuaranteeSystemBmiRefFkeyUsingGuaranteePkeyUpdate!]

  """
  The primary key(s) and patch data for `guarantee` for the far side of the relationship.
  """
  updateByBmiReferenceId: [GuaranteeOnGuaranteeForGuaranteeSystemBmiRefFkeyUsingGuaranteeBmiReferenceIdKeyUpdate!]

  """
  The primary key(s) and patch data for `guarantee` for the far side of the relationship.
  """
  updateByNodeId: [SystemOnGuaranteeForGuaranteeSystemBmiRefFkeyNodeIdUpdate!]

  """
  A `GuaranteeInput` object that will be created and connected to this object.
  """
  create: [GuaranteeSystemBmiRefFkeyGuaranteeCreateInput!]
}

"""
The fields on `guarantee` to look up the row to update.
"""
input GuaranteeOnGuaranteeForGuaranteeSystemBmiRefFkeyUsingGuaranteePkeyUpdate {
  """
  An object where the defined keys will be set on the `guarantee` being updated.
  """
  patch: updateGuaranteeOnGuaranteeForGuaranteeSystemBmiRefFkeyPatch!

  """
  Primary key - starts at 6100
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `guarantee` being updated.
"""
input updateGuaranteeOnGuaranteeForGuaranteeSystemBmiRefFkeyPatch {
  """
  Primary key - starts at 6100
  """
  id: Int

  """
  The pdf file that is emailed out, or a reference to it, or reference to the service that will generate it on demand
  """
  fileStorageId: String

  """
  fk
  """
  requestorAccountId: Int

  """
  fk
  """
  projectId: Int

  """
  a reference to the guaranteeType sys id in Contentful
  """
  guaranteeTypeId: String

  """
  fk
  """
  productBmiRef: String

  """
  fk
  """
  reviewerAccountId: Int

  """
  a reference to the guaranteeType sys id in Contentful
  """
  guaranteeTemplateId: String

  """
  ek
  """
  status: RequestStatus

  """
  The date that the Guarantee is approved either automatically or manually
  """
  startDate: Datetime

  """
  When the guarantee will expire.  This should be calculated when the request_status becomes APPROVED. dependent on the StartDate, the Validity of the Product or System and the ValidityOffset in this Tier
  """
  expiryDate: Datetime

  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String
  createdAt: Datetime
  updatedAt: Datetime
  accountToRequestorAccountId: GuaranteeRequestorAccountIdFkeyInput
  projectToProjectId: GuaranteeProjectIdFkeyInput
  systemToSystemBmiRef: GuaranteeSystemBmiRefFkeyInput
  productToProductBmiRef: GuaranteeProductBmiRefFkeyInput
  accountToReviewerAccountId: GuaranteeReviewerAccountIdFkeyInput
  evidenceItemsUsingId: EvidenceItemGuaranteeIdFkeyInverseInput
}

"""
Input for the nested mutation of `product` in the `GuaranteeInput` mutation.
"""
input GuaranteeProductBmiRefFkeyInput {
  """
  The primary key(s) for `product` for the far side of the relationship.
  """
  connectById: ProductProductPkeyConnect

  """
  The primary key(s) for `product` for the far side of the relationship.
  """
  connectByBmiRef: ProductProductBmiRefKeyConnect

  """
  The primary key(s) for `product` for the far side of the relationship.
  """
  connectByNodeId: ProductNodeIdConnect

  """
  The primary key(s) for `product` for the far side of the relationship.
  """
  deleteById: ProductProductPkeyDelete

  """
  The primary key(s) for `product` for the far side of the relationship.
  """
  deleteByBmiRef: ProductProductBmiRefKeyDelete

  """
  The primary key(s) for `product` for the far side of the relationship.
  """
  deleteByNodeId: ProductNodeIdDelete

  """
  The primary key(s) and patch data for `product` for the far side of the relationship.
  """
  updateById: ProductOnGuaranteeForGuaranteeProductBmiRefFkeyUsingProductPkeyUpdate

  """
  The primary key(s) and patch data for `product` for the far side of the relationship.
  """
  updateByBmiRef: ProductOnGuaranteeForGuaranteeProductBmiRefFkeyUsingProductBmiRefKeyUpdate

  """
  The primary key(s) and patch data for `product` for the far side of the relationship.
  """
  updateByNodeId: GuaranteeOnGuaranteeForGuaranteeProductBmiRefFkeyNodeIdUpdate

  """
  A `ProductInput` object that will be created and connected to this object.
  """
  create: GuaranteeProductBmiRefFkeyProductCreateInput
}

"""
The fields on `product` to look up the row to update.
"""
input ProductOnGuaranteeForGuaranteeProductBmiRefFkeyUsingProductPkeyUpdate {
  """
  An object where the defined keys will be set on the `product` being updated.
  """
  patch: updateProductOnGuaranteeForGuaranteeProductBmiRefFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `product` being updated.
"""
input updateProductOnGuaranteeForGuaranteeProductBmiRefFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int

  """
  ek
  """
  technology: Technology

  """
  A unique reference for the product known to BMI
  """
  bmiRef: String

  """
  The Products brand
  """
  brand: String

  """
  Short name for the Product
  """
  name: String

  """
  A description of the Product
  """
  description: String

  """
  The family of Products this Product is in
  """
  family: String

  """
  Whether the Product is avialable for new guarantees
  """
  published: Boolean

  """
  The number of years that this product can be guaranteed for
  """
  maximumValidityYears: Int
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: ProductMarketIdFkeyInput
  guaranteesUsingBmiRef: GuaranteeProductBmiRefFkeyInverseInput
  systemMembersUsingBmiRef: SystemMemberProductBmiRefFkeyInverseInput
}

"""
Input for the nested mutation of `guarantee` in the `ProductInput` mutation.
"""
input GuaranteeProductBmiRefFkeyInverseInput {
  """
  Flag indicating whether all other `guarantee` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  connectById: [GuaranteeGuaranteePkeyConnect!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  connectByBmiReferenceId: [GuaranteeGuaranteeBmiReferenceIdKeyConnect!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  connectByNodeId: [GuaranteeNodeIdConnect!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  deleteById: [GuaranteeGuaranteePkeyDelete!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  deleteByBmiReferenceId: [GuaranteeGuaranteeBmiReferenceIdKeyDelete!]

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  deleteByNodeId: [GuaranteeNodeIdDelete!]

  """
  The primary key(s) and patch data for `guarantee` for the far side of the relationship.
  """
  updateById: [GuaranteeOnGuaranteeForGuaranteeProductBmiRefFkeyUsingGuaranteePkeyUpdate!]

  """
  The primary key(s) and patch data for `guarantee` for the far side of the relationship.
  """
  updateByBmiReferenceId: [GuaranteeOnGuaranteeForGuaranteeProductBmiRefFkeyUsingGuaranteeBmiReferenceIdKeyUpdate!]

  """
  The primary key(s) and patch data for `guarantee` for the far side of the relationship.
  """
  updateByNodeId: [ProductOnGuaranteeForGuaranteeProductBmiRefFkeyNodeIdUpdate!]

  """
  A `GuaranteeInput` object that will be created and connected to this object.
  """
  create: [GuaranteeProductBmiRefFkeyGuaranteeCreateInput!]
}

"""
The fields on `guarantee` to look up the row to update.
"""
input GuaranteeOnGuaranteeForGuaranteeProductBmiRefFkeyUsingGuaranteePkeyUpdate {
  """
  An object where the defined keys will be set on the `guarantee` being updated.
  """
  patch: updateGuaranteeOnGuaranteeForGuaranteeProductBmiRefFkeyPatch!

  """
  Primary key - starts at 6100
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `guarantee` being updated.
"""
input updateGuaranteeOnGuaranteeForGuaranteeProductBmiRefFkeyPatch {
  """
  Primary key - starts at 6100
  """
  id: Int

  """
  The pdf file that is emailed out, or a reference to it, or reference to the service that will generate it on demand
  """
  fileStorageId: String

  """
  fk
  """
  requestorAccountId: Int

  """
  fk
  """
  projectId: Int

  """
  a reference to the guaranteeType sys id in Contentful
  """
  guaranteeTypeId: String

  """
  fk
  """
  systemBmiRef: String

  """
  fk
  """
  reviewerAccountId: Int

  """
  a reference to the guaranteeType sys id in Contentful
  """
  guaranteeTemplateId: String

  """
  ek
  """
  status: RequestStatus

  """
  The date that the Guarantee is approved either automatically or manually
  """
  startDate: Datetime

  """
  When the guarantee will expire.  This should be calculated when the request_status becomes APPROVED. dependent on the StartDate, the Validity of the Product or System and the ValidityOffset in this Tier
  """
  expiryDate: Datetime

  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String
  createdAt: Datetime
  updatedAt: Datetime
  accountToRequestorAccountId: GuaranteeRequestorAccountIdFkeyInput
  projectToProjectId: GuaranteeProjectIdFkeyInput
  systemToSystemBmiRef: GuaranteeSystemBmiRefFkeyInput
  productToProductBmiRef: GuaranteeProductBmiRefFkeyInput
  accountToReviewerAccountId: GuaranteeReviewerAccountIdFkeyInput
  evidenceItemsUsingId: EvidenceItemGuaranteeIdFkeyInverseInput
}

"""
Input for the nested mutation of `account` in the `GuaranteeInput` mutation.
"""
input GuaranteeReviewerAccountIdFkeyInput {
  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectById: AccountAccountPkeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByEmail: AccountAccountEmailKeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByDoceboUserId: AccountAccountDoceboUserIdKeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByNodeId: AccountNodeIdConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteById: AccountAccountPkeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByEmail: AccountAccountEmailKeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByDoceboUserId: AccountAccountDoceboUserIdKeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByNodeId: AccountNodeIdDelete

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateById: AccountOnGuaranteeForGuaranteeReviewerAccountIdFkeyUsingAccountPkeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByEmail: AccountOnGuaranteeForGuaranteeReviewerAccountIdFkeyUsingAccountEmailKeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByDoceboUserId: AccountOnGuaranteeForGuaranteeReviewerAccountIdFkeyUsingAccountDoceboUserIdKeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByNodeId: GuaranteeOnGuaranteeForGuaranteeReviewerAccountIdFkeyNodeIdUpdate
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnGuaranteeForGuaranteeReviewerAccountIdFkeyUsingAccountPkeyUpdate {
  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnGuaranteeForGuaranteeReviewerAccountIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `account` being updated.
"""
input updateAccountOnGuaranteeForGuaranteeReviewerAccountIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  ek
  """
  status: AccountStatus

  """
  fk
  """
  marketId: Int

  """
  ek
  """
  role: Role

  """
  The email address associated with the account
  """
  email: String

  """
  A phone number that can optionally be provided, and is useful for Company Admin people to provide
  """
  phone: String

  """
  First name
  """
  firstName: String

  """
  Last name
  """
  lastName: String

  """
  When the account was created
  """
  created: Datetime

  """
  User account in Docebo
  """
  doceboUserId: Int

  """
  Username in Docebo.  Needed to generate the SSO link
  """
  doceboUsername: String

  """
  File reference. A profile picture of the user
  """
  photo: String

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: AccountMarketIdFkeyInput
  certificationsUsingDoceboUserId: CertificationDoceboUserIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberAccountIdFkeyInverseInput
  guaranteesToRequestorAccountIdUsingId: GuaranteeRequestorAccountIdFkeyInverseInput
  guaranteesToReviewerAccountIdUsingId: GuaranteeReviewerAccountIdFkeyInverseInput
  invitationsUsingId: InvitationSenderAccountIdFkeyInverseInput
  notesUsingId: NoteAuthorIdFkeyInverseInput
  notificationsUsingId: NotificationAccountIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberAccountIdFkeyInverseInput
  photoUpload: Upload
  shouldRemovePhoto: Boolean
}

"""
Input for the nested mutation of `invitation` in the `AccountInput` mutation.
"""
input InvitationSenderAccountIdFkeyInverseInput {
  """
  Flag indicating whether all other `invitation` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `invitation` for the far side of the relationship.
  """
  connectById: [InvitationInvitationPkeyConnect!]

  """
  The primary key(s) for `invitation` for the far side of the relationship.
  """
  connectByNodeId: [InvitationNodeIdConnect!]

  """
  The primary key(s) for `invitation` for the far side of the relationship.
  """
  deleteById: [InvitationInvitationPkeyDelete!]

  """
  The primary key(s) for `invitation` for the far side of the relationship.
  """
  deleteByNodeId: [InvitationNodeIdDelete!]

  """
  The primary key(s) and patch data for `invitation` for the far side of the relationship.
  """
  updateById: [InvitationOnInvitationForInvitationSenderAccountIdFkeyUsingInvitationPkeyUpdate!]

  """
  The primary key(s) and patch data for `invitation` for the far side of the relationship.
  """
  updateByNodeId: [AccountOnInvitationForInvitationSenderAccountIdFkeyNodeIdUpdate!]
}

"""
The fields on `invitation` to look up the row to update.
"""
input InvitationOnInvitationForInvitationSenderAccountIdFkeyUsingInvitationPkeyUpdate {
  """
  An object where the defined keys will be set on the `invitation` being updated.
  """
  patch: updateInvitationOnInvitationForInvitationSenderAccountIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `invitation` being updated.
"""
input updateInvitationOnInvitationForInvitationSenderAccountIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  companyId: Int

  """
  ek
  """
  status: InvitationStatus

  """
  An email address
  """
  invitee: String

  """
  An optional note that can be included in the invitation by the sender
  """
  personalNote: String
  createdAt: Datetime
  updatedAt: Datetime
  accountToSenderAccountId: InvitationSenderAccountIdFkeyInput
  companyToCompanyId: InvitationCompanyIdFkeyInput
}

"""
Input for the nested mutation of `company` in the `InvitationInput` mutation.
"""
input InvitationCompanyIdFkeyInput {
  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectById: CompanyCompanyPkeyConnect

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByName: CompanyCompanyNameKeyConnect

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByReferenceNumber: CompanyCompanyReferenceNumberKeyConnect

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  connectByNodeId: CompanyNodeIdConnect

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteById: CompanyCompanyPkeyDelete

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByName: CompanyCompanyNameKeyDelete

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByReferenceNumber: CompanyCompanyReferenceNumberKeyDelete

  """
  The primary key(s) for `company` for the far side of the relationship.
  """
  deleteByNodeId: CompanyNodeIdDelete

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateById: CompanyOnInvitationForInvitationCompanyIdFkeyUsingCompanyPkeyUpdate

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByName: CompanyOnInvitationForInvitationCompanyIdFkeyUsingCompanyNameKeyUpdate

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByReferenceNumber: CompanyOnInvitationForInvitationCompanyIdFkeyUsingCompanyReferenceNumberKeyUpdate

  """
  The primary key(s) and patch data for `company` for the far side of the relationship.
  """
  updateByNodeId: InvitationOnInvitationForInvitationCompanyIdFkeyNodeIdUpdate
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnInvitationForInvitationCompanyIdFkeyUsingCompanyPkeyUpdate {
  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnInvitationForInvitationCompanyIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `company` being updated.
"""
input updateCompanyOnInvitationForInvitationCompanyIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int

  """
  fk
  """
  registeredAddressId: Int

  """
  fk
  """
  tradingAddressId: Int

  """
  the name of the owner of the Company
  """
  ownerFullname: String

  """
  the email address to contact the owner
  """
  ownerEmail: String

  """
  the phone number to contact the owner
  """
  ownerPhone: String

  """
  ek
  """
  businessType: BusinessType

  """
  ek
  """
  tier: Tier

  """
  ek
  """
  status: CompanyStatus

  """
  the email address of the person who filled out the company registration form
  """
  registeredBy: String

  """
  the date that the Company registration form was submitted
  """
  registeredDate: Datetime

  """
  The registered name of the Company
  """
  name: String

  """
  The Tax number in that Market, such as the VAT number
  """
  taxNumber: String

  """
  The Company public phone number
  """
  phone: String

  """
  A descirption of the Company intended for Find a Roofer
  """
  aboutUs: String

  """
  The email address that they can be contacted with by the public assuming they are listed
  """
  publicEmail: String

  """
  The Company website URL
  """
  website: String

  """
  The Company facebook website
  """
  facebook: String

  """
  Their Company LinkedIn page URL
  """
  linkedIn: String

  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: String

  """
  A reference to the logo image
  """
  logo: String

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String

  """
  Used for reference when importing data from the legacy system
  """
  tradingAddressMigrationId: String

  """
  Used for reference when importing data from the legacy system
  """
  registeredAddressMigrationId: String
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: CompanyMarketIdFkeyInput
  addressToRegisteredAddressId: CompanyRegisteredAddressIdFkeyInput
  addressToTradingAddressId: CompanyTradingAddressIdFkeyInput
  companyDocumentsUsingId: CompanyDocumentCompanyIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberCompanyIdFkeyInverseInput
  companyOperationsUsingId: CompanyOperationCompanyFkeyInverseInput
  invitationsUsingId: InvitationCompanyIdFkeyInverseInput
  projectsUsingId: ProjectCompanyIdFkeyInverseInput
  logoUpload: Upload
  shouldRemoveLogo: Boolean
}

"""
Input for the nested mutation of `project` in the `CompanyInput` mutation.
"""
input ProjectCompanyIdFkeyInverseInput {
  """
  Flag indicating whether all other `project` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  connectById: [ProjectProjectPkeyConnect!]

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  connectByNodeId: [ProjectNodeIdConnect!]

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  deleteById: [ProjectProjectPkeyDelete!]

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  deleteByNodeId: [ProjectNodeIdDelete!]

  """
  The primary key(s) and patch data for `project` for the far side of the relationship.
  """
  updateById: [ProjectOnProjectForProjectCompanyIdFkeyUsingProjectPkeyUpdate!]

  """
  The primary key(s) and patch data for `project` for the far side of the relationship.
  """
  updateByNodeId: [CompanyOnProjectForProjectCompanyIdFkeyNodeIdUpdate!]

  """
  A `ProjectInput` object that will be created and connected to this object.
  """
  create: [ProjectCompanyIdFkeyProjectCreateInput!]
}

"""
The fields on `project` to look up the row to update.
"""
input ProjectOnProjectForProjectCompanyIdFkeyUsingProjectPkeyUpdate {
  """
  An object where the defined keys will be set on the `project` being updated.
  """
  patch: updateProjectOnProjectForProjectCompanyIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `project` being updated.
"""
input updateProjectOnProjectForProjectCompanyIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  siteAddressId: Int

  """
  fk
  """
  buildingOwnerAddressId: Int

  """
  ek
  """
  technology: Technology

  """
  Short name for the Project
  """
  name: String

  """
  Short description of what the Project is about.  Sometimes useful to clarify some points to BMI
  """
  description: String

  """
  If this is true then the Project should be hidden from End Users
  """
  hidden: Boolean

  """
  The number of square meters of roof that this project covers
  """
  roofArea: Int

  """
  Email address of the person who owns the building that the roof is going on.  Not mandatory for a Project, but mandatory when the Company applies for a Guarantee related to the project.
  """
  buildingOwnerMail: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerFirstname: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerLastname: String

  """
  Name of the Building Owner company if there is such a thing.  Not the same as an InTouch Company.
  """
  buildingOwnerCompany: String

  """
  The date that the Project officially starts or started
  """
  startDate: Datetime

  """
  The date that the Project officially expects to end or ended
  """
  endDate: Datetime
  createdAt: Datetime
  updatedAt: Datetime
  companyToCompanyId: ProjectCompanyIdFkeyInput
  addressToSiteAddressId: ProjectSiteAddressIdFkeyInput
  addressToBuildingOwnerAddressId: ProjectBuildingOwnerAddressIdFkeyInput
  evidenceItemsUsingId: EvidenceItemProjectIdFkeyInverseInput
  guaranteesUsingId: GuaranteeProjectIdFkeyInverseInput
  notesUsingId: NoteProjectIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberProjectIdFkeyInverseInput
}

"""
Input for the nested mutation of `note` in the `ProjectInput` mutation.
"""
input NoteProjectIdFkeyInverseInput {
  """
  Flag indicating whether all other `note` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `note` for the far side of the relationship.
  """
  connectById: [NoteNotePkeyConnect!]

  """
  The primary key(s) for `note` for the far side of the relationship.
  """
  connectByNodeId: [NoteNodeIdConnect!]

  """
  The primary key(s) for `note` for the far side of the relationship.
  """
  deleteById: [NoteNotePkeyDelete!]

  """
  The primary key(s) for `note` for the far side of the relationship.
  """
  deleteByNodeId: [NoteNodeIdDelete!]

  """
  The primary key(s) and patch data for `note` for the far side of the relationship.
  """
  updateById: [NoteOnNoteForNoteProjectIdFkeyUsingNotePkeyUpdate!]

  """
  The primary key(s) and patch data for `note` for the far side of the relationship.
  """
  updateByNodeId: [ProjectOnNoteForNoteProjectIdFkeyNodeIdUpdate!]

  """
  A `NoteInput` object that will be created and connected to this object.
  """
  create: [NoteProjectIdFkeyNoteCreateInput!]
}

"""
The fields on `note` to look up the row to connect.
"""
input NoteNotePkeyConnect {
  """
  Primary key
  """
  id: Int!
}

"""
The globally unique `ID` look up for the row to connect.
"""
input NoteNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `note` to be connected.
  """
  nodeId: ID!
}

"""
The fields on `note` to look up the row to delete.
"""
input NoteNotePkeyDelete {
  """
  Primary key
  """
  id: Int!
}

"""
The globally unique `ID` look up for the row to delete.
"""
input NoteNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `note` to be deleted.
  """
  nodeId: ID!
}

"""
The fields on `note` to look up the row to update.
"""
input NoteOnNoteForNoteProjectIdFkeyUsingNotePkeyUpdate {
  """
  An object where the defined keys will be set on the `note` being updated.
  """
  patch: updateNoteOnNoteForNoteProjectIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `note` being updated.
"""
input updateNoteOnNoteForNoteProjectIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  authorId: Int

  """
  The body of the Note
  """
  body: String
  createdAt: Datetime
  updatedAt: Datetime
  accountToAuthorId: NoteAuthorIdFkeyInput
  projectToProjectId: NoteProjectIdFkeyInput
}

"""
Input for the nested mutation of `account` in the `NoteInput` mutation.
"""
input NoteAuthorIdFkeyInput {
  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectById: AccountAccountPkeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByEmail: AccountAccountEmailKeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByDoceboUserId: AccountAccountDoceboUserIdKeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByNodeId: AccountNodeIdConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteById: AccountAccountPkeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByEmail: AccountAccountEmailKeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByDoceboUserId: AccountAccountDoceboUserIdKeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByNodeId: AccountNodeIdDelete

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateById: AccountOnNoteForNoteAuthorIdFkeyUsingAccountPkeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByEmail: AccountOnNoteForNoteAuthorIdFkeyUsingAccountEmailKeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByDoceboUserId: AccountOnNoteForNoteAuthorIdFkeyUsingAccountDoceboUserIdKeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByNodeId: NoteOnNoteForNoteAuthorIdFkeyNodeIdUpdate
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnNoteForNoteAuthorIdFkeyUsingAccountPkeyUpdate {
  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnNoteForNoteAuthorIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `account` being updated.
"""
input updateAccountOnNoteForNoteAuthorIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  ek
  """
  status: AccountStatus

  """
  fk
  """
  marketId: Int

  """
  ek
  """
  role: Role

  """
  The email address associated with the account
  """
  email: String

  """
  A phone number that can optionally be provided, and is useful for Company Admin people to provide
  """
  phone: String

  """
  First name
  """
  firstName: String

  """
  Last name
  """
  lastName: String

  """
  When the account was created
  """
  created: Datetime

  """
  User account in Docebo
  """
  doceboUserId: Int

  """
  Username in Docebo.  Needed to generate the SSO link
  """
  doceboUsername: String

  """
  File reference. A profile picture of the user
  """
  photo: String

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: AccountMarketIdFkeyInput
  certificationsUsingDoceboUserId: CertificationDoceboUserIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberAccountIdFkeyInverseInput
  guaranteesToRequestorAccountIdUsingId: GuaranteeRequestorAccountIdFkeyInverseInput
  guaranteesToReviewerAccountIdUsingId: GuaranteeReviewerAccountIdFkeyInverseInput
  invitationsUsingId: InvitationSenderAccountIdFkeyInverseInput
  notesUsingId: NoteAuthorIdFkeyInverseInput
  notificationsUsingId: NotificationAccountIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberAccountIdFkeyInverseInput
  photoUpload: Upload
  shouldRemovePhoto: Boolean
}

"""
Input for the nested mutation of `note` in the `AccountInput` mutation.
"""
input NoteAuthorIdFkeyInverseInput {
  """
  Flag indicating whether all other `note` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `note` for the far side of the relationship.
  """
  connectById: [NoteNotePkeyConnect!]

  """
  The primary key(s) for `note` for the far side of the relationship.
  """
  connectByNodeId: [NoteNodeIdConnect!]

  """
  The primary key(s) for `note` for the far side of the relationship.
  """
  deleteById: [NoteNotePkeyDelete!]

  """
  The primary key(s) for `note` for the far side of the relationship.
  """
  deleteByNodeId: [NoteNodeIdDelete!]

  """
  The primary key(s) and patch data for `note` for the far side of the relationship.
  """
  updateById: [NoteOnNoteForNoteAuthorIdFkeyUsingNotePkeyUpdate!]

  """
  The primary key(s) and patch data for `note` for the far side of the relationship.
  """
  updateByNodeId: [AccountOnNoteForNoteAuthorIdFkeyNodeIdUpdate!]

  """
  A `NoteInput` object that will be created and connected to this object.
  """
  create: [NoteAuthorIdFkeyNoteCreateInput!]
}

"""
The fields on `note` to look up the row to update.
"""
input NoteOnNoteForNoteAuthorIdFkeyUsingNotePkeyUpdate {
  """
  An object where the defined keys will be set on the `note` being updated.
  """
  patch: updateNoteOnNoteForNoteAuthorIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `note` being updated.
"""
input updateNoteOnNoteForNoteAuthorIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  projectId: Int

  """
  The body of the Note
  """
  body: String
  createdAt: Datetime
  updatedAt: Datetime
  accountToAuthorId: NoteAuthorIdFkeyInput
  projectToProjectId: NoteProjectIdFkeyInput
}

"""
Input for the nested mutation of `project` in the `NoteInput` mutation.
"""
input NoteProjectIdFkeyInput {
  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  connectById: ProjectProjectPkeyConnect

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  connectByNodeId: ProjectNodeIdConnect

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  deleteById: ProjectProjectPkeyDelete

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  deleteByNodeId: ProjectNodeIdDelete

  """
  The primary key(s) and patch data for `project` for the far side of the relationship.
  """
  updateById: ProjectOnNoteForNoteProjectIdFkeyUsingProjectPkeyUpdate

  """
  The primary key(s) and patch data for `project` for the far side of the relationship.
  """
  updateByNodeId: NoteOnNoteForNoteProjectIdFkeyNodeIdUpdate

  """
  A `ProjectInput` object that will be created and connected to this object.
  """
  create: NoteProjectIdFkeyProjectCreateInput
}

"""
The fields on `project` to look up the row to update.
"""
input ProjectOnNoteForNoteProjectIdFkeyUsingProjectPkeyUpdate {
  """
  An object where the defined keys will be set on the `project` being updated.
  """
  patch: updateProjectOnNoteForNoteProjectIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `project` being updated.
"""
input updateProjectOnNoteForNoteProjectIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  companyId: Int

  """
  fk
  """
  siteAddressId: Int

  """
  fk
  """
  buildingOwnerAddressId: Int

  """
  ek
  """
  technology: Technology

  """
  Short name for the Project
  """
  name: String

  """
  Short description of what the Project is about.  Sometimes useful to clarify some points to BMI
  """
  description: String

  """
  If this is true then the Project should be hidden from End Users
  """
  hidden: Boolean

  """
  The number of square meters of roof that this project covers
  """
  roofArea: Int

  """
  Email address of the person who owns the building that the roof is going on.  Not mandatory for a Project, but mandatory when the Company applies for a Guarantee related to the project.
  """
  buildingOwnerMail: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerFirstname: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerLastname: String

  """
  Name of the Building Owner company if there is such a thing.  Not the same as an InTouch Company.
  """
  buildingOwnerCompany: String

  """
  The date that the Project officially starts or started
  """
  startDate: Datetime

  """
  The date that the Project officially expects to end or ended
  """
  endDate: Datetime
  createdAt: Datetime
  updatedAt: Datetime
  companyToCompanyId: ProjectCompanyIdFkeyInput
  addressToSiteAddressId: ProjectSiteAddressIdFkeyInput
  addressToBuildingOwnerAddressId: ProjectBuildingOwnerAddressIdFkeyInput
  evidenceItemsUsingId: EvidenceItemProjectIdFkeyInverseInput
  guaranteesUsingId: GuaranteeProjectIdFkeyInverseInput
  notesUsingId: NoteProjectIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberProjectIdFkeyInverseInput
}

"""
Input for the nested mutation of `projectMember` in the `ProjectInput` mutation.
"""
input ProjectMemberProjectIdFkeyInverseInput {
  """
  Flag indicating whether all other `projectMember` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `projectMember` for the far side of the relationship.
  """
  connectById: [ProjectMemberProjectMemberPkeyConnect!]

  """
  The primary key(s) for `projectMember` for the far side of the relationship.
  """
  connectByNodeId: [ProjectMemberNodeIdConnect!]

  """
  The primary key(s) for `projectMember` for the far side of the relationship.
  """
  deleteById: [ProjectMemberProjectMemberPkeyDelete!]

  """
  The primary key(s) for `projectMember` for the far side of the relationship.
  """
  deleteByNodeId: [ProjectMemberNodeIdDelete!]

  """
  The primary key(s) and patch data for `projectMember` for the far side of the relationship.
  """
  updateById: [ProjectMemberOnProjectMemberForProjectMemberProjectIdFkeyUsingProjectMemberPkeyUpdate!]

  """
  The primary key(s) and patch data for `projectMember` for the far side of the relationship.
  """
  updateByNodeId: [ProjectOnProjectMemberForProjectMemberProjectIdFkeyNodeIdUpdate!]

  """
  A `ProjectMemberInput` object that will be created and connected to this object.
  """
  create: [ProjectMemberProjectIdFkeyProjectMemberCreateInput!]
}

"""
The fields on `projectMember` to look up the row to connect.
"""
input ProjectMemberProjectMemberPkeyConnect {
  """
  Primary key
  """
  id: Int!
}

"""
The globally unique `ID` look up for the row to connect.
"""
input ProjectMemberNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `projectMember` to be connected.
  """
  nodeId: ID!
}

"""
The fields on `projectMember` to look up the row to delete.
"""
input ProjectMemberProjectMemberPkeyDelete {
  """
  Primary key
  """
  id: Int!
}

"""
The globally unique `ID` look up for the row to delete.
"""
input ProjectMemberNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `projectMember` to be deleted.
  """
  nodeId: ID!
}

"""
The fields on `projectMember` to look up the row to update.
"""
input ProjectMemberOnProjectMemberForProjectMemberProjectIdFkeyUsingProjectMemberPkeyUpdate {
  """
  An object where the defined keys will be set on the `projectMember` being updated.
  """
  patch: updateProjectMemberOnProjectMemberForProjectMemberProjectIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `projectMember` being updated.
"""
input updateProjectMemberOnProjectMemberForProjectMemberProjectIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  accountId: Int

  """
  The responsible installer
  """
  isResponsibleInstaller: Boolean
  createdAt: Datetime
  updatedAt: Datetime
  projectToProjectId: ProjectMemberProjectIdFkeyInput
  accountToAccountId: ProjectMemberAccountIdFkeyInput
}

"""
Input for the nested mutation of `project` in the `ProjectMemberInput` mutation.
"""
input ProjectMemberProjectIdFkeyInput {
  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  connectById: ProjectProjectPkeyConnect

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  connectByNodeId: ProjectNodeIdConnect

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  deleteById: ProjectProjectPkeyDelete

  """
  The primary key(s) for `project` for the far side of the relationship.
  """
  deleteByNodeId: ProjectNodeIdDelete

  """
  The primary key(s) and patch data for `project` for the far side of the relationship.
  """
  updateById: ProjectOnProjectMemberForProjectMemberProjectIdFkeyUsingProjectPkeyUpdate

  """
  The primary key(s) and patch data for `project` for the far side of the relationship.
  """
  updateByNodeId: ProjectMemberOnProjectMemberForProjectMemberProjectIdFkeyNodeIdUpdate

  """
  A `ProjectInput` object that will be created and connected to this object.
  """
  create: ProjectMemberProjectIdFkeyProjectCreateInput
}

"""
The fields on `project` to look up the row to update.
"""
input ProjectOnProjectMemberForProjectMemberProjectIdFkeyUsingProjectPkeyUpdate {
  """
  An object where the defined keys will be set on the `project` being updated.
  """
  patch: updateProjectOnProjectMemberForProjectMemberProjectIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `project` being updated.
"""
input updateProjectOnProjectMemberForProjectMemberProjectIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  companyId: Int

  """
  fk
  """
  siteAddressId: Int

  """
  fk
  """
  buildingOwnerAddressId: Int

  """
  ek
  """
  technology: Technology

  """
  Short name for the Project
  """
  name: String

  """
  Short description of what the Project is about.  Sometimes useful to clarify some points to BMI
  """
  description: String

  """
  If this is true then the Project should be hidden from End Users
  """
  hidden: Boolean

  """
  The number of square meters of roof that this project covers
  """
  roofArea: Int

  """
  Email address of the person who owns the building that the roof is going on.  Not mandatory for a Project, but mandatory when the Company applies for a Guarantee related to the project.
  """
  buildingOwnerMail: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerFirstname: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerLastname: String

  """
  Name of the Building Owner company if there is such a thing.  Not the same as an InTouch Company.
  """
  buildingOwnerCompany: String

  """
  The date that the Project officially starts or started
  """
  startDate: Datetime

  """
  The date that the Project officially expects to end or ended
  """
  endDate: Datetime
  createdAt: Datetime
  updatedAt: Datetime
  companyToCompanyId: ProjectCompanyIdFkeyInput
  addressToSiteAddressId: ProjectSiteAddressIdFkeyInput
  addressToBuildingOwnerAddressId: ProjectBuildingOwnerAddressIdFkeyInput
  evidenceItemsUsingId: EvidenceItemProjectIdFkeyInverseInput
  guaranteesUsingId: GuaranteeProjectIdFkeyInverseInput
  notesUsingId: NoteProjectIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberProjectIdFkeyInverseInput
}

"""
The globally unique `ID` look up for the row to update.
"""
input ProjectMemberOnProjectMemberForProjectMemberProjectIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `project` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `project` being updated.
  """
  patch: ProjectPatch!
}

"""
Represents an update to a `Project`. Fields that are set will be updated.
"""
input ProjectPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  companyId: Int

  """
  fk
  """
  siteAddressId: Int

  """
  fk
  """
  buildingOwnerAddressId: Int

  """
  ek
  """
  technology: Technology

  """
  Short name for the Project
  """
  name: String

  """
  Short description of what the Project is about.  Sometimes useful to clarify some points to BMI
  """
  description: String

  """
  If this is true then the Project should be hidden from End Users
  """
  hidden: Boolean

  """
  The number of square meters of roof that this project covers
  """
  roofArea: Int

  """
  Email address of the person who owns the building that the roof is going on.  Not mandatory for a Project, but mandatory when the Company applies for a Guarantee related to the project.
  """
  buildingOwnerMail: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerFirstname: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerLastname: String

  """
  Name of the Building Owner company if there is such a thing.  Not the same as an InTouch Company.
  """
  buildingOwnerCompany: String

  """
  The date that the Project officially starts or started
  """
  startDate: Datetime

  """
  The date that the Project officially expects to end or ended
  """
  endDate: Datetime
  createdAt: Datetime
  updatedAt: Datetime
  companyToCompanyId: ProjectCompanyIdFkeyInput
  addressToSiteAddressId: ProjectSiteAddressIdFkeyInput
  addressToBuildingOwnerAddressId: ProjectBuildingOwnerAddressIdFkeyInput
  evidenceItemsUsingId: EvidenceItemProjectIdFkeyInverseInput
  guaranteesUsingId: GuaranteeProjectIdFkeyInverseInput
  notesUsingId: NoteProjectIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberProjectIdFkeyInverseInput
}

"""
The `project` to be created by this mutation.
"""
input ProjectMemberProjectIdFkeyProjectCreateInput {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  companyId: Int

  """
  fk
  """
  siteAddressId: Int

  """
  fk
  """
  buildingOwnerAddressId: Int

  """
  ek
  """
  technology: Technology

  """
  Short name for the Project
  """
  name: String!

  """
  Short description of what the Project is about.  Sometimes useful to clarify some points to BMI
  """
  description: String

  """
  If this is true then the Project should be hidden from End Users
  """
  hidden: Boolean

  """
  The number of square meters of roof that this project covers
  """
  roofArea: Int!

  """
  Email address of the person who owns the building that the roof is going on.  Not mandatory for a Project, but mandatory when the Company applies for a Guarantee related to the project.
  """
  buildingOwnerMail: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerFirstname: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerLastname: String

  """
  Name of the Building Owner company if there is such a thing.  Not the same as an InTouch Company.
  """
  buildingOwnerCompany: String

  """
  The date that the Project officially starts or started
  """
  startDate: Datetime!

  """
  The date that the Project officially expects to end or ended
  """
  endDate: Datetime!
  createdAt: Datetime
  updatedAt: Datetime
  companyToCompanyId: ProjectCompanyIdFkeyInput
  addressToSiteAddressId: ProjectSiteAddressIdFkeyInput
  addressToBuildingOwnerAddressId: ProjectBuildingOwnerAddressIdFkeyInput
  evidenceItemsUsingId: EvidenceItemProjectIdFkeyInverseInput
  guaranteesUsingId: GuaranteeProjectIdFkeyInverseInput
  notesUsingId: NoteProjectIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberProjectIdFkeyInverseInput
}

"""
Input for the nested mutation of `account` in the `ProjectMemberInput` mutation.
"""
input ProjectMemberAccountIdFkeyInput {
  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectById: AccountAccountPkeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByEmail: AccountAccountEmailKeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByDoceboUserId: AccountAccountDoceboUserIdKeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByNodeId: AccountNodeIdConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteById: AccountAccountPkeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByEmail: AccountAccountEmailKeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByDoceboUserId: AccountAccountDoceboUserIdKeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByNodeId: AccountNodeIdDelete

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateById: AccountOnProjectMemberForProjectMemberAccountIdFkeyUsingAccountPkeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByEmail: AccountOnProjectMemberForProjectMemberAccountIdFkeyUsingAccountEmailKeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByDoceboUserId: AccountOnProjectMemberForProjectMemberAccountIdFkeyUsingAccountDoceboUserIdKeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByNodeId: ProjectMemberOnProjectMemberForProjectMemberAccountIdFkeyNodeIdUpdate
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnProjectMemberForProjectMemberAccountIdFkeyUsingAccountPkeyUpdate {
  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnProjectMemberForProjectMemberAccountIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `account` being updated.
"""
input updateAccountOnProjectMemberForProjectMemberAccountIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  ek
  """
  status: AccountStatus

  """
  fk
  """
  marketId: Int

  """
  ek
  """
  role: Role

  """
  The email address associated with the account
  """
  email: String

  """
  A phone number that can optionally be provided, and is useful for Company Admin people to provide
  """
  phone: String

  """
  First name
  """
  firstName: String

  """
  Last name
  """
  lastName: String

  """
  When the account was created
  """
  created: Datetime

  """
  User account in Docebo
  """
  doceboUserId: Int

  """
  Username in Docebo.  Needed to generate the SSO link
  """
  doceboUsername: String

  """
  File reference. A profile picture of the user
  """
  photo: String

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: AccountMarketIdFkeyInput
  certificationsUsingDoceboUserId: CertificationDoceboUserIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberAccountIdFkeyInverseInput
  guaranteesToRequestorAccountIdUsingId: GuaranteeRequestorAccountIdFkeyInverseInput
  guaranteesToReviewerAccountIdUsingId: GuaranteeReviewerAccountIdFkeyInverseInput
  invitationsUsingId: InvitationSenderAccountIdFkeyInverseInput
  notesUsingId: NoteAuthorIdFkeyInverseInput
  notificationsUsingId: NotificationAccountIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberAccountIdFkeyInverseInput
  photoUpload: Upload
  shouldRemovePhoto: Boolean
}

"""
Input for the nested mutation of `notification` in the `AccountInput` mutation.
"""
input NotificationAccountIdFkeyInverseInput {
  """
  Flag indicating whether all other `notification` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `notification` for the far side of the relationship.
  """
  connectById: [NotificationNotificationPkeyConnect!]

  """
  The primary key(s) for `notification` for the far side of the relationship.
  """
  connectByNodeId: [NotificationNodeIdConnect!]

  """
  The primary key(s) for `notification` for the far side of the relationship.
  """
  deleteById: [NotificationNotificationPkeyDelete!]

  """
  The primary key(s) for `notification` for the far side of the relationship.
  """
  deleteByNodeId: [NotificationNodeIdDelete!]

  """
  The primary key(s) and patch data for `notification` for the far side of the relationship.
  """
  updateById: [NotificationOnNotificationForNotificationAccountIdFkeyUsingNotificationPkeyUpdate!]

  """
  The primary key(s) and patch data for `notification` for the far side of the relationship.
  """
  updateByNodeId: [AccountOnNotificationForNotificationAccountIdFkeyNodeIdUpdate!]

  """
  A `NotificationInput` object that will be created and connected to this object.
  """
  create: [NotificationAccountIdFkeyNotificationCreateInput!]
}

"""
The fields on `notification` to look up the row to connect.
"""
input NotificationNotificationPkeyConnect {
  """
  Primary key
  """
  id: Int!
}

"""
The globally unique `ID` look up for the row to connect.
"""
input NotificationNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `notification` to be connected.
  """
  nodeId: ID!
}

"""
The fields on `notification` to look up the row to delete.
"""
input NotificationNotificationPkeyDelete {
  """
  Primary key
  """
  id: Int!
}

"""
The globally unique `ID` look up for the row to delete.
"""
input NotificationNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `notification` to be deleted.
  """
  nodeId: ID!
}

"""
The fields on `notification` to look up the row to update.
"""
input NotificationOnNotificationForNotificationAccountIdFkeyUsingNotificationPkeyUpdate {
  """
  An object where the defined keys will be set on the `notification` being updated.
  """
  patch: updateNotificationOnNotificationForNotificationAccountIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `notification` being updated.
"""
input updateNotificationOnNotificationForNotificationAccountIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  The datetime stamp for when the message was sent
  """
  sendDate: Datetime

  """
  Whether the message has been read
  """
  read: Boolean

  """
  The body of the message
  """
  body: String
  createdAt: Datetime
  updatedAt: Datetime
  accountToAccountId: NotificationAccountIdFkeyInput
}

"""
Input for the nested mutation of `account` in the `NotificationInput` mutation.
"""
input NotificationAccountIdFkeyInput {
  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectById: AccountAccountPkeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByEmail: AccountAccountEmailKeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByDoceboUserId: AccountAccountDoceboUserIdKeyConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  connectByNodeId: AccountNodeIdConnect

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteById: AccountAccountPkeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByEmail: AccountAccountEmailKeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByDoceboUserId: AccountAccountDoceboUserIdKeyDelete

  """
  The primary key(s) for `account` for the far side of the relationship.
  """
  deleteByNodeId: AccountNodeIdDelete

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateById: AccountOnNotificationForNotificationAccountIdFkeyUsingAccountPkeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByEmail: AccountOnNotificationForNotificationAccountIdFkeyUsingAccountEmailKeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByDoceboUserId: AccountOnNotificationForNotificationAccountIdFkeyUsingAccountDoceboUserIdKeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByNodeId: NotificationOnNotificationForNotificationAccountIdFkeyNodeIdUpdate
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnNotificationForNotificationAccountIdFkeyUsingAccountPkeyUpdate {
  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnNotificationForNotificationAccountIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `account` being updated.
"""
input updateAccountOnNotificationForNotificationAccountIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  ek
  """
  status: AccountStatus

  """
  fk
  """
  marketId: Int

  """
  ek
  """
  role: Role

  """
  The email address associated with the account
  """
  email: String

  """
  A phone number that can optionally be provided, and is useful for Company Admin people to provide
  """
  phone: String

  """
  First name
  """
  firstName: String

  """
  Last name
  """
  lastName: String

  """
  When the account was created
  """
  created: Datetime

  """
  User account in Docebo
  """
  doceboUserId: Int

  """
  Username in Docebo.  Needed to generate the SSO link
  """
  doceboUsername: String

  """
  File reference. A profile picture of the user
  """
  photo: String

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: AccountMarketIdFkeyInput
  certificationsUsingDoceboUserId: CertificationDoceboUserIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberAccountIdFkeyInverseInput
  guaranteesToRequestorAccountIdUsingId: GuaranteeRequestorAccountIdFkeyInverseInput
  guaranteesToReviewerAccountIdUsingId: GuaranteeReviewerAccountIdFkeyInverseInput
  invitationsUsingId: InvitationSenderAccountIdFkeyInverseInput
  notesUsingId: NoteAuthorIdFkeyInverseInput
  notificationsUsingId: NotificationAccountIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberAccountIdFkeyInverseInput
  photoUpload: Upload
  shouldRemovePhoto: Boolean
}

"""
Input for the nested mutation of `projectMember` in the `AccountInput` mutation.
"""
input ProjectMemberAccountIdFkeyInverseInput {
  """
  Flag indicating whether all other `projectMember` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `projectMember` for the far side of the relationship.
  """
  connectById: [ProjectMemberProjectMemberPkeyConnect!]

  """
  The primary key(s) for `projectMember` for the far side of the relationship.
  """
  connectByNodeId: [ProjectMemberNodeIdConnect!]

  """
  The primary key(s) for `projectMember` for the far side of the relationship.
  """
  deleteById: [ProjectMemberProjectMemberPkeyDelete!]

  """
  The primary key(s) for `projectMember` for the far side of the relationship.
  """
  deleteByNodeId: [ProjectMemberNodeIdDelete!]

  """
  The primary key(s) and patch data for `projectMember` for the far side of the relationship.
  """
  updateById: [ProjectMemberOnProjectMemberForProjectMemberAccountIdFkeyUsingProjectMemberPkeyUpdate!]

  """
  The primary key(s) and patch data for `projectMember` for the far side of the relationship.
  """
  updateByNodeId: [AccountOnProjectMemberForProjectMemberAccountIdFkeyNodeIdUpdate!]

  """
  A `ProjectMemberInput` object that will be created and connected to this object.
  """
  create: [ProjectMemberAccountIdFkeyProjectMemberCreateInput!]
}

"""
The fields on `projectMember` to look up the row to update.
"""
input ProjectMemberOnProjectMemberForProjectMemberAccountIdFkeyUsingProjectMemberPkeyUpdate {
  """
  An object where the defined keys will be set on the `projectMember` being updated.
  """
  patch: updateProjectMemberOnProjectMemberForProjectMemberAccountIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `projectMember` being updated.
"""
input updateProjectMemberOnProjectMemberForProjectMemberAccountIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  projectId: Int

  """
  The responsible installer
  """
  isResponsibleInstaller: Boolean
  createdAt: Datetime
  updatedAt: Datetime
  projectToProjectId: ProjectMemberProjectIdFkeyInput
  accountToAccountId: ProjectMemberAccountIdFkeyInput
}

"""
The globally unique `ID` look up for the row to update.
"""
input AccountOnProjectMemberForProjectMemberAccountIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `projectMember` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `projectMember` being updated.
  """
  patch: ProjectMemberPatch!
}

"""
Represents an update to a `ProjectMember`. Fields that are set will be updated.
"""
input ProjectMemberPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  projectId: Int

  """
  fk
  """
  accountId: Int

  """
  The responsible installer
  """
  isResponsibleInstaller: Boolean
  createdAt: Datetime
  updatedAt: Datetime
  projectToProjectId: ProjectMemberProjectIdFkeyInput
  accountToAccountId: ProjectMemberAccountIdFkeyInput
}

"""
The `projectMember` to be created by this mutation.
"""
input ProjectMemberAccountIdFkeyProjectMemberCreateInput {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  projectId: Int

  """
  The responsible installer
  """
  isResponsibleInstaller: Boolean
  createdAt: Datetime
  updatedAt: Datetime
  projectToProjectId: ProjectMemberProjectIdFkeyInput
  accountToAccountId: ProjectMemberAccountIdFkeyInput
}

"""
The `Upload` scalar type represents a file upload.
"""
scalar Upload

"""
The fields on `account` to look up the row to update.
"""
input AccountOnNotificationForNotificationAccountIdFkeyUsingAccountEmailKeyUpdate {
  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnNotificationForNotificationAccountIdFkeyPatch!

  """
  The email address associated with the account
  """
  email: String!
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnNotificationForNotificationAccountIdFkeyUsingAccountDoceboUserIdKeyUpdate {
  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnNotificationForNotificationAccountIdFkeyPatch!

  """
  User account in Docebo
  """
  doceboUserId: Int!
}

"""
The globally unique `ID` look up for the row to update.
"""
input NotificationOnNotificationForNotificationAccountIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `account` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: AccountPatch!
}

"""
Represents an update to a `Account`. Fields that are set will be updated.
"""
input AccountPatch {
  """
  Primary key
  """
  id: Int

  """
  ek
  """
  status: AccountStatus

  """
  fk
  """
  marketId: Int

  """
  ek
  """
  role: Role

  """
  The email address associated with the account
  """
  email: String

  """
  A phone number that can optionally be provided, and is useful for Company Admin people to provide
  """
  phone: String

  """
  First name
  """
  firstName: String

  """
  Last name
  """
  lastName: String

  """
  When the account was created
  """
  created: Datetime

  """
  User account in Docebo
  """
  doceboUserId: Int

  """
  Username in Docebo.  Needed to generate the SSO link
  """
  doceboUsername: String

  """
  File reference. A profile picture of the user
  """
  photo: String

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: AccountMarketIdFkeyInput
  certificationsUsingDoceboUserId: CertificationDoceboUserIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberAccountIdFkeyInverseInput
  guaranteesToRequestorAccountIdUsingId: GuaranteeRequestorAccountIdFkeyInverseInput
  guaranteesToReviewerAccountIdUsingId: GuaranteeReviewerAccountIdFkeyInverseInput
  invitationsUsingId: InvitationSenderAccountIdFkeyInverseInput
  notesUsingId: NoteAuthorIdFkeyInverseInput
  notificationsUsingId: NotificationAccountIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberAccountIdFkeyInverseInput
  photoUpload: Upload
  shouldRemovePhoto: Boolean
}

"""
The globally unique `ID` look up for the row to update.
"""
input AccountOnNotificationForNotificationAccountIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `notification` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `notification` being updated.
  """
  patch: NotificationPatch!
}

"""
Represents an update to a `Notification`. Fields that are set will be updated.
"""
input NotificationPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  accountId: Int

  """
  The datetime stamp for when the message was sent
  """
  sendDate: Datetime

  """
  Whether the message has been read
  """
  read: Boolean

  """
  The body of the message
  """
  body: String
  createdAt: Datetime
  updatedAt: Datetime
  accountToAccountId: NotificationAccountIdFkeyInput
}

"""
The `notification` to be created by this mutation.
"""
input NotificationAccountIdFkeyNotificationCreateInput {
  """
  Primary key
  """
  id: Int

  """
  The datetime stamp for when the message was sent
  """
  sendDate: Datetime!

  """
  Whether the message has been read
  """
  read: Boolean

  """
  The body of the message
  """
  body: String
  createdAt: Datetime
  updatedAt: Datetime
  accountToAccountId: NotificationAccountIdFkeyInput
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnProjectMemberForProjectMemberAccountIdFkeyUsingAccountEmailKeyUpdate {
  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnProjectMemberForProjectMemberAccountIdFkeyPatch!

  """
  The email address associated with the account
  """
  email: String!
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnProjectMemberForProjectMemberAccountIdFkeyUsingAccountDoceboUserIdKeyUpdate {
  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnProjectMemberForProjectMemberAccountIdFkeyPatch!

  """
  User account in Docebo
  """
  doceboUserId: Int!
}

"""
The globally unique `ID` look up for the row to update.
"""
input ProjectMemberOnProjectMemberForProjectMemberAccountIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `account` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: AccountPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input ProjectOnProjectMemberForProjectMemberProjectIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `projectMember` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `projectMember` being updated.
  """
  patch: ProjectMemberPatch!
}

"""
The `projectMember` to be created by this mutation.
"""
input ProjectMemberProjectIdFkeyProjectMemberCreateInput {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  accountId: Int

  """
  The responsible installer
  """
  isResponsibleInstaller: Boolean
  createdAt: Datetime
  updatedAt: Datetime
  projectToProjectId: ProjectMemberProjectIdFkeyInput
  accountToAccountId: ProjectMemberAccountIdFkeyInput
}

"""
The globally unique `ID` look up for the row to update.
"""
input NoteOnNoteForNoteProjectIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `project` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `project` being updated.
  """
  patch: ProjectPatch!
}

"""
The `project` to be created by this mutation.
"""
input NoteProjectIdFkeyProjectCreateInput {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  companyId: Int

  """
  fk
  """
  siteAddressId: Int

  """
  fk
  """
  buildingOwnerAddressId: Int

  """
  ek
  """
  technology: Technology

  """
  Short name for the Project
  """
  name: String!

  """
  Short description of what the Project is about.  Sometimes useful to clarify some points to BMI
  """
  description: String

  """
  If this is true then the Project should be hidden from End Users
  """
  hidden: Boolean

  """
  The number of square meters of roof that this project covers
  """
  roofArea: Int!

  """
  Email address of the person who owns the building that the roof is going on.  Not mandatory for a Project, but mandatory when the Company applies for a Guarantee related to the project.
  """
  buildingOwnerMail: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerFirstname: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerLastname: String

  """
  Name of the Building Owner company if there is such a thing.  Not the same as an InTouch Company.
  """
  buildingOwnerCompany: String

  """
  The date that the Project officially starts or started
  """
  startDate: Datetime!

  """
  The date that the Project officially expects to end or ended
  """
  endDate: Datetime!
  createdAt: Datetime
  updatedAt: Datetime
  companyToCompanyId: ProjectCompanyIdFkeyInput
  addressToSiteAddressId: ProjectSiteAddressIdFkeyInput
  addressToBuildingOwnerAddressId: ProjectBuildingOwnerAddressIdFkeyInput
  evidenceItemsUsingId: EvidenceItemProjectIdFkeyInverseInput
  guaranteesUsingId: GuaranteeProjectIdFkeyInverseInput
  notesUsingId: NoteProjectIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberProjectIdFkeyInverseInput
}

"""
The globally unique `ID` look up for the row to update.
"""
input AccountOnNoteForNoteAuthorIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `note` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `note` being updated.
  """
  patch: NotePatch!
}

"""
Represents an update to a `Note`. Fields that are set will be updated.
"""
input NotePatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  authorId: Int

  """
  fk
  """
  projectId: Int

  """
  The body of the Note
  """
  body: String
  createdAt: Datetime
  updatedAt: Datetime
  accountToAuthorId: NoteAuthorIdFkeyInput
  projectToProjectId: NoteProjectIdFkeyInput
}

"""
The `note` to be created by this mutation.
"""
input NoteAuthorIdFkeyNoteCreateInput {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  projectId: Int

  """
  The body of the Note
  """
  body: String
  createdAt: Datetime
  updatedAt: Datetime
  accountToAuthorId: NoteAuthorIdFkeyInput
  projectToProjectId: NoteProjectIdFkeyInput
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnNoteForNoteAuthorIdFkeyUsingAccountEmailKeyUpdate {
  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnNoteForNoteAuthorIdFkeyPatch!

  """
  The email address associated with the account
  """
  email: String!
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnNoteForNoteAuthorIdFkeyUsingAccountDoceboUserIdKeyUpdate {
  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnNoteForNoteAuthorIdFkeyPatch!

  """
  User account in Docebo
  """
  doceboUserId: Int!
}

"""
The globally unique `ID` look up for the row to update.
"""
input NoteOnNoteForNoteAuthorIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `account` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: AccountPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input ProjectOnNoteForNoteProjectIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `note` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `note` being updated.
  """
  patch: NotePatch!
}

"""
The `note` to be created by this mutation.
"""
input NoteProjectIdFkeyNoteCreateInput {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  authorId: Int

  """
  The body of the Note
  """
  body: String
  createdAt: Datetime
  updatedAt: Datetime
  accountToAuthorId: NoteAuthorIdFkeyInput
  projectToProjectId: NoteProjectIdFkeyInput
}

"""
The globally unique `ID` look up for the row to update.
"""
input CompanyOnProjectForProjectCompanyIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `project` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `project` being updated.
  """
  patch: ProjectPatch!
}

"""
The `project` to be created by this mutation.
"""
input ProjectCompanyIdFkeyProjectCreateInput {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  siteAddressId: Int

  """
  fk
  """
  buildingOwnerAddressId: Int

  """
  ek
  """
  technology: Technology

  """
  Short name for the Project
  """
  name: String!

  """
  Short description of what the Project is about.  Sometimes useful to clarify some points to BMI
  """
  description: String

  """
  If this is true then the Project should be hidden from End Users
  """
  hidden: Boolean

  """
  The number of square meters of roof that this project covers
  """
  roofArea: Int!

  """
  Email address of the person who owns the building that the roof is going on.  Not mandatory for a Project, but mandatory when the Company applies for a Guarantee related to the project.
  """
  buildingOwnerMail: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerFirstname: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerLastname: String

  """
  Name of the Building Owner company if there is such a thing.  Not the same as an InTouch Company.
  """
  buildingOwnerCompany: String

  """
  The date that the Project officially starts or started
  """
  startDate: Datetime!

  """
  The date that the Project officially expects to end or ended
  """
  endDate: Datetime!
  createdAt: Datetime
  updatedAt: Datetime
  companyToCompanyId: ProjectCompanyIdFkeyInput
  addressToSiteAddressId: ProjectSiteAddressIdFkeyInput
  addressToBuildingOwnerAddressId: ProjectBuildingOwnerAddressIdFkeyInput
  evidenceItemsUsingId: EvidenceItemProjectIdFkeyInverseInput
  guaranteesUsingId: GuaranteeProjectIdFkeyInverseInput
  notesUsingId: NoteProjectIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberProjectIdFkeyInverseInput
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnInvitationForInvitationCompanyIdFkeyUsingCompanyNameKeyUpdate {
  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnInvitationForInvitationCompanyIdFkeyPatch!

  """
  The registered name of the Company
  """
  name: String!
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnInvitationForInvitationCompanyIdFkeyUsingCompanyReferenceNumberKeyUpdate {
  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnInvitationForInvitationCompanyIdFkeyPatch!

  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: String!
}

"""
The globally unique `ID` look up for the row to update.
"""
input InvitationOnInvitationForInvitationCompanyIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `company` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: CompanyPatch!
}

"""
Represents an update to a `Company`. Fields that are set will be updated.
"""
input CompanyPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int

  """
  fk
  """
  registeredAddressId: Int

  """
  fk
  """
  tradingAddressId: Int

  """
  the name of the owner of the Company
  """
  ownerFullname: String

  """
  the email address to contact the owner
  """
  ownerEmail: String

  """
  the phone number to contact the owner
  """
  ownerPhone: String

  """
  ek
  """
  businessType: BusinessType

  """
  ek
  """
  tier: Tier

  """
  ek
  """
  status: CompanyStatus

  """
  the email address of the person who filled out the company registration form
  """
  registeredBy: String

  """
  the date that the Company registration form was submitted
  """
  registeredDate: Datetime

  """
  The registered name of the Company
  """
  name: String

  """
  The Tax number in that Market, such as the VAT number
  """
  taxNumber: String

  """
  The Company public phone number
  """
  phone: String

  """
  A descirption of the Company intended for Find a Roofer
  """
  aboutUs: String

  """
  The email address that they can be contacted with by the public assuming they are listed
  """
  publicEmail: String

  """
  The Company website URL
  """
  website: String

  """
  The Company facebook website
  """
  facebook: String

  """
  Their Company LinkedIn page URL
  """
  linkedIn: String

  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: String

  """
  A reference to the logo image
  """
  logo: String

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String

  """
  Used for reference when importing data from the legacy system
  """
  tradingAddressMigrationId: String

  """
  Used for reference when importing data from the legacy system
  """
  registeredAddressMigrationId: String
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: CompanyMarketIdFkeyInput
  addressToRegisteredAddressId: CompanyRegisteredAddressIdFkeyInput
  addressToTradingAddressId: CompanyTradingAddressIdFkeyInput
  companyDocumentsUsingId: CompanyDocumentCompanyIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberCompanyIdFkeyInverseInput
  companyOperationsUsingId: CompanyOperationCompanyFkeyInverseInput
  invitationsUsingId: InvitationCompanyIdFkeyInverseInput
  projectsUsingId: ProjectCompanyIdFkeyInverseInput
  logoUpload: Upload
  shouldRemoveLogo: Boolean
}

"""
The globally unique `ID` look up for the row to update.
"""
input AccountOnInvitationForInvitationSenderAccountIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `invitation` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `invitation` being updated.
  """
  patch: InvitationPatch!
}

"""
Represents an update to a `Invitation`. Fields that are set will be updated.
"""
input InvitationPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  senderAccountId: Int

  """
  fk
  """
  companyId: Int

  """
  ek
  """
  status: InvitationStatus

  """
  An email address
  """
  invitee: String

  """
  An optional note that can be included in the invitation by the sender
  """
  personalNote: String
  createdAt: Datetime
  updatedAt: Datetime
  accountToSenderAccountId: InvitationSenderAccountIdFkeyInput
  companyToCompanyId: InvitationCompanyIdFkeyInput
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnGuaranteeForGuaranteeReviewerAccountIdFkeyUsingAccountEmailKeyUpdate {
  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnGuaranteeForGuaranteeReviewerAccountIdFkeyPatch!

  """
  The email address associated with the account
  """
  email: String!
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnGuaranteeForGuaranteeReviewerAccountIdFkeyUsingAccountDoceboUserIdKeyUpdate {
  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnGuaranteeForGuaranteeReviewerAccountIdFkeyPatch!

  """
  User account in Docebo
  """
  doceboUserId: Int!
}

"""
The globally unique `ID` look up for the row to update.
"""
input GuaranteeOnGuaranteeForGuaranteeReviewerAccountIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `account` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: AccountPatch!
}

"""
Input for the nested mutation of `evidenceItem` in the `GuaranteeInput` mutation.
"""
input EvidenceItemGuaranteeIdFkeyInverseInput {
  """
  Flag indicating whether all other `evidenceItem` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `evidenceItem` for the far side of the relationship.
  """
  connectById: [EvidenceItemEvidenceItemPkeyConnect!]

  """
  The primary key(s) for `evidenceItem` for the far side of the relationship.
  """
  connectByNodeId: [EvidenceItemNodeIdConnect!]

  """
  The primary key(s) for `evidenceItem` for the far side of the relationship.
  """
  deleteById: [EvidenceItemEvidenceItemPkeyDelete!]

  """
  The primary key(s) for `evidenceItem` for the far side of the relationship.
  """
  deleteByNodeId: [EvidenceItemNodeIdDelete!]

  """
  The primary key(s) and patch data for `evidenceItem` for the far side of the relationship.
  """
  updateById: [EvidenceItemOnEvidenceItemForEvidenceItemGuaranteeIdFkeyUsingEvidenceItemPkeyUpdate!]

  """
  The primary key(s) and patch data for `evidenceItem` for the far side of the relationship.
  """
  updateByNodeId: [GuaranteeOnEvidenceItemForEvidenceItemGuaranteeIdFkeyNodeIdUpdate!]

  """
  A `EvidenceItemInput` object that will be created and connected to this object.
  """
  create: [EvidenceItemGuaranteeIdFkeyEvidenceItemCreateInput!]
}

"""
The fields on `evidenceItem` to look up the row to update.
"""
input EvidenceItemOnEvidenceItemForEvidenceItemGuaranteeIdFkeyUsingEvidenceItemPkeyUpdate {
  """
  An object where the defined keys will be set on the `evidenceItem` being updated.
  """
  patch: updateEvidenceItemOnEvidenceItemForEvidenceItemGuaranteeIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `evidenceItem` being updated.
"""
input updateEvidenceItemOnEvidenceItemForEvidenceItemGuaranteeIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  a reference to the evidenceCategory sys id in Contentful
  """
  customEvidenceCategoryId: String

  """
  fk
  """
  projectId: Int

  """
  ek
  """
  evidenceCategoryType: EvidenceCategoryType

  """
  Short name for the item of evidence
  """
  name: String

  """
  File reference or the file itself. Photo of the evidence
  """
  attachment: String
  createdAt: Datetime
  updatedAt: Datetime
  projectToProjectId: EvidenceItemProjectIdFkeyInput
  guaranteeToGuaranteeId: EvidenceItemGuaranteeIdFkeyInput
}

"""
Input for the nested mutation of `guarantee` in the `EvidenceItemInput` mutation.
"""
input EvidenceItemGuaranteeIdFkeyInput {
  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  connectById: GuaranteeGuaranteePkeyConnect

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  connectByBmiReferenceId: GuaranteeGuaranteeBmiReferenceIdKeyConnect

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  connectByNodeId: GuaranteeNodeIdConnect

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  deleteById: GuaranteeGuaranteePkeyDelete

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  deleteByBmiReferenceId: GuaranteeGuaranteeBmiReferenceIdKeyDelete

  """
  The primary key(s) for `guarantee` for the far side of the relationship.
  """
  deleteByNodeId: GuaranteeNodeIdDelete

  """
  The primary key(s) and patch data for `guarantee` for the far side of the relationship.
  """
  updateById: GuaranteeOnEvidenceItemForEvidenceItemGuaranteeIdFkeyUsingGuaranteePkeyUpdate

  """
  The primary key(s) and patch data for `guarantee` for the far side of the relationship.
  """
  updateByBmiReferenceId: GuaranteeOnEvidenceItemForEvidenceItemGuaranteeIdFkeyUsingGuaranteeBmiReferenceIdKeyUpdate

  """
  The primary key(s) and patch data for `guarantee` for the far side of the relationship.
  """
  updateByNodeId: EvidenceItemOnEvidenceItemForEvidenceItemGuaranteeIdFkeyNodeIdUpdate

  """
  A `GuaranteeInput` object that will be created and connected to this object.
  """
  create: EvidenceItemGuaranteeIdFkeyGuaranteeCreateInput
}

"""
The fields on `guarantee` to look up the row to update.
"""
input GuaranteeOnEvidenceItemForEvidenceItemGuaranteeIdFkeyUsingGuaranteePkeyUpdate {
  """
  An object where the defined keys will be set on the `guarantee` being updated.
  """
  patch: updateGuaranteeOnEvidenceItemForEvidenceItemGuaranteeIdFkeyPatch!

  """
  Primary key - starts at 6100
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `guarantee` being updated.
"""
input updateGuaranteeOnEvidenceItemForEvidenceItemGuaranteeIdFkeyPatch {
  """
  Primary key - starts at 6100
  """
  id: Int

  """
  The pdf file that is emailed out, or a reference to it, or reference to the service that will generate it on demand
  """
  fileStorageId: String

  """
  fk
  """
  requestorAccountId: Int

  """
  fk
  """
  projectId: Int

  """
  a reference to the guaranteeType sys id in Contentful
  """
  guaranteeTypeId: String

  """
  fk
  """
  systemBmiRef: String

  """
  fk
  """
  productBmiRef: String

  """
  fk
  """
  reviewerAccountId: Int

  """
  a reference to the guaranteeType sys id in Contentful
  """
  guaranteeTemplateId: String

  """
  ek
  """
  status: RequestStatus

  """
  The date that the Guarantee is approved either automatically or manually
  """
  startDate: Datetime

  """
  When the guarantee will expire.  This should be calculated when the request_status becomes APPROVED. dependent on the StartDate, the Validity of the Product or System and the ValidityOffset in this Tier
  """
  expiryDate: Datetime

  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String
  createdAt: Datetime
  updatedAt: Datetime
  accountToRequestorAccountId: GuaranteeRequestorAccountIdFkeyInput
  projectToProjectId: GuaranteeProjectIdFkeyInput
  systemToSystemBmiRef: GuaranteeSystemBmiRefFkeyInput
  productToProductBmiRef: GuaranteeProductBmiRefFkeyInput
  accountToReviewerAccountId: GuaranteeReviewerAccountIdFkeyInput
  evidenceItemsUsingId: EvidenceItemGuaranteeIdFkeyInverseInput
}

"""
The fields on `guarantee` to look up the row to update.
"""
input GuaranteeOnEvidenceItemForEvidenceItemGuaranteeIdFkeyUsingGuaranteeBmiReferenceIdKeyUpdate {
  """
  An object where the defined keys will be set on the `guarantee` being updated.
  """
  patch: updateGuaranteeOnEvidenceItemForEvidenceItemGuaranteeIdFkeyPatch!

  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String!
}

"""
The globally unique `ID` look up for the row to update.
"""
input EvidenceItemOnEvidenceItemForEvidenceItemGuaranteeIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `guarantee` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `guarantee` being updated.
  """
  patch: GuaranteePatch!
}

"""
Represents an update to a `Guarantee`. Fields that are set will be updated.
"""
input GuaranteePatch {
  """
  Primary key - starts at 6100
  """
  id: Int

  """
  The pdf file that is emailed out, or a reference to it, or reference to the service that will generate it on demand
  """
  fileStorageId: String

  """
  fk
  """
  requestorAccountId: Int

  """
  fk
  """
  projectId: Int

  """
  a reference to the guaranteeType sys id in Contentful
  """
  guaranteeTypeId: String

  """
  fk
  """
  systemBmiRef: String

  """
  fk
  """
  productBmiRef: String

  """
  fk
  """
  reviewerAccountId: Int

  """
  a reference to the guaranteeType sys id in Contentful
  """
  guaranteeTemplateId: String

  """
  ek
  """
  status: RequestStatus

  """
  The date that the Guarantee is approved either automatically or manually
  """
  startDate: Datetime

  """
  When the guarantee will expire.  This should be calculated when the request_status becomes APPROVED. dependent on the StartDate, the Validity of the Product or System and the ValidityOffset in this Tier
  """
  expiryDate: Datetime

  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String
  createdAt: Datetime
  updatedAt: Datetime
  accountToRequestorAccountId: GuaranteeRequestorAccountIdFkeyInput
  projectToProjectId: GuaranteeProjectIdFkeyInput
  systemToSystemBmiRef: GuaranteeSystemBmiRefFkeyInput
  productToProductBmiRef: GuaranteeProductBmiRefFkeyInput
  accountToReviewerAccountId: GuaranteeReviewerAccountIdFkeyInput
  evidenceItemsUsingId: EvidenceItemGuaranteeIdFkeyInverseInput
}

"""
The `guarantee` to be created by this mutation.
"""
input EvidenceItemGuaranteeIdFkeyGuaranteeCreateInput {
  """
  Primary key - starts at 6100
  """
  id: Int

  """
  The pdf file that is emailed out, or a reference to it, or reference to the service that will generate it on demand
  """
  fileStorageId: String

  """
  fk
  """
  requestorAccountId: Int

  """
  fk
  """
  projectId: Int

  """
  a reference to the guaranteeType sys id in Contentful
  """
  guaranteeTypeId: String!

  """
  fk
  """
  systemBmiRef: String

  """
  fk
  """
  productBmiRef: String

  """
  fk
  """
  reviewerAccountId: Int

  """
  a reference to the guaranteeType sys id in Contentful
  """
  guaranteeTemplateId: String

  """
  ek
  """
  status: RequestStatus

  """
  The date that the Guarantee is approved either automatically or manually
  """
  startDate: Datetime

  """
  When the guarantee will expire.  This should be calculated when the request_status becomes APPROVED. dependent on the StartDate, the Validity of the Product or System and the ValidityOffset in this Tier
  """
  expiryDate: Datetime

  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String
  createdAt: Datetime
  updatedAt: Datetime
  accountToRequestorAccountId: GuaranteeRequestorAccountIdFkeyInput
  projectToProjectId: GuaranteeProjectIdFkeyInput
  systemToSystemBmiRef: GuaranteeSystemBmiRefFkeyInput
  productToProductBmiRef: GuaranteeProductBmiRefFkeyInput
  accountToReviewerAccountId: GuaranteeReviewerAccountIdFkeyInput
  evidenceItemsUsingId: EvidenceItemGuaranteeIdFkeyInverseInput
  guaranteeTypeCoverage: ContentfulGuaranteeCoverageType
}

"""
The globally unique `ID` look up for the row to update.
"""
input GuaranteeOnEvidenceItemForEvidenceItemGuaranteeIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `evidenceItem` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `evidenceItem` being updated.
  """
  patch: EvidenceItemPatch!
}

"""
Represents an update to a `EvidenceItem`. Fields that are set will be updated.
"""
input EvidenceItemPatch {
  """
  Primary key
  """
  id: Int

  """
  a reference to the evidenceCategory sys id in Contentful
  """
  customEvidenceCategoryId: String

  """
  fk
  """
  projectId: Int

  """
  fk
  """
  guaranteeId: Int

  """
  ek
  """
  evidenceCategoryType: EvidenceCategoryType

  """
  Short name for the item of evidence
  """
  name: String

  """
  File reference or the file itself. Photo of the evidence
  """
  attachment: String
  createdAt: Datetime
  updatedAt: Datetime
  projectToProjectId: EvidenceItemProjectIdFkeyInput
  guaranteeToGuaranteeId: EvidenceItemGuaranteeIdFkeyInput
}

"""
The `evidenceItem` to be created by this mutation.
"""
input EvidenceItemGuaranteeIdFkeyEvidenceItemCreateInput {
  """
  Primary key
  """
  id: Int

  """
  a reference to the evidenceCategory sys id in Contentful
  """
  customEvidenceCategoryId: String

  """
  fk
  """
  projectId: Int

  """
  ek
  """
  evidenceCategoryType: EvidenceCategoryType

  """
  Short name for the item of evidence
  """
  name: String!

  """
  File reference or the file itself. Photo of the evidence
  """
  attachment: String!
  createdAt: Datetime
  updatedAt: Datetime
  projectToProjectId: EvidenceItemProjectIdFkeyInput
  guaranteeToGuaranteeId: EvidenceItemGuaranteeIdFkeyInput
  attachmentUpload: Upload
}

"""
The fields on `guarantee` to look up the row to update.
"""
input GuaranteeOnGuaranteeForGuaranteeProductBmiRefFkeyUsingGuaranteeBmiReferenceIdKeyUpdate {
  """
  An object where the defined keys will be set on the `guarantee` being updated.
  """
  patch: updateGuaranteeOnGuaranteeForGuaranteeProductBmiRefFkeyPatch!

  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String!
}

"""
The globally unique `ID` look up for the row to update.
"""
input ProductOnGuaranteeForGuaranteeProductBmiRefFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `guarantee` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `guarantee` being updated.
  """
  patch: GuaranteePatch!
}

"""
The `guarantee` to be created by this mutation.
"""
input GuaranteeProductBmiRefFkeyGuaranteeCreateInput {
  """
  Primary key - starts at 6100
  """
  id: Int

  """
  The pdf file that is emailed out, or a reference to it, or reference to the service that will generate it on demand
  """
  fileStorageId: String

  """
  fk
  """
  requestorAccountId: Int

  """
  fk
  """
  projectId: Int

  """
  a reference to the guaranteeType sys id in Contentful
  """
  guaranteeTypeId: String!

  """
  fk
  """
  systemBmiRef: String

  """
  fk
  """
  reviewerAccountId: Int

  """
  a reference to the guaranteeType sys id in Contentful
  """
  guaranteeTemplateId: String

  """
  ek
  """
  status: RequestStatus

  """
  The date that the Guarantee is approved either automatically or manually
  """
  startDate: Datetime

  """
  When the guarantee will expire.  This should be calculated when the request_status becomes APPROVED. dependent on the StartDate, the Validity of the Product or System and the ValidityOffset in this Tier
  """
  expiryDate: Datetime

  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String
  createdAt: Datetime
  updatedAt: Datetime
  accountToRequestorAccountId: GuaranteeRequestorAccountIdFkeyInput
  projectToProjectId: GuaranteeProjectIdFkeyInput
  systemToSystemBmiRef: GuaranteeSystemBmiRefFkeyInput
  productToProductBmiRef: GuaranteeProductBmiRefFkeyInput
  accountToReviewerAccountId: GuaranteeReviewerAccountIdFkeyInput
  evidenceItemsUsingId: EvidenceItemGuaranteeIdFkeyInverseInput
  guaranteeTypeCoverage: ContentfulGuaranteeCoverageType
}

"""
Input for the nested mutation of `systemMember` in the `ProductInput` mutation.
"""
input SystemMemberProductBmiRefFkeyInverseInput {
  """
  Flag indicating whether all other `systemMember` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `systemMember` for the far side of the relationship.
  """
  connectById: [SystemMemberSystemMemberPkeyConnect!]

  """
  The primary key(s) for `systemMember` for the far side of the relationship.
  """
  connectBySystemBmiRefAndProductBmiRefAndMarketId: [SystemMemberSystemMemberSystemBmiRefProductBmiRefMarketIdKeyConnect!]

  """
  The primary key(s) for `systemMember` for the far side of the relationship.
  """
  connectByNodeId: [SystemMemberNodeIdConnect!]

  """
  The primary key(s) for `systemMember` for the far side of the relationship.
  """
  deleteById: [SystemMemberSystemMemberPkeyDelete!]

  """
  The primary key(s) for `systemMember` for the far side of the relationship.
  """
  deleteBySystemBmiRefAndProductBmiRefAndMarketId: [SystemMemberSystemMemberSystemBmiRefProductBmiRefMarketIdKeyDelete!]

  """
  The primary key(s) for `systemMember` for the far side of the relationship.
  """
  deleteByNodeId: [SystemMemberNodeIdDelete!]

  """
  The primary key(s) and patch data for `systemMember` for the far side of the relationship.
  """
  updateById: [SystemMemberOnSystemMemberForSystemMemberProductBmiRefFkeyUsingSystemMemberPkeyUpdate!]

  """
  The primary key(s) and patch data for `systemMember` for the far side of the relationship.
  """
  updateBySystemBmiRefAndProductBmiRefAndMarketId: [SystemMemberOnSystemMemberForSystemMemberProductBmiRefFkeyUsingSystemMemberSystemBmiRefProductBmiRefMarketIdKeyUpdate!]

  """
  The primary key(s) and patch data for `systemMember` for the far side of the relationship.
  """
  updateByNodeId: [ProductOnSystemMemberForSystemMemberProductBmiRefFkeyNodeIdUpdate!]

  """
  A `SystemMemberInput` object that will be created and connected to this object.
  """
  create: [SystemMemberProductBmiRefFkeySystemMemberCreateInput!]
}

"""
The fields on `systemMember` to look up the row to connect.
"""
input SystemMemberSystemMemberPkeyConnect {
  """
  Primary key
  """
  id: Int!
}

"""
The fields on `systemMember` to look up the row to connect.
"""
input SystemMemberSystemMemberSystemBmiRefProductBmiRefMarketIdKeyConnect {
  """
  fk
  """
  systemBmiRef: String!

  """
  fk
  """
  productBmiRef: String!

  """
  fk
  """
  marketId: Int!
}

"""
The globally unique `ID` look up for the row to connect.
"""
input SystemMemberNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `systemMember` to be connected.
  """
  nodeId: ID!
}

"""
The fields on `systemMember` to look up the row to delete.
"""
input SystemMemberSystemMemberPkeyDelete {
  """
  Primary key
  """
  id: Int!
}

"""
The fields on `systemMember` to look up the row to delete.
"""
input SystemMemberSystemMemberSystemBmiRefProductBmiRefMarketIdKeyDelete {
  """
  fk
  """
  systemBmiRef: String!

  """
  fk
  """
  productBmiRef: String!

  """
  fk
  """
  marketId: Int!
}

"""
The globally unique `ID` look up for the row to delete.
"""
input SystemMemberNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `systemMember` to be deleted.
  """
  nodeId: ID!
}

"""
The fields on `systemMember` to look up the row to update.
"""
input SystemMemberOnSystemMemberForSystemMemberProductBmiRefFkeyUsingSystemMemberPkeyUpdate {
  """
  An object where the defined keys will be set on the `systemMember` being updated.
  """
  patch: updateSystemMemberOnSystemMemberForSystemMemberProductBmiRefFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `systemMember` being updated.
"""
input updateSystemMemberOnSystemMemberForSystemMemberProductBmiRefFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  systemBmiRef: String

  """
  fk
  """
  marketId: Int
  createdAt: Datetime
  updatedAt: Datetime
  systemToSystemBmiRef: SystemMemberSystemBmiRefFkeyInput
  productToProductBmiRef: SystemMemberProductBmiRefFkeyInput
  marketToMarketId: SystemMemberMarketIdFkeyInput
}

"""
Input for the nested mutation of `system` in the `SystemMemberInput` mutation.
"""
input SystemMemberSystemBmiRefFkeyInput {
  """
  The primary key(s) for `system` for the far side of the relationship.
  """
  connectById: SystemSystemPkeyConnect

  """
  The primary key(s) for `system` for the far side of the relationship.
  """
  connectByBmiRef: SystemSystemBmiRefKeyConnect

  """
  The primary key(s) for `system` for the far side of the relationship.
  """
  connectByNodeId: SystemNodeIdConnect

  """
  The primary key(s) for `system` for the far side of the relationship.
  """
  deleteById: SystemSystemPkeyDelete

  """
  The primary key(s) for `system` for the far side of the relationship.
  """
  deleteByBmiRef: SystemSystemBmiRefKeyDelete

  """
  The primary key(s) for `system` for the far side of the relationship.
  """
  deleteByNodeId: SystemNodeIdDelete

  """
  The primary key(s) and patch data for `system` for the far side of the relationship.
  """
  updateById: SystemOnSystemMemberForSystemMemberSystemBmiRefFkeyUsingSystemPkeyUpdate

  """
  The primary key(s) and patch data for `system` for the far side of the relationship.
  """
  updateByBmiRef: SystemOnSystemMemberForSystemMemberSystemBmiRefFkeyUsingSystemBmiRefKeyUpdate

  """
  The primary key(s) and patch data for `system` for the far side of the relationship.
  """
  updateByNodeId: SystemMemberOnSystemMemberForSystemMemberSystemBmiRefFkeyNodeIdUpdate

  """
  A `SystemInput` object that will be created and connected to this object.
  """
  create: SystemMemberSystemBmiRefFkeySystemCreateInput
}

"""
The fields on `system` to look up the row to update.
"""
input SystemOnSystemMemberForSystemMemberSystemBmiRefFkeyUsingSystemPkeyUpdate {
  """
  An object where the defined keys will be set on the `system` being updated.
  """
  patch: updateSystemOnSystemMemberForSystemMemberSystemBmiRefFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `system` being updated.
"""
input updateSystemOnSystemMemberForSystemMemberSystemBmiRefFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int

  """
  ek
  """
  technology: Technology

  """
  A unique reference for the system known to BMI
  """
  bmiRef: String

  """
  Short name for the System
  """
  name: String

  """
  A description for the System
  """
  description: String

  """
  The maximum number of years that this system can be guaranteed for.  Must be greater than 10.
  """
  maximumValidityYears: Int

  """
  If true this system is available for users to select when applying for a system or solution guarantee
  """
  published: Boolean
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: SystemMarketIdFkeyInput
  guaranteesUsingBmiRef: GuaranteeSystemBmiRefFkeyInverseInput
  systemMembersUsingBmiRef: SystemMemberSystemBmiRefFkeyInverseInput
}

"""
Input for the nested mutation of `systemMember` in the `SystemInput` mutation.
"""
input SystemMemberSystemBmiRefFkeyInverseInput {
  """
  Flag indicating whether all other `systemMember` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `systemMember` for the far side of the relationship.
  """
  connectById: [SystemMemberSystemMemberPkeyConnect!]

  """
  The primary key(s) for `systemMember` for the far side of the relationship.
  """
  connectBySystemBmiRefAndProductBmiRefAndMarketId: [SystemMemberSystemMemberSystemBmiRefProductBmiRefMarketIdKeyConnect!]

  """
  The primary key(s) for `systemMember` for the far side of the relationship.
  """
  connectByNodeId: [SystemMemberNodeIdConnect!]

  """
  The primary key(s) for `systemMember` for the far side of the relationship.
  """
  deleteById: [SystemMemberSystemMemberPkeyDelete!]

  """
  The primary key(s) for `systemMember` for the far side of the relationship.
  """
  deleteBySystemBmiRefAndProductBmiRefAndMarketId: [SystemMemberSystemMemberSystemBmiRefProductBmiRefMarketIdKeyDelete!]

  """
  The primary key(s) for `systemMember` for the far side of the relationship.
  """
  deleteByNodeId: [SystemMemberNodeIdDelete!]

  """
  The primary key(s) and patch data for `systemMember` for the far side of the relationship.
  """
  updateById: [SystemMemberOnSystemMemberForSystemMemberSystemBmiRefFkeyUsingSystemMemberPkeyUpdate!]

  """
  The primary key(s) and patch data for `systemMember` for the far side of the relationship.
  """
  updateBySystemBmiRefAndProductBmiRefAndMarketId: [SystemMemberOnSystemMemberForSystemMemberSystemBmiRefFkeyUsingSystemMemberSystemBmiRefProductBmiRefMarketIdKeyUpdate!]

  """
  The primary key(s) and patch data for `systemMember` for the far side of the relationship.
  """
  updateByNodeId: [SystemOnSystemMemberForSystemMemberSystemBmiRefFkeyNodeIdUpdate!]

  """
  A `SystemMemberInput` object that will be created and connected to this object.
  """
  create: [SystemMemberSystemBmiRefFkeySystemMemberCreateInput!]
}

"""
The fields on `systemMember` to look up the row to update.
"""
input SystemMemberOnSystemMemberForSystemMemberSystemBmiRefFkeyUsingSystemMemberPkeyUpdate {
  """
  An object where the defined keys will be set on the `systemMember` being updated.
  """
  patch: updateSystemMemberOnSystemMemberForSystemMemberSystemBmiRefFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `systemMember` being updated.
"""
input updateSystemMemberOnSystemMemberForSystemMemberSystemBmiRefFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  productBmiRef: String

  """
  fk
  """
  marketId: Int
  createdAt: Datetime
  updatedAt: Datetime
  systemToSystemBmiRef: SystemMemberSystemBmiRefFkeyInput
  productToProductBmiRef: SystemMemberProductBmiRefFkeyInput
  marketToMarketId: SystemMemberMarketIdFkeyInput
}

"""
Input for the nested mutation of `product` in the `SystemMemberInput` mutation.
"""
input SystemMemberProductBmiRefFkeyInput {
  """
  The primary key(s) for `product` for the far side of the relationship.
  """
  connectById: ProductProductPkeyConnect

  """
  The primary key(s) for `product` for the far side of the relationship.
  """
  connectByBmiRef: ProductProductBmiRefKeyConnect

  """
  The primary key(s) for `product` for the far side of the relationship.
  """
  connectByNodeId: ProductNodeIdConnect

  """
  The primary key(s) for `product` for the far side of the relationship.
  """
  deleteById: ProductProductPkeyDelete

  """
  The primary key(s) for `product` for the far side of the relationship.
  """
  deleteByBmiRef: ProductProductBmiRefKeyDelete

  """
  The primary key(s) for `product` for the far side of the relationship.
  """
  deleteByNodeId: ProductNodeIdDelete

  """
  The primary key(s) and patch data for `product` for the far side of the relationship.
  """
  updateById: ProductOnSystemMemberForSystemMemberProductBmiRefFkeyUsingProductPkeyUpdate

  """
  The primary key(s) and patch data for `product` for the far side of the relationship.
  """
  updateByBmiRef: ProductOnSystemMemberForSystemMemberProductBmiRefFkeyUsingProductBmiRefKeyUpdate

  """
  The primary key(s) and patch data for `product` for the far side of the relationship.
  """
  updateByNodeId: SystemMemberOnSystemMemberForSystemMemberProductBmiRefFkeyNodeIdUpdate

  """
  A `ProductInput` object that will be created and connected to this object.
  """
  create: SystemMemberProductBmiRefFkeyProductCreateInput
}

"""
The fields on `product` to look up the row to update.
"""
input ProductOnSystemMemberForSystemMemberProductBmiRefFkeyUsingProductPkeyUpdate {
  """
  An object where the defined keys will be set on the `product` being updated.
  """
  patch: updateProductOnSystemMemberForSystemMemberProductBmiRefFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `product` being updated.
"""
input updateProductOnSystemMemberForSystemMemberProductBmiRefFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int

  """
  ek
  """
  technology: Technology

  """
  A unique reference for the product known to BMI
  """
  bmiRef: String

  """
  The Products brand
  """
  brand: String

  """
  Short name for the Product
  """
  name: String

  """
  A description of the Product
  """
  description: String

  """
  The family of Products this Product is in
  """
  family: String

  """
  Whether the Product is avialable for new guarantees
  """
  published: Boolean

  """
  The number of years that this product can be guaranteed for
  """
  maximumValidityYears: Int
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: ProductMarketIdFkeyInput
  guaranteesUsingBmiRef: GuaranteeProductBmiRefFkeyInverseInput
  systemMembersUsingBmiRef: SystemMemberProductBmiRefFkeyInverseInput
}

"""
The fields on `product` to look up the row to update.
"""
input ProductOnSystemMemberForSystemMemberProductBmiRefFkeyUsingProductBmiRefKeyUpdate {
  """
  An object where the defined keys will be set on the `product` being updated.
  """
  patch: updateProductOnSystemMemberForSystemMemberProductBmiRefFkeyPatch!

  """
  A unique reference for the product known to BMI
  """
  bmiRef: String!
}

"""
The globally unique `ID` look up for the row to update.
"""
input SystemMemberOnSystemMemberForSystemMemberProductBmiRefFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `product` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `product` being updated.
  """
  patch: ProductPatch!
}

"""
Represents an update to a `Product`. Fields that are set will be updated.
"""
input ProductPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int

  """
  ek
  """
  technology: Technology

  """
  A unique reference for the product known to BMI
  """
  bmiRef: String

  """
  The Products brand
  """
  brand: String

  """
  Short name for the Product
  """
  name: String

  """
  A description of the Product
  """
  description: String

  """
  The family of Products this Product is in
  """
  family: String

  """
  Whether the Product is avialable for new guarantees
  """
  published: Boolean

  """
  The number of years that this product can be guaranteed for
  """
  maximumValidityYears: Int
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: ProductMarketIdFkeyInput
  guaranteesUsingBmiRef: GuaranteeProductBmiRefFkeyInverseInput
  systemMembersUsingBmiRef: SystemMemberProductBmiRefFkeyInverseInput
}

"""
The `product` to be created by this mutation.
"""
input SystemMemberProductBmiRefFkeyProductCreateInput {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int

  """
  ek
  """
  technology: Technology

  """
  A unique reference for the product known to BMI
  """
  bmiRef: String!

  """
  The Products brand
  """
  brand: String!

  """
  Short name for the Product
  """
  name: String!

  """
  A description of the Product
  """
  description: String

  """
  The family of Products this Product is in
  """
  family: String!

  """
  Whether the Product is avialable for new guarantees
  """
  published: Boolean!

  """
  The number of years that this product can be guaranteed for
  """
  maximumValidityYears: Int!
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: ProductMarketIdFkeyInput
  guaranteesUsingBmiRef: GuaranteeProductBmiRefFkeyInverseInput
  systemMembersUsingBmiRef: SystemMemberProductBmiRefFkeyInverseInput
}

"""
Input for the nested mutation of `market` in the `SystemMemberInput` mutation.
"""
input SystemMemberMarketIdFkeyInput {
  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectById: MarketMarketPkeyConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectByDomain: MarketMarketDomainKeyConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectByDoceboCatalogueId: MarketMarketDoceboCatalogueIdKeyConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  connectByNodeId: MarketNodeIdConnect

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteById: MarketMarketPkeyDelete

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteByDomain: MarketMarketDomainKeyDelete

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteByDoceboCatalogueId: MarketMarketDoceboCatalogueIdKeyDelete

  """
  The primary key(s) for `market` for the far side of the relationship.
  """
  deleteByNodeId: MarketNodeIdDelete

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateById: MarketOnSystemMemberForSystemMemberMarketIdFkeyUsingMarketPkeyUpdate

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateByDomain: MarketOnSystemMemberForSystemMemberMarketIdFkeyUsingMarketDomainKeyUpdate

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateByDoceboCatalogueId: MarketOnSystemMemberForSystemMemberMarketIdFkeyUsingMarketDoceboCatalogueIdKeyUpdate

  """
  The primary key(s) and patch data for `market` for the far side of the relationship.
  """
  updateByNodeId: SystemMemberOnSystemMemberForSystemMemberMarketIdFkeyNodeIdUpdate

  """
  A `MarketInput` object that will be created and connected to this object.
  """
  create: SystemMemberMarketIdFkeyMarketCreateInput
}

"""
The fields on `market` to look up the row to update.
"""
input MarketOnSystemMemberForSystemMemberMarketIdFkeyUsingMarketPkeyUpdate {
  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: updateMarketOnSystemMemberForSystemMemberMarketIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `market` being updated.
"""
input updateMarketOnSystemMemberForSystemMemberMarketIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  ek
  """
  language: Language

  """
  the country code used for example as the subdomain
  """
  domain: String

  """
  The space in Contenful
  """
  cmsSpaceId: String

  """
  A short name for the market, e.g. Italy, Norway, Netherlands
  """
  name: String

  """
  The From name used when sending an email
  """
  sendName: String

  """
  The mailbox on intouch.bmigroup.com that emails will be sent from for this Market
  """
  sendMailbox: String

  """
  The default branch in Docebo that installers go into
  """
  doceboInstallersBranchId: String

  """
  The branch in Docebo that company admins go into
  """
  doceboCompanyAdminBranchId: String

  """
  The default catalogue for the market.  All users in the market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int

  """
  The address of the merchandising site for the market.  CTAs of the MERCHANDISING type will link to this address
  """
  merchandisingUrl: String

  """
  Whether the market supports Projects.  If so then the Projects link should be available in th left hand navigation.
  """
  projectsEnabled: Boolean

  """
  Reference to the Google Analytics tracking ID that is used for the Country GA reports
  """
  gtag: String

  """
  The coordinates of the middle of the Market on a map
  """
  geoMiddle: PointInput

  """
  The length of the radius in km (from the geo_middle lat/lng), for which the Google Places API biases the search results for address autocomplete. Locations outside of the radius will not be excluded.
  """
  locationBiasRadiusKm: Int
  createdAt: Datetime
  updatedAt: Datetime
  accountsUsingId: AccountMarketIdFkeyInverseInput
  companiesUsingId: CompanyMarketIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberMarketIdFkeyInverseInput
  productsUsingId: ProductMarketIdFkeyInverseInput
  systemsUsingId: SystemMarketIdFkeyInverseInput
  systemMembersUsingId: SystemMemberMarketIdFkeyInverseInput
}

"""
Input for the nested mutation of `systemMember` in the `MarketInput` mutation.
"""
input SystemMemberMarketIdFkeyInverseInput {
  """
  Flag indicating whether all other `systemMember` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `systemMember` for the far side of the relationship.
  """
  connectById: [SystemMemberSystemMemberPkeyConnect!]

  """
  The primary key(s) for `systemMember` for the far side of the relationship.
  """
  connectBySystemBmiRefAndProductBmiRefAndMarketId: [SystemMemberSystemMemberSystemBmiRefProductBmiRefMarketIdKeyConnect!]

  """
  The primary key(s) for `systemMember` for the far side of the relationship.
  """
  connectByNodeId: [SystemMemberNodeIdConnect!]

  """
  The primary key(s) for `systemMember` for the far side of the relationship.
  """
  deleteById: [SystemMemberSystemMemberPkeyDelete!]

  """
  The primary key(s) for `systemMember` for the far side of the relationship.
  """
  deleteBySystemBmiRefAndProductBmiRefAndMarketId: [SystemMemberSystemMemberSystemBmiRefProductBmiRefMarketIdKeyDelete!]

  """
  The primary key(s) for `systemMember` for the far side of the relationship.
  """
  deleteByNodeId: [SystemMemberNodeIdDelete!]

  """
  The primary key(s) and patch data for `systemMember` for the far side of the relationship.
  """
  updateById: [SystemMemberOnSystemMemberForSystemMemberMarketIdFkeyUsingSystemMemberPkeyUpdate!]

  """
  The primary key(s) and patch data for `systemMember` for the far side of the relationship.
  """
  updateBySystemBmiRefAndProductBmiRefAndMarketId: [SystemMemberOnSystemMemberForSystemMemberMarketIdFkeyUsingSystemMemberSystemBmiRefProductBmiRefMarketIdKeyUpdate!]

  """
  The primary key(s) and patch data for `systemMember` for the far side of the relationship.
  """
  updateByNodeId: [MarketOnSystemMemberForSystemMemberMarketIdFkeyNodeIdUpdate!]

  """
  A `SystemMemberInput` object that will be created and connected to this object.
  """
  create: [SystemMemberMarketIdFkeySystemMemberCreateInput!]
}

"""
The fields on `systemMember` to look up the row to update.
"""
input SystemMemberOnSystemMemberForSystemMemberMarketIdFkeyUsingSystemMemberPkeyUpdate {
  """
  An object where the defined keys will be set on the `systemMember` being updated.
  """
  patch: updateSystemMemberOnSystemMemberForSystemMemberMarketIdFkeyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
An object where the defined keys will be set on the `systemMember` being updated.
"""
input updateSystemMemberOnSystemMemberForSystemMemberMarketIdFkeyPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  systemBmiRef: String

  """
  fk
  """
  productBmiRef: String
  createdAt: Datetime
  updatedAt: Datetime
  systemToSystemBmiRef: SystemMemberSystemBmiRefFkeyInput
  productToProductBmiRef: SystemMemberProductBmiRefFkeyInput
  marketToMarketId: SystemMemberMarketIdFkeyInput
}

"""
The fields on `systemMember` to look up the row to update.
"""
input SystemMemberOnSystemMemberForSystemMemberMarketIdFkeyUsingSystemMemberSystemBmiRefProductBmiRefMarketIdKeyUpdate {
  """
  An object where the defined keys will be set on the `systemMember` being updated.
  """
  patch: updateSystemMemberOnSystemMemberForSystemMemberMarketIdFkeyPatch!

  """
  fk
  """
  systemBmiRef: String!

  """
  fk
  """
  productBmiRef: String!

  """
  fk
  """
  marketId: Int!
}

"""
The globally unique `ID` look up for the row to update.
"""
input MarketOnSystemMemberForSystemMemberMarketIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `systemMember` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `systemMember` being updated.
  """
  patch: SystemMemberPatch!
}

"""
Represents an update to a `SystemMember`. Fields that are set will be updated.
"""
input SystemMemberPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  systemBmiRef: String

  """
  fk
  """
  productBmiRef: String

  """
  fk
  """
  marketId: Int
  createdAt: Datetime
  updatedAt: Datetime
  systemToSystemBmiRef: SystemMemberSystemBmiRefFkeyInput
  productToProductBmiRef: SystemMemberProductBmiRefFkeyInput
  marketToMarketId: SystemMemberMarketIdFkeyInput
}

"""
The `systemMember` to be created by this mutation.
"""
input SystemMemberMarketIdFkeySystemMemberCreateInput {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  systemBmiRef: String

  """
  fk
  """
  productBmiRef: String
  createdAt: Datetime
  updatedAt: Datetime
  systemToSystemBmiRef: SystemMemberSystemBmiRefFkeyInput
  productToProductBmiRef: SystemMemberProductBmiRefFkeyInput
  marketToMarketId: SystemMemberMarketIdFkeyInput
}

"""
The fields on `market` to look up the row to update.
"""
input MarketOnSystemMemberForSystemMemberMarketIdFkeyUsingMarketDomainKeyUpdate {
  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: updateMarketOnSystemMemberForSystemMemberMarketIdFkeyPatch!

  """
  the country code used for example as the subdomain
  """
  domain: String!
}

"""
The fields on `market` to look up the row to update.
"""
input MarketOnSystemMemberForSystemMemberMarketIdFkeyUsingMarketDoceboCatalogueIdKeyUpdate {
  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: updateMarketOnSystemMemberForSystemMemberMarketIdFkeyPatch!

  """
  The default catalogue for the market.  All users in the market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int!
}

"""
The globally unique `ID` look up for the row to update.
"""
input SystemMemberOnSystemMemberForSystemMemberMarketIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `market` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: MarketPatch!
}

"""
Represents an update to a `Market`. Fields that are set will be updated.
"""
input MarketPatch {
  """
  Primary key
  """
  id: Int

  """
  ek
  """
  language: Language

  """
  the country code used for example as the subdomain
  """
  domain: String

  """
  The space in Contenful
  """
  cmsSpaceId: String

  """
  A short name for the market, e.g. Italy, Norway, Netherlands
  """
  name: String

  """
  The From name used when sending an email
  """
  sendName: String

  """
  The mailbox on intouch.bmigroup.com that emails will be sent from for this Market
  """
  sendMailbox: String

  """
  The default branch in Docebo that installers go into
  """
  doceboInstallersBranchId: String

  """
  The branch in Docebo that company admins go into
  """
  doceboCompanyAdminBranchId: String

  """
  The default catalogue for the market.  All users in the market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int

  """
  The address of the merchandising site for the market.  CTAs of the MERCHANDISING type will link to this address
  """
  merchandisingUrl: String

  """
  Whether the market supports Projects.  If so then the Projects link should be available in th left hand navigation.
  """
  projectsEnabled: Boolean

  """
  Reference to the Google Analytics tracking ID that is used for the Country GA reports
  """
  gtag: String

  """
  The coordinates of the middle of the Market on a map
  """
  geoMiddle: PointInput

  """
  The length of the radius in km (from the geo_middle lat/lng), for which the Google Places API biases the search results for address autocomplete. Locations outside of the radius will not be excluded.
  """
  locationBiasRadiusKm: Int
  createdAt: Datetime
  updatedAt: Datetime
  accountsUsingId: AccountMarketIdFkeyInverseInput
  companiesUsingId: CompanyMarketIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberMarketIdFkeyInverseInput
  productsUsingId: ProductMarketIdFkeyInverseInput
  systemsUsingId: SystemMarketIdFkeyInverseInput
  systemMembersUsingId: SystemMemberMarketIdFkeyInverseInput
}

"""
The `market` to be created by this mutation.
"""
input SystemMemberMarketIdFkeyMarketCreateInput {
  """
  Primary key
  """
  id: Int

  """
  ek
  """
  language: Language

  """
  the country code used for example as the subdomain
  """
  domain: String!

  """
  The space in Contenful
  """
  cmsSpaceId: String

  """
  A short name for the market, e.g. Italy, Norway, Netherlands
  """
  name: String

  """
  The From name used when sending an email
  """
  sendName: String

  """
  The mailbox on intouch.bmigroup.com that emails will be sent from for this Market
  """
  sendMailbox: String

  """
  The default branch in Docebo that installers go into
  """
  doceboInstallersBranchId: String

  """
  The branch in Docebo that company admins go into
  """
  doceboCompanyAdminBranchId: String

  """
  The default catalogue for the market.  All users in the market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int

  """
  The address of the merchandising site for the market.  CTAs of the MERCHANDISING type will link to this address
  """
  merchandisingUrl: String

  """
  Whether the market supports Projects.  If so then the Projects link should be available in th left hand navigation.
  """
  projectsEnabled: Boolean

  """
  Reference to the Google Analytics tracking ID that is used for the Country GA reports
  """
  gtag: String

  """
  The coordinates of the middle of the Market on a map
  """
  geoMiddle: PointInput

  """
  The length of the radius in km (from the geo_middle lat/lng), for which the Google Places API biases the search results for address autocomplete. Locations outside of the radius will not be excluded.
  """
  locationBiasRadiusKm: Int
  createdAt: Datetime
  updatedAt: Datetime
  accountsUsingId: AccountMarketIdFkeyInverseInput
  companiesUsingId: CompanyMarketIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberMarketIdFkeyInverseInput
  productsUsingId: ProductMarketIdFkeyInverseInput
  systemsUsingId: SystemMarketIdFkeyInverseInput
  systemMembersUsingId: SystemMemberMarketIdFkeyInverseInput
}

"""
The fields on `systemMember` to look up the row to update.
"""
input SystemMemberOnSystemMemberForSystemMemberSystemBmiRefFkeyUsingSystemMemberSystemBmiRefProductBmiRefMarketIdKeyUpdate {
  """
  An object where the defined keys will be set on the `systemMember` being updated.
  """
  patch: updateSystemMemberOnSystemMemberForSystemMemberSystemBmiRefFkeyPatch!

  """
  fk
  """
  systemBmiRef: String!

  """
  fk
  """
  productBmiRef: String!

  """
  fk
  """
  marketId: Int!
}

"""
The globally unique `ID` look up for the row to update.
"""
input SystemOnSystemMemberForSystemMemberSystemBmiRefFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `systemMember` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `systemMember` being updated.
  """
  patch: SystemMemberPatch!
}

"""
The `systemMember` to be created by this mutation.
"""
input SystemMemberSystemBmiRefFkeySystemMemberCreateInput {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  productBmiRef: String

  """
  fk
  """
  marketId: Int
  createdAt: Datetime
  updatedAt: Datetime
  systemToSystemBmiRef: SystemMemberSystemBmiRefFkeyInput
  productToProductBmiRef: SystemMemberProductBmiRefFkeyInput
  marketToMarketId: SystemMemberMarketIdFkeyInput
}

"""
The fields on `system` to look up the row to update.
"""
input SystemOnSystemMemberForSystemMemberSystemBmiRefFkeyUsingSystemBmiRefKeyUpdate {
  """
  An object where the defined keys will be set on the `system` being updated.
  """
  patch: updateSystemOnSystemMemberForSystemMemberSystemBmiRefFkeyPatch!

  """
  A unique reference for the system known to BMI
  """
  bmiRef: String!
}

"""
The globally unique `ID` look up for the row to update.
"""
input SystemMemberOnSystemMemberForSystemMemberSystemBmiRefFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `system` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `system` being updated.
  """
  patch: SystemPatch!
}

"""
Represents an update to a `System`. Fields that are set will be updated.
"""
input SystemPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int

  """
  ek
  """
  technology: Technology

  """
  A unique reference for the system known to BMI
  """
  bmiRef: String

  """
  Short name for the System
  """
  name: String

  """
  A description for the System
  """
  description: String

  """
  The maximum number of years that this system can be guaranteed for.  Must be greater than 10.
  """
  maximumValidityYears: Int

  """
  If true this system is available for users to select when applying for a system or solution guarantee
  """
  published: Boolean
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: SystemMarketIdFkeyInput
  guaranteesUsingBmiRef: GuaranteeSystemBmiRefFkeyInverseInput
  systemMembersUsingBmiRef: SystemMemberSystemBmiRefFkeyInverseInput
}

"""
The `system` to be created by this mutation.
"""
input SystemMemberSystemBmiRefFkeySystemCreateInput {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int

  """
  ek
  """
  technology: Technology

  """
  A unique reference for the system known to BMI
  """
  bmiRef: String!

  """
  Short name for the System
  """
  name: String!

  """
  A description for the System
  """
  description: String

  """
  The maximum number of years that this system can be guaranteed for.  Must be greater than 10.
  """
  maximumValidityYears: Int!

  """
  If true this system is available for users to select when applying for a system or solution guarantee
  """
  published: Boolean!
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: SystemMarketIdFkeyInput
  guaranteesUsingBmiRef: GuaranteeSystemBmiRefFkeyInverseInput
  systemMembersUsingBmiRef: SystemMemberSystemBmiRefFkeyInverseInput
}

"""
The fields on `systemMember` to look up the row to update.
"""
input SystemMemberOnSystemMemberForSystemMemberProductBmiRefFkeyUsingSystemMemberSystemBmiRefProductBmiRefMarketIdKeyUpdate {
  """
  An object where the defined keys will be set on the `systemMember` being updated.
  """
  patch: updateSystemMemberOnSystemMemberForSystemMemberProductBmiRefFkeyPatch!

  """
  fk
  """
  systemBmiRef: String!

  """
  fk
  """
  productBmiRef: String!

  """
  fk
  """
  marketId: Int!
}

"""
The globally unique `ID` look up for the row to update.
"""
input ProductOnSystemMemberForSystemMemberProductBmiRefFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `systemMember` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `systemMember` being updated.
  """
  patch: SystemMemberPatch!
}

"""
The `systemMember` to be created by this mutation.
"""
input SystemMemberProductBmiRefFkeySystemMemberCreateInput {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  systemBmiRef: String

  """
  fk
  """
  marketId: Int
  createdAt: Datetime
  updatedAt: Datetime
  systemToSystemBmiRef: SystemMemberSystemBmiRefFkeyInput
  productToProductBmiRef: SystemMemberProductBmiRefFkeyInput
  marketToMarketId: SystemMemberMarketIdFkeyInput
}

"""
The fields on `product` to look up the row to update.
"""
input ProductOnGuaranteeForGuaranteeProductBmiRefFkeyUsingProductBmiRefKeyUpdate {
  """
  An object where the defined keys will be set on the `product` being updated.
  """
  patch: updateProductOnGuaranteeForGuaranteeProductBmiRefFkeyPatch!

  """
  A unique reference for the product known to BMI
  """
  bmiRef: String!
}

"""
The globally unique `ID` look up for the row to update.
"""
input GuaranteeOnGuaranteeForGuaranteeProductBmiRefFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `product` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `product` being updated.
  """
  patch: ProductPatch!
}

"""
The `product` to be created by this mutation.
"""
input GuaranteeProductBmiRefFkeyProductCreateInput {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int

  """
  ek
  """
  technology: Technology

  """
  A unique reference for the product known to BMI
  """
  bmiRef: String!

  """
  The Products brand
  """
  brand: String!

  """
  Short name for the Product
  """
  name: String!

  """
  A description of the Product
  """
  description: String

  """
  The family of Products this Product is in
  """
  family: String!

  """
  Whether the Product is avialable for new guarantees
  """
  published: Boolean!

  """
  The number of years that this product can be guaranteed for
  """
  maximumValidityYears: Int!
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: ProductMarketIdFkeyInput
  guaranteesUsingBmiRef: GuaranteeProductBmiRefFkeyInverseInput
  systemMembersUsingBmiRef: SystemMemberProductBmiRefFkeyInverseInput
}

"""
The fields on `guarantee` to look up the row to update.
"""
input GuaranteeOnGuaranteeForGuaranteeSystemBmiRefFkeyUsingGuaranteeBmiReferenceIdKeyUpdate {
  """
  An object where the defined keys will be set on the `guarantee` being updated.
  """
  patch: updateGuaranteeOnGuaranteeForGuaranteeSystemBmiRefFkeyPatch!

  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String!
}

"""
The globally unique `ID` look up for the row to update.
"""
input SystemOnGuaranteeForGuaranteeSystemBmiRefFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `guarantee` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `guarantee` being updated.
  """
  patch: GuaranteePatch!
}

"""
The `guarantee` to be created by this mutation.
"""
input GuaranteeSystemBmiRefFkeyGuaranteeCreateInput {
  """
  Primary key - starts at 6100
  """
  id: Int

  """
  The pdf file that is emailed out, or a reference to it, or reference to the service that will generate it on demand
  """
  fileStorageId: String

  """
  fk
  """
  requestorAccountId: Int

  """
  fk
  """
  projectId: Int

  """
  a reference to the guaranteeType sys id in Contentful
  """
  guaranteeTypeId: String!

  """
  fk
  """
  productBmiRef: String

  """
  fk
  """
  reviewerAccountId: Int

  """
  a reference to the guaranteeType sys id in Contentful
  """
  guaranteeTemplateId: String

  """
  ek
  """
  status: RequestStatus

  """
  The date that the Guarantee is approved either automatically or manually
  """
  startDate: Datetime

  """
  When the guarantee will expire.  This should be calculated when the request_status becomes APPROVED. dependent on the StartDate, the Validity of the Product or System and the ValidityOffset in this Tier
  """
  expiryDate: Datetime

  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String
  createdAt: Datetime
  updatedAt: Datetime
  accountToRequestorAccountId: GuaranteeRequestorAccountIdFkeyInput
  projectToProjectId: GuaranteeProjectIdFkeyInput
  systemToSystemBmiRef: GuaranteeSystemBmiRefFkeyInput
  productToProductBmiRef: GuaranteeProductBmiRefFkeyInput
  accountToReviewerAccountId: GuaranteeReviewerAccountIdFkeyInput
  evidenceItemsUsingId: EvidenceItemGuaranteeIdFkeyInverseInput
  guaranteeTypeCoverage: ContentfulGuaranteeCoverageType
}

"""
The fields on `system` to look up the row to update.
"""
input SystemOnSystemForSystemMarketIdFkeyUsingSystemBmiRefKeyUpdate {
  """
  An object where the defined keys will be set on the `system` being updated.
  """
  patch: updateSystemOnSystemForSystemMarketIdFkeyPatch!

  """
  A unique reference for the system known to BMI
  """
  bmiRef: String!
}

"""
The globally unique `ID` look up for the row to update.
"""
input MarketOnSystemForSystemMarketIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `system` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `system` being updated.
  """
  patch: SystemPatch!
}

"""
The `system` to be created by this mutation.
"""
input SystemMarketIdFkeySystemCreateInput {
  """
  Primary key
  """
  id: Int

  """
  ek
  """
  technology: Technology

  """
  A unique reference for the system known to BMI
  """
  bmiRef: String!

  """
  Short name for the System
  """
  name: String!

  """
  A description for the System
  """
  description: String

  """
  The maximum number of years that this system can be guaranteed for.  Must be greater than 10.
  """
  maximumValidityYears: Int!

  """
  If true this system is available for users to select when applying for a system or solution guarantee
  """
  published: Boolean!
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: SystemMarketIdFkeyInput
  guaranteesUsingBmiRef: GuaranteeSystemBmiRefFkeyInverseInput
  systemMembersUsingBmiRef: SystemMemberSystemBmiRefFkeyInverseInput
}

"""
The fields on `market` to look up the row to update.
"""
input MarketOnProductForProductMarketIdFkeyUsingMarketDomainKeyUpdate {
  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: updateMarketOnProductForProductMarketIdFkeyPatch!

  """
  the country code used for example as the subdomain
  """
  domain: String!
}

"""
The fields on `market` to look up the row to update.
"""
input MarketOnProductForProductMarketIdFkeyUsingMarketDoceboCatalogueIdKeyUpdate {
  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: updateMarketOnProductForProductMarketIdFkeyPatch!

  """
  The default catalogue for the market.  All users in the market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int!
}

"""
The globally unique `ID` look up for the row to update.
"""
input ProductOnProductForProductMarketIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `market` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: MarketPatch!
}

"""
The `market` to be created by this mutation.
"""
input ProductMarketIdFkeyMarketCreateInput {
  """
  Primary key
  """
  id: Int

  """
  ek
  """
  language: Language

  """
  the country code used for example as the subdomain
  """
  domain: String!

  """
  The space in Contenful
  """
  cmsSpaceId: String

  """
  A short name for the market, e.g. Italy, Norway, Netherlands
  """
  name: String

  """
  The From name used when sending an email
  """
  sendName: String

  """
  The mailbox on intouch.bmigroup.com that emails will be sent from for this Market
  """
  sendMailbox: String

  """
  The default branch in Docebo that installers go into
  """
  doceboInstallersBranchId: String

  """
  The branch in Docebo that company admins go into
  """
  doceboCompanyAdminBranchId: String

  """
  The default catalogue for the market.  All users in the market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int

  """
  The address of the merchandising site for the market.  CTAs of the MERCHANDISING type will link to this address
  """
  merchandisingUrl: String

  """
  Whether the market supports Projects.  If so then the Projects link should be available in th left hand navigation.
  """
  projectsEnabled: Boolean

  """
  Reference to the Google Analytics tracking ID that is used for the Country GA reports
  """
  gtag: String

  """
  The coordinates of the middle of the Market on a map
  """
  geoMiddle: PointInput

  """
  The length of the radius in km (from the geo_middle lat/lng), for which the Google Places API biases the search results for address autocomplete. Locations outside of the radius will not be excluded.
  """
  locationBiasRadiusKm: Int
  createdAt: Datetime
  updatedAt: Datetime
  accountsUsingId: AccountMarketIdFkeyInverseInput
  companiesUsingId: CompanyMarketIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberMarketIdFkeyInverseInput
  productsUsingId: ProductMarketIdFkeyInverseInput
  systemsUsingId: SystemMarketIdFkeyInverseInput
  systemMembersUsingId: SystemMemberMarketIdFkeyInverseInput
}

"""
The fields on `product` to look up the row to update.
"""
input ProductOnProductForProductMarketIdFkeyUsingProductBmiRefKeyUpdate {
  """
  An object where the defined keys will be set on the `product` being updated.
  """
  patch: updateProductOnProductForProductMarketIdFkeyPatch!

  """
  A unique reference for the product known to BMI
  """
  bmiRef: String!
}

"""
The globally unique `ID` look up for the row to update.
"""
input MarketOnProductForProductMarketIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `product` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `product` being updated.
  """
  patch: ProductPatch!
}

"""
The `product` to be created by this mutation.
"""
input ProductMarketIdFkeyProductCreateInput {
  """
  Primary key
  """
  id: Int

  """
  ek
  """
  technology: Technology

  """
  A unique reference for the product known to BMI
  """
  bmiRef: String!

  """
  The Products brand
  """
  brand: String!

  """
  Short name for the Product
  """
  name: String!

  """
  A description of the Product
  """
  description: String

  """
  The family of Products this Product is in
  """
  family: String!

  """
  Whether the Product is avialable for new guarantees
  """
  published: Boolean!

  """
  The number of years that this product can be guaranteed for
  """
  maximumValidityYears: Int!
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: ProductMarketIdFkeyInput
  guaranteesUsingBmiRef: GuaranteeProductBmiRefFkeyInverseInput
  systemMembersUsingBmiRef: SystemMemberProductBmiRefFkeyInverseInput
}

"""
The fields on `market` to look up the row to update.
"""
input MarketOnSystemForSystemMarketIdFkeyUsingMarketDomainKeyUpdate {
  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: updateMarketOnSystemForSystemMarketIdFkeyPatch!

  """
  the country code used for example as the subdomain
  """
  domain: String!
}

"""
The fields on `market` to look up the row to update.
"""
input MarketOnSystemForSystemMarketIdFkeyUsingMarketDoceboCatalogueIdKeyUpdate {
  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: updateMarketOnSystemForSystemMarketIdFkeyPatch!

  """
  The default catalogue for the market.  All users in the market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int!
}

"""
The globally unique `ID` look up for the row to update.
"""
input SystemOnSystemForSystemMarketIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `market` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: MarketPatch!
}

"""
The `market` to be created by this mutation.
"""
input SystemMarketIdFkeyMarketCreateInput {
  """
  Primary key
  """
  id: Int

  """
  ek
  """
  language: Language

  """
  the country code used for example as the subdomain
  """
  domain: String!

  """
  The space in Contenful
  """
  cmsSpaceId: String

  """
  A short name for the market, e.g. Italy, Norway, Netherlands
  """
  name: String

  """
  The From name used when sending an email
  """
  sendName: String

  """
  The mailbox on intouch.bmigroup.com that emails will be sent from for this Market
  """
  sendMailbox: String

  """
  The default branch in Docebo that installers go into
  """
  doceboInstallersBranchId: String

  """
  The branch in Docebo that company admins go into
  """
  doceboCompanyAdminBranchId: String

  """
  The default catalogue for the market.  All users in the market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int

  """
  The address of the merchandising site for the market.  CTAs of the MERCHANDISING type will link to this address
  """
  merchandisingUrl: String

  """
  Whether the market supports Projects.  If so then the Projects link should be available in th left hand navigation.
  """
  projectsEnabled: Boolean

  """
  Reference to the Google Analytics tracking ID that is used for the Country GA reports
  """
  gtag: String

  """
  The coordinates of the middle of the Market on a map
  """
  geoMiddle: PointInput

  """
  The length of the radius in km (from the geo_middle lat/lng), for which the Google Places API biases the search results for address autocomplete. Locations outside of the radius will not be excluded.
  """
  locationBiasRadiusKm: Int
  createdAt: Datetime
  updatedAt: Datetime
  accountsUsingId: AccountMarketIdFkeyInverseInput
  companiesUsingId: CompanyMarketIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberMarketIdFkeyInverseInput
  productsUsingId: ProductMarketIdFkeyInverseInput
  systemsUsingId: SystemMarketIdFkeyInverseInput
  systemMembersUsingId: SystemMemberMarketIdFkeyInverseInput
}

"""
The fields on `system` to look up the row to update.
"""
input SystemOnGuaranteeForGuaranteeSystemBmiRefFkeyUsingSystemBmiRefKeyUpdate {
  """
  An object where the defined keys will be set on the `system` being updated.
  """
  patch: updateSystemOnGuaranteeForGuaranteeSystemBmiRefFkeyPatch!

  """
  A unique reference for the system known to BMI
  """
  bmiRef: String!
}

"""
The globally unique `ID` look up for the row to update.
"""
input GuaranteeOnGuaranteeForGuaranteeSystemBmiRefFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `system` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `system` being updated.
  """
  patch: SystemPatch!
}

"""
The `system` to be created by this mutation.
"""
input GuaranteeSystemBmiRefFkeySystemCreateInput {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int

  """
  ek
  """
  technology: Technology

  """
  A unique reference for the system known to BMI
  """
  bmiRef: String!

  """
  Short name for the System
  """
  name: String!

  """
  A description for the System
  """
  description: String

  """
  The maximum number of years that this system can be guaranteed for.  Must be greater than 10.
  """
  maximumValidityYears: Int!

  """
  If true this system is available for users to select when applying for a system or solution guarantee
  """
  published: Boolean!
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: SystemMarketIdFkeyInput
  guaranteesUsingBmiRef: GuaranteeSystemBmiRefFkeyInverseInput
  systemMembersUsingBmiRef: SystemMemberSystemBmiRefFkeyInverseInput
}

"""
The fields on `guarantee` to look up the row to update.
"""
input GuaranteeOnGuaranteeForGuaranteeProjectIdFkeyUsingGuaranteeBmiReferenceIdKeyUpdate {
  """
  An object where the defined keys will be set on the `guarantee` being updated.
  """
  patch: updateGuaranteeOnGuaranteeForGuaranteeProjectIdFkeyPatch!

  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String!
}

"""
The globally unique `ID` look up for the row to update.
"""
input ProjectOnGuaranteeForGuaranteeProjectIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `guarantee` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `guarantee` being updated.
  """
  patch: GuaranteePatch!
}

"""
The `guarantee` to be created by this mutation.
"""
input GuaranteeProjectIdFkeyGuaranteeCreateInput {
  """
  Primary key - starts at 6100
  """
  id: Int

  """
  The pdf file that is emailed out, or a reference to it, or reference to the service that will generate it on demand
  """
  fileStorageId: String

  """
  fk
  """
  requestorAccountId: Int

  """
  a reference to the guaranteeType sys id in Contentful
  """
  guaranteeTypeId: String!

  """
  fk
  """
  systemBmiRef: String

  """
  fk
  """
  productBmiRef: String

  """
  fk
  """
  reviewerAccountId: Int

  """
  a reference to the guaranteeType sys id in Contentful
  """
  guaranteeTemplateId: String

  """
  ek
  """
  status: RequestStatus

  """
  The date that the Guarantee is approved either automatically or manually
  """
  startDate: Datetime

  """
  When the guarantee will expire.  This should be calculated when the request_status becomes APPROVED. dependent on the StartDate, the Validity of the Product or System and the ValidityOffset in this Tier
  """
  expiryDate: Datetime

  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String
  createdAt: Datetime
  updatedAt: Datetime
  accountToRequestorAccountId: GuaranteeRequestorAccountIdFkeyInput
  projectToProjectId: GuaranteeProjectIdFkeyInput
  systemToSystemBmiRef: GuaranteeSystemBmiRefFkeyInput
  productToProductBmiRef: GuaranteeProductBmiRefFkeyInput
  accountToReviewerAccountId: GuaranteeReviewerAccountIdFkeyInput
  evidenceItemsUsingId: EvidenceItemGuaranteeIdFkeyInverseInput
  guaranteeTypeCoverage: ContentfulGuaranteeCoverageType
}

"""
The globally unique `ID` look up for the row to update.
"""
input EvidenceItemOnEvidenceItemForEvidenceItemProjectIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `project` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `project` being updated.
  """
  patch: ProjectPatch!
}

"""
The `project` to be created by this mutation.
"""
input EvidenceItemProjectIdFkeyProjectCreateInput {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  companyId: Int

  """
  fk
  """
  siteAddressId: Int

  """
  fk
  """
  buildingOwnerAddressId: Int

  """
  ek
  """
  technology: Technology

  """
  Short name for the Project
  """
  name: String!

  """
  Short description of what the Project is about.  Sometimes useful to clarify some points to BMI
  """
  description: String

  """
  If this is true then the Project should be hidden from End Users
  """
  hidden: Boolean

  """
  The number of square meters of roof that this project covers
  """
  roofArea: Int!

  """
  Email address of the person who owns the building that the roof is going on.  Not mandatory for a Project, but mandatory when the Company applies for a Guarantee related to the project.
  """
  buildingOwnerMail: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerFirstname: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerLastname: String

  """
  Name of the Building Owner company if there is such a thing.  Not the same as an InTouch Company.
  """
  buildingOwnerCompany: String

  """
  The date that the Project officially starts or started
  """
  startDate: Datetime!

  """
  The date that the Project officially expects to end or ended
  """
  endDate: Datetime!
  createdAt: Datetime
  updatedAt: Datetime
  companyToCompanyId: ProjectCompanyIdFkeyInput
  addressToSiteAddressId: ProjectSiteAddressIdFkeyInput
  addressToBuildingOwnerAddressId: ProjectBuildingOwnerAddressIdFkeyInput
  evidenceItemsUsingId: EvidenceItemProjectIdFkeyInverseInput
  guaranteesUsingId: GuaranteeProjectIdFkeyInverseInput
  notesUsingId: NoteProjectIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberProjectIdFkeyInverseInput
}

"""
The globally unique `ID` look up for the row to update.
"""
input ProjectOnEvidenceItemForEvidenceItemProjectIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `evidenceItem` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `evidenceItem` being updated.
  """
  patch: EvidenceItemPatch!
}

"""
The `evidenceItem` to be created by this mutation.
"""
input EvidenceItemProjectIdFkeyEvidenceItemCreateInput {
  """
  Primary key
  """
  id: Int

  """
  a reference to the evidenceCategory sys id in Contentful
  """
  customEvidenceCategoryId: String

  """
  fk
  """
  guaranteeId: Int

  """
  ek
  """
  evidenceCategoryType: EvidenceCategoryType

  """
  Short name for the item of evidence
  """
  name: String!

  """
  File reference or the file itself. Photo of the evidence
  """
  attachment: String!
  createdAt: Datetime
  updatedAt: Datetime
  projectToProjectId: EvidenceItemProjectIdFkeyInput
  guaranteeToGuaranteeId: EvidenceItemGuaranteeIdFkeyInput
  attachmentUpload: Upload
}

"""
The globally unique `ID` look up for the row to update.
"""
input AddressOnProjectForProjectBuildingOwnerAddressIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `project` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `project` being updated.
  """
  patch: ProjectPatch!
}

"""
The `project` to be created by this mutation.
"""
input ProjectBuildingOwnerAddressIdFkeyProjectCreateInput {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  companyId: Int

  """
  fk
  """
  siteAddressId: Int

  """
  ek
  """
  technology: Technology

  """
  Short name for the Project
  """
  name: String!

  """
  Short description of what the Project is about.  Sometimes useful to clarify some points to BMI
  """
  description: String

  """
  If this is true then the Project should be hidden from End Users
  """
  hidden: Boolean

  """
  The number of square meters of roof that this project covers
  """
  roofArea: Int!

  """
  Email address of the person who owns the building that the roof is going on.  Not mandatory for a Project, but mandatory when the Company applies for a Guarantee related to the project.
  """
  buildingOwnerMail: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerFirstname: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerLastname: String

  """
  Name of the Building Owner company if there is such a thing.  Not the same as an InTouch Company.
  """
  buildingOwnerCompany: String

  """
  The date that the Project officially starts or started
  """
  startDate: Datetime!

  """
  The date that the Project officially expects to end or ended
  """
  endDate: Datetime!
  createdAt: Datetime
  updatedAt: Datetime
  companyToCompanyId: ProjectCompanyIdFkeyInput
  addressToSiteAddressId: ProjectSiteAddressIdFkeyInput
  addressToBuildingOwnerAddressId: ProjectBuildingOwnerAddressIdFkeyInput
  evidenceItemsUsingId: EvidenceItemProjectIdFkeyInverseInput
  guaranteesUsingId: GuaranteeProjectIdFkeyInverseInput
  notesUsingId: NoteProjectIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberProjectIdFkeyInverseInput
}

"""
The globally unique `ID` look up for the row to update.
"""
input ProjectOnProjectForProjectSiteAddressIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `address` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `address` being updated.
  """
  patch: AddressPatch!
}

"""
The `address` to be created by this mutation.
"""
input ProjectSiteAddressIdFkeyAddressCreateInput {
  """
  Primary key
  """
  id: Int

  """
  First line of this address
  """
  firstLine: String!

  """
  Second line of this address
  """
  secondLine: String

  """
  The postal town
  """
  town: String

  """
  The region if relevant
  """
  region: String

  """
  The country for this address
  """
  country: String

  """
  The postcode for this address
  """
  postcode: String!

  """
  The coordinates on a map of the world
  """
  coordinates: PointInput

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String
  createdAt: Datetime
  updatedAt: Datetime
  companiesToRegisteredAddressIdUsingId: CompanyRegisteredAddressIdFkeyInverseInput
  companiesToTradingAddressIdUsingId: CompanyTradingAddressIdFkeyInverseInput
  projectsToSiteAddressIdUsingId: ProjectSiteAddressIdFkeyInverseInput
  projectsToBuildingOwnerAddressIdUsingId: ProjectBuildingOwnerAddressIdFkeyInverseInput
}

"""
The globally unique `ID` look up for the row to update.
"""
input GuaranteeOnGuaranteeForGuaranteeProjectIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `project` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `project` being updated.
  """
  patch: ProjectPatch!
}

"""
The `project` to be created by this mutation.
"""
input GuaranteeProjectIdFkeyProjectCreateInput {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  companyId: Int

  """
  fk
  """
  siteAddressId: Int

  """
  fk
  """
  buildingOwnerAddressId: Int

  """
  ek
  """
  technology: Technology

  """
  Short name for the Project
  """
  name: String!

  """
  Short description of what the Project is about.  Sometimes useful to clarify some points to BMI
  """
  description: String

  """
  If this is true then the Project should be hidden from End Users
  """
  hidden: Boolean

  """
  The number of square meters of roof that this project covers
  """
  roofArea: Int!

  """
  Email address of the person who owns the building that the roof is going on.  Not mandatory for a Project, but mandatory when the Company applies for a Guarantee related to the project.
  """
  buildingOwnerMail: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerFirstname: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerLastname: String

  """
  Name of the Building Owner company if there is such a thing.  Not the same as an InTouch Company.
  """
  buildingOwnerCompany: String

  """
  The date that the Project officially starts or started
  """
  startDate: Datetime!

  """
  The date that the Project officially expects to end or ended
  """
  endDate: Datetime!
  createdAt: Datetime
  updatedAt: Datetime
  companyToCompanyId: ProjectCompanyIdFkeyInput
  addressToSiteAddressId: ProjectSiteAddressIdFkeyInput
  addressToBuildingOwnerAddressId: ProjectBuildingOwnerAddressIdFkeyInput
  evidenceItemsUsingId: EvidenceItemProjectIdFkeyInverseInput
  guaranteesUsingId: GuaranteeProjectIdFkeyInverseInput
  notesUsingId: NoteProjectIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberProjectIdFkeyInverseInput
}

"""
The fields on `guarantee` to look up the row to update.
"""
input GuaranteeOnGuaranteeForGuaranteeReviewerAccountIdFkeyUsingGuaranteeBmiReferenceIdKeyUpdate {
  """
  An object where the defined keys will be set on the `guarantee` being updated.
  """
  patch: updateGuaranteeOnGuaranteeForGuaranteeReviewerAccountIdFkeyPatch!

  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String!
}

"""
The globally unique `ID` look up for the row to update.
"""
input AccountOnGuaranteeForGuaranteeReviewerAccountIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `guarantee` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `guarantee` being updated.
  """
  patch: GuaranteePatch!
}

"""
The `guarantee` to be created by this mutation.
"""
input GuaranteeReviewerAccountIdFkeyGuaranteeCreateInput {
  """
  Primary key - starts at 6100
  """
  id: Int

  """
  The pdf file that is emailed out, or a reference to it, or reference to the service that will generate it on demand
  """
  fileStorageId: String

  """
  fk
  """
  requestorAccountId: Int

  """
  fk
  """
  projectId: Int

  """
  a reference to the guaranteeType sys id in Contentful
  """
  guaranteeTypeId: String!

  """
  fk
  """
  systemBmiRef: String

  """
  fk
  """
  productBmiRef: String

  """
  a reference to the guaranteeType sys id in Contentful
  """
  guaranteeTemplateId: String

  """
  ek
  """
  status: RequestStatus

  """
  The date that the Guarantee is approved either automatically or manually
  """
  startDate: Datetime

  """
  When the guarantee will expire.  This should be calculated when the request_status becomes APPROVED. dependent on the StartDate, the Validity of the Product or System and the ValidityOffset in this Tier
  """
  expiryDate: Datetime

  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String
  createdAt: Datetime
  updatedAt: Datetime
  accountToRequestorAccountId: GuaranteeRequestorAccountIdFkeyInput
  projectToProjectId: GuaranteeProjectIdFkeyInput
  systemToSystemBmiRef: GuaranteeSystemBmiRefFkeyInput
  productToProductBmiRef: GuaranteeProductBmiRefFkeyInput
  accountToReviewerAccountId: GuaranteeReviewerAccountIdFkeyInput
  evidenceItemsUsingId: EvidenceItemGuaranteeIdFkeyInverseInput
  guaranteeTypeCoverage: ContentfulGuaranteeCoverageType
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnGuaranteeForGuaranteeRequestorAccountIdFkeyUsingAccountEmailKeyUpdate {
  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnGuaranteeForGuaranteeRequestorAccountIdFkeyPatch!

  """
  The email address associated with the account
  """
  email: String!
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnGuaranteeForGuaranteeRequestorAccountIdFkeyUsingAccountDoceboUserIdKeyUpdate {
  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnGuaranteeForGuaranteeRequestorAccountIdFkeyPatch!

  """
  User account in Docebo
  """
  doceboUserId: Int!
}

"""
The globally unique `ID` look up for the row to update.
"""
input GuaranteeOnGuaranteeForGuaranteeRequestorAccountIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `account` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: AccountPatch!
}

"""
The fields on `guarantee` to look up the row to update.
"""
input GuaranteeOnGuaranteeForGuaranteeRequestorAccountIdFkeyUsingGuaranteeBmiReferenceIdKeyUpdate {
  """
  An object where the defined keys will be set on the `guarantee` being updated.
  """
  patch: updateGuaranteeOnGuaranteeForGuaranteeRequestorAccountIdFkeyPatch!

  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String!
}

"""
The globally unique `ID` look up for the row to update.
"""
input AccountOnGuaranteeForGuaranteeRequestorAccountIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `guarantee` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `guarantee` being updated.
  """
  patch: GuaranteePatch!
}

"""
The `guarantee` to be created by this mutation.
"""
input GuaranteeRequestorAccountIdFkeyGuaranteeCreateInput {
  """
  Primary key - starts at 6100
  """
  id: Int

  """
  The pdf file that is emailed out, or a reference to it, or reference to the service that will generate it on demand
  """
  fileStorageId: String

  """
  fk
  """
  projectId: Int

  """
  a reference to the guaranteeType sys id in Contentful
  """
  guaranteeTypeId: String!

  """
  fk
  """
  systemBmiRef: String

  """
  fk
  """
  productBmiRef: String

  """
  fk
  """
  reviewerAccountId: Int

  """
  a reference to the guaranteeType sys id in Contentful
  """
  guaranteeTemplateId: String

  """
  ek
  """
  status: RequestStatus

  """
  The date that the Guarantee is approved either automatically or manually
  """
  startDate: Datetime

  """
  When the guarantee will expire.  This should be calculated when the request_status becomes APPROVED. dependent on the StartDate, the Validity of the Product or System and the ValidityOffset in this Tier
  """
  expiryDate: Datetime

  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String
  createdAt: Datetime
  updatedAt: Datetime
  accountToRequestorAccountId: GuaranteeRequestorAccountIdFkeyInput
  projectToProjectId: GuaranteeProjectIdFkeyInput
  systemToSystemBmiRef: GuaranteeSystemBmiRefFkeyInput
  productToProductBmiRef: GuaranteeProductBmiRefFkeyInput
  accountToReviewerAccountId: GuaranteeReviewerAccountIdFkeyInput
  evidenceItemsUsingId: EvidenceItemGuaranteeIdFkeyInverseInput
  guaranteeTypeCoverage: ContentfulGuaranteeCoverageType
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnInvitationForInvitationSenderAccountIdFkeyUsingAccountEmailKeyUpdate {
  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnInvitationForInvitationSenderAccountIdFkeyPatch!

  """
  The email address associated with the account
  """
  email: String!
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnInvitationForInvitationSenderAccountIdFkeyUsingAccountDoceboUserIdKeyUpdate {
  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnInvitationForInvitationSenderAccountIdFkeyPatch!

  """
  User account in Docebo
  """
  doceboUserId: Int!
}

"""
The globally unique `ID` look up for the row to update.
"""
input InvitationOnInvitationForInvitationSenderAccountIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `account` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: AccountPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input CompanyOnInvitationForInvitationCompanyIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `invitation` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `invitation` being updated.
  """
  patch: InvitationPatch!
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnCompanyOperationForCompanyOperationCompanyFkeyUsingCompanyNameKeyUpdate {
  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnCompanyOperationForCompanyOperationCompanyFkeyPatch!

  """
  The registered name of the Company
  """
  name: String!
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnCompanyOperationForCompanyOperationCompanyFkeyUsingCompanyReferenceNumberKeyUpdate {
  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnCompanyOperationForCompanyOperationCompanyFkeyPatch!

  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: String!
}

"""
The globally unique `ID` look up for the row to update.
"""
input CompanyOperationOnCompanyOperationForCompanyOperationCompanyFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `company` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: CompanyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input CompanyOnCompanyOperationForCompanyOperationCompanyFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `companyOperation` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `companyOperation` being updated.
  """
  patch: CompanyOperationPatch!
}

"""
Represents an update to a `CompanyOperation`. Fields that are set will be updated.
"""
input CompanyOperationPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  company: Int

  """
  ek
  """
  operation: Operation
  createdAt: Datetime
  updatedAt: Datetime
  companyToCompany: CompanyOperationCompanyFkeyInput
}

"""
The `companyOperation` to be created by this mutation.
"""
input CompanyOperationCompanyFkeyCompanyOperationCreateInput {
  """
  Primary key
  """
  id: Int

  """
  ek
  """
  operation: Operation
  createdAt: Datetime
  updatedAt: Datetime
  companyToCompany: CompanyOperationCompanyFkeyInput
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnCompanyMemberForCompanyMemberCompanyIdFkeyUsingCompanyNameKeyUpdate {
  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnCompanyMemberForCompanyMemberCompanyIdFkeyPatch!

  """
  The registered name of the Company
  """
  name: String!
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnCompanyMemberForCompanyMemberCompanyIdFkeyUsingCompanyReferenceNumberKeyUpdate {
  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnCompanyMemberForCompanyMemberCompanyIdFkeyPatch!

  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: String!
}

"""
The globally unique `ID` look up for the row to update.
"""
input CompanyMemberOnCompanyMemberForCompanyMemberCompanyIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `company` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: CompanyPatch!
}

"""
The fields on `companyMember` to look up the row to update.
"""
input CompanyMemberOnCompanyMemberForCompanyMemberAccountIdFkeyUsingCompanyMemberMarketIdAccountIdCompanyIdKeyUpdate {
  """
  An object where the defined keys will be set on the `companyMember` being updated.
  """
  patch: updateCompanyMemberOnCompanyMemberForCompanyMemberAccountIdFkeyPatch!

  """
  fk
  """
  marketId: Int!

  """
  fk
  """
  accountId: Int!

  """
  fk
  """
  companyId: Int!
}

"""
The globally unique `ID` look up for the row to update.
"""
input AccountOnCompanyMemberForCompanyMemberAccountIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `companyMember` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `companyMember` being updated.
  """
  patch: CompanyMemberPatch!
}

"""
Represents an update to a `CompanyMember`. Fields that are set will be updated.
"""
input CompanyMemberPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int

  """
  fk
  """
  accountId: Int

  """
  fk
  """
  companyId: Int
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: CompanyMemberMarketIdFkeyInput
  accountToAccountId: CompanyMemberAccountIdFkeyInput
  companyToCompanyId: CompanyMemberCompanyIdFkeyInput
}

"""
The `companyMember` to be created by this mutation.
"""
input CompanyMemberAccountIdFkeyCompanyMemberCreateInput {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int

  """
  fk
  """
  companyId: Int
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: CompanyMemberMarketIdFkeyInput
  accountToAccountId: CompanyMemberAccountIdFkeyInput
  companyToCompanyId: CompanyMemberCompanyIdFkeyInput
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnCertificationForCertificationDoceboUserIdFkeyUsingAccountEmailKeyUpdate {
  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnCertificationForCertificationDoceboUserIdFkeyPatch!

  """
  The email address associated with the account
  """
  email: String!
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnCertificationForCertificationDoceboUserIdFkeyUsingAccountDoceboUserIdKeyUpdate {
  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnCertificationForCertificationDoceboUserIdFkeyPatch!

  """
  User account in Docebo
  """
  doceboUserId: Int!
}

"""
The globally unique `ID` look up for the row to update.
"""
input CertificationOnCertificationForCertificationDoceboUserIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `account` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: AccountPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input AccountOnCertificationForCertificationDoceboUserIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `certification` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `certification` being updated.
  """
  patch: CertificationPatch!
}

"""
Represents an update to a `Certification`. Fields that are set will be updated.
"""
input CertificationPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  doceboUserId: Int

  """
  technology
  """
  technology: String

  """
  The name of the certification according to Docebo
  """
  name: String

  """
  The last day that this certification is valid
  """
  expiryDate: Datetime
  createdAt: Datetime
  updatedAt: Datetime
  accountToDoceboUserId: CertificationDoceboUserIdFkeyInput
}

"""
The `certification` to be created by this mutation.
"""
input CertificationDoceboUserIdFkeyCertificationCreateInput {
  """
  Primary key
  """
  id: Int

  """
  technology
  """
  technology: String

  """
  The name of the certification according to Docebo
  """
  name: String

  """
  The last day that this certification is valid
  """
  expiryDate: Datetime
  createdAt: Datetime
  updatedAt: Datetime
  accountToDoceboUserId: CertificationDoceboUserIdFkeyInput
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnCompanyMemberForCompanyMemberAccountIdFkeyUsingAccountEmailKeyUpdate {
  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnCompanyMemberForCompanyMemberAccountIdFkeyPatch!

  """
  The email address associated with the account
  """
  email: String!
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnCompanyMemberForCompanyMemberAccountIdFkeyUsingAccountDoceboUserIdKeyUpdate {
  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnCompanyMemberForCompanyMemberAccountIdFkeyPatch!

  """
  User account in Docebo
  """
  doceboUserId: Int!
}

"""
The globally unique `ID` look up for the row to update.
"""
input CompanyMemberOnCompanyMemberForCompanyMemberAccountIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `account` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: AccountPatch!
}

"""
The fields on `companyMember` to look up the row to update.
"""
input CompanyMemberOnCompanyMemberForCompanyMemberMarketIdFkeyUsingCompanyMemberMarketIdAccountIdCompanyIdKeyUpdate {
  """
  An object where the defined keys will be set on the `companyMember` being updated.
  """
  patch: updateCompanyMemberOnCompanyMemberForCompanyMemberMarketIdFkeyPatch!

  """
  fk
  """
  marketId: Int!

  """
  fk
  """
  accountId: Int!

  """
  fk
  """
  companyId: Int!
}

"""
The globally unique `ID` look up for the row to update.
"""
input MarketOnCompanyMemberForCompanyMemberMarketIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `companyMember` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `companyMember` being updated.
  """
  patch: CompanyMemberPatch!
}

"""
The `companyMember` to be created by this mutation.
"""
input CompanyMemberMarketIdFkeyCompanyMemberCreateInput {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  accountId: Int

  """
  fk
  """
  companyId: Int
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: CompanyMemberMarketIdFkeyInput
  accountToAccountId: CompanyMemberAccountIdFkeyInput
  companyToCompanyId: CompanyMemberCompanyIdFkeyInput
}

"""
The fields on `market` to look up the row to update.
"""
input MarketOnCompanyMemberForCompanyMemberMarketIdFkeyUsingMarketDomainKeyUpdate {
  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: updateMarketOnCompanyMemberForCompanyMemberMarketIdFkeyPatch!

  """
  the country code used for example as the subdomain
  """
  domain: String!
}

"""
The fields on `market` to look up the row to update.
"""
input MarketOnCompanyMemberForCompanyMemberMarketIdFkeyUsingMarketDoceboCatalogueIdKeyUpdate {
  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: updateMarketOnCompanyMemberForCompanyMemberMarketIdFkeyPatch!

  """
  The default catalogue for the market.  All users in the market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int!
}

"""
The globally unique `ID` look up for the row to update.
"""
input CompanyMemberOnCompanyMemberForCompanyMemberMarketIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `market` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: MarketPatch!
}

"""
The `market` to be created by this mutation.
"""
input CompanyMemberMarketIdFkeyMarketCreateInput {
  """
  Primary key
  """
  id: Int

  """
  ek
  """
  language: Language

  """
  the country code used for example as the subdomain
  """
  domain: String!

  """
  The space in Contenful
  """
  cmsSpaceId: String

  """
  A short name for the market, e.g. Italy, Norway, Netherlands
  """
  name: String

  """
  The From name used when sending an email
  """
  sendName: String

  """
  The mailbox on intouch.bmigroup.com that emails will be sent from for this Market
  """
  sendMailbox: String

  """
  The default branch in Docebo that installers go into
  """
  doceboInstallersBranchId: String

  """
  The branch in Docebo that company admins go into
  """
  doceboCompanyAdminBranchId: String

  """
  The default catalogue for the market.  All users in the market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int

  """
  The address of the merchandising site for the market.  CTAs of the MERCHANDISING type will link to this address
  """
  merchandisingUrl: String

  """
  Whether the market supports Projects.  If so then the Projects link should be available in th left hand navigation.
  """
  projectsEnabled: Boolean

  """
  Reference to the Google Analytics tracking ID that is used for the Country GA reports
  """
  gtag: String

  """
  The coordinates of the middle of the Market on a map
  """
  geoMiddle: PointInput

  """
  The length of the radius in km (from the geo_middle lat/lng), for which the Google Places API biases the search results for address autocomplete. Locations outside of the radius will not be excluded.
  """
  locationBiasRadiusKm: Int
  createdAt: Datetime
  updatedAt: Datetime
  accountsUsingId: AccountMarketIdFkeyInverseInput
  companiesUsingId: CompanyMarketIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberMarketIdFkeyInverseInput
  productsUsingId: ProductMarketIdFkeyInverseInput
  systemsUsingId: SystemMarketIdFkeyInverseInput
  systemMembersUsingId: SystemMemberMarketIdFkeyInverseInput
}

"""
The fields on `companyMember` to look up the row to update.
"""
input CompanyMemberOnCompanyMemberForCompanyMemberCompanyIdFkeyUsingCompanyMemberMarketIdAccountIdCompanyIdKeyUpdate {
  """
  An object where the defined keys will be set on the `companyMember` being updated.
  """
  patch: updateCompanyMemberOnCompanyMemberForCompanyMemberCompanyIdFkeyPatch!

  """
  fk
  """
  marketId: Int!

  """
  fk
  """
  accountId: Int!

  """
  fk
  """
  companyId: Int!
}

"""
The globally unique `ID` look up for the row to update.
"""
input CompanyOnCompanyMemberForCompanyMemberCompanyIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `companyMember` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `companyMember` being updated.
  """
  patch: CompanyMemberPatch!
}

"""
The `companyMember` to be created by this mutation.
"""
input CompanyMemberCompanyIdFkeyCompanyMemberCreateInput {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int

  """
  fk
  """
  accountId: Int
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: CompanyMemberMarketIdFkeyInput
  accountToAccountId: CompanyMemberAccountIdFkeyInput
  companyToCompanyId: CompanyMemberCompanyIdFkeyInput
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnCompanyDocumentForCompanyDocumentCompanyIdFkeyUsingCompanyNameKeyUpdate {
  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnCompanyDocumentForCompanyDocumentCompanyIdFkeyPatch!

  """
  The registered name of the Company
  """
  name: String!
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnCompanyDocumentForCompanyDocumentCompanyIdFkeyUsingCompanyReferenceNumberKeyUpdate {
  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnCompanyDocumentForCompanyDocumentCompanyIdFkeyPatch!

  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: String!
}

"""
The globally unique `ID` look up for the row to update.
"""
input CompanyDocumentOnCompanyDocumentForCompanyDocumentCompanyIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `company` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: CompanyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input CompanyOnCompanyDocumentForCompanyDocumentCompanyIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `companyDocument` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `companyDocument` being updated.
  """
  patch: CompanyDocumentPatch!
}

"""
Represents an update to a `CompanyDocument`. Fields that are set will be updated.
"""
input CompanyDocumentPatch {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  companyId: Int

  """
  The reference to the document
  """
  document: String
  createdAt: Datetime
  updatedAt: Datetime
  companyToCompanyId: CompanyDocumentCompanyIdFkeyInput
}

"""
The `companyDocument` to be created by this mutation.
"""
input CompanyDocumentCompanyIdFkeyCompanyDocumentCreateInput {
  """
  Primary key
  """
  id: Int

  """
  The reference to the document
  """
  document: String
  createdAt: Datetime
  updatedAt: Datetime
  companyToCompanyId: CompanyDocumentCompanyIdFkeyInput
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnProjectForProjectCompanyIdFkeyUsingCompanyNameKeyUpdate {
  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnProjectForProjectCompanyIdFkeyPatch!

  """
  The registered name of the Company
  """
  name: String!
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnProjectForProjectCompanyIdFkeyUsingCompanyReferenceNumberKeyUpdate {
  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnProjectForProjectCompanyIdFkeyPatch!

  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: String!
}

"""
The globally unique `ID` look up for the row to update.
"""
input ProjectOnProjectForProjectCompanyIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `company` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: CompanyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input AddressOnProjectForProjectSiteAddressIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `project` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `project` being updated.
  """
  patch: ProjectPatch!
}

"""
The `project` to be created by this mutation.
"""
input ProjectSiteAddressIdFkeyProjectCreateInput {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  companyId: Int

  """
  fk
  """
  buildingOwnerAddressId: Int

  """
  ek
  """
  technology: Technology

  """
  Short name for the Project
  """
  name: String!

  """
  Short description of what the Project is about.  Sometimes useful to clarify some points to BMI
  """
  description: String

  """
  If this is true then the Project should be hidden from End Users
  """
  hidden: Boolean

  """
  The number of square meters of roof that this project covers
  """
  roofArea: Int!

  """
  Email address of the person who owns the building that the roof is going on.  Not mandatory for a Project, but mandatory when the Company applies for a Guarantee related to the project.
  """
  buildingOwnerMail: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerFirstname: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerLastname: String

  """
  Name of the Building Owner company if there is such a thing.  Not the same as an InTouch Company.
  """
  buildingOwnerCompany: String

  """
  The date that the Project officially starts or started
  """
  startDate: Datetime!

  """
  The date that the Project officially expects to end or ended
  """
  endDate: Datetime!
  createdAt: Datetime
  updatedAt: Datetime
  companyToCompanyId: ProjectCompanyIdFkeyInput
  addressToSiteAddressId: ProjectSiteAddressIdFkeyInput
  addressToBuildingOwnerAddressId: ProjectBuildingOwnerAddressIdFkeyInput
  evidenceItemsUsingId: EvidenceItemProjectIdFkeyInverseInput
  guaranteesUsingId: GuaranteeProjectIdFkeyInverseInput
  notesUsingId: NoteProjectIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberProjectIdFkeyInverseInput
}

"""
The globally unique `ID` look up for the row to update.
"""
input CompanyOnCompanyForCompanyTradingAddressIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `address` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `address` being updated.
  """
  patch: AddressPatch!
}

"""
The `address` to be created by this mutation.
"""
input CompanyTradingAddressIdFkeyAddressCreateInput {
  """
  Primary key
  """
  id: Int

  """
  First line of this address
  """
  firstLine: String!

  """
  Second line of this address
  """
  secondLine: String

  """
  The postal town
  """
  town: String

  """
  The region if relevant
  """
  region: String

  """
  The country for this address
  """
  country: String

  """
  The postcode for this address
  """
  postcode: String!

  """
  The coordinates on a map of the world
  """
  coordinates: PointInput

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String
  createdAt: Datetime
  updatedAt: Datetime
  companiesToRegisteredAddressIdUsingId: CompanyRegisteredAddressIdFkeyInverseInput
  companiesToTradingAddressIdUsingId: CompanyTradingAddressIdFkeyInverseInput
  projectsToSiteAddressIdUsingId: ProjectSiteAddressIdFkeyInverseInput
  projectsToBuildingOwnerAddressIdUsingId: ProjectBuildingOwnerAddressIdFkeyInverseInput
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnCompanyForCompanyTradingAddressIdFkeyUsingCompanyNameKeyUpdate {
  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnCompanyForCompanyTradingAddressIdFkeyPatch!

  """
  The registered name of the Company
  """
  name: String!
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnCompanyForCompanyTradingAddressIdFkeyUsingCompanyReferenceNumberKeyUpdate {
  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnCompanyForCompanyTradingAddressIdFkeyPatch!

  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: String!
}

"""
The globally unique `ID` look up for the row to update.
"""
input AddressOnCompanyForCompanyTradingAddressIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `company` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: CompanyPatch!
}

"""
The globally unique `ID` look up for the row to update.
"""
input CompanyOnCompanyForCompanyRegisteredAddressIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `address` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `address` being updated.
  """
  patch: AddressPatch!
}

"""
The `address` to be created by this mutation.
"""
input CompanyRegisteredAddressIdFkeyAddressCreateInput {
  """
  Primary key
  """
  id: Int

  """
  First line of this address
  """
  firstLine: String!

  """
  Second line of this address
  """
  secondLine: String

  """
  The postal town
  """
  town: String

  """
  The region if relevant
  """
  region: String

  """
  The country for this address
  """
  country: String

  """
  The postcode for this address
  """
  postcode: String!

  """
  The coordinates on a map of the world
  """
  coordinates: PointInput

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String
  createdAt: Datetime
  updatedAt: Datetime
  companiesToRegisteredAddressIdUsingId: CompanyRegisteredAddressIdFkeyInverseInput
  companiesToTradingAddressIdUsingId: CompanyTradingAddressIdFkeyInverseInput
  projectsToSiteAddressIdUsingId: ProjectSiteAddressIdFkeyInverseInput
  projectsToBuildingOwnerAddressIdUsingId: ProjectBuildingOwnerAddressIdFkeyInverseInput
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnCompanyForCompanyMarketIdFkeyUsingCompanyNameKeyUpdate {
  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnCompanyForCompanyMarketIdFkeyPatch!

  """
  The registered name of the Company
  """
  name: String!
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnCompanyForCompanyMarketIdFkeyUsingCompanyReferenceNumberKeyUpdate {
  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnCompanyForCompanyMarketIdFkeyPatch!

  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: String!
}

"""
The globally unique `ID` look up for the row to update.
"""
input MarketOnCompanyForCompanyMarketIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `company` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: CompanyPatch!
}

"""
The fields on `market` to look up the row to update.
"""
input MarketOnAccountForAccountMarketIdFkeyUsingMarketDomainKeyUpdate {
  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: updateMarketOnAccountForAccountMarketIdFkeyPatch!

  """
  the country code used for example as the subdomain
  """
  domain: String!
}

"""
The fields on `market` to look up the row to update.
"""
input MarketOnAccountForAccountMarketIdFkeyUsingMarketDoceboCatalogueIdKeyUpdate {
  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: updateMarketOnAccountForAccountMarketIdFkeyPatch!

  """
  The default catalogue for the market.  All users in the market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int!
}

"""
The globally unique `ID` look up for the row to update.
"""
input AccountOnAccountForAccountMarketIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `market` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: MarketPatch!
}

"""
The `market` to be created by this mutation.
"""
input AccountMarketIdFkeyMarketCreateInput {
  """
  Primary key
  """
  id: Int

  """
  ek
  """
  language: Language

  """
  the country code used for example as the subdomain
  """
  domain: String!

  """
  The space in Contenful
  """
  cmsSpaceId: String

  """
  A short name for the market, e.g. Italy, Norway, Netherlands
  """
  name: String

  """
  The From name used when sending an email
  """
  sendName: String

  """
  The mailbox on intouch.bmigroup.com that emails will be sent from for this Market
  """
  sendMailbox: String

  """
  The default branch in Docebo that installers go into
  """
  doceboInstallersBranchId: String

  """
  The branch in Docebo that company admins go into
  """
  doceboCompanyAdminBranchId: String

  """
  The default catalogue for the market.  All users in the market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int

  """
  The address of the merchandising site for the market.  CTAs of the MERCHANDISING type will link to this address
  """
  merchandisingUrl: String

  """
  Whether the market supports Projects.  If so then the Projects link should be available in th left hand navigation.
  """
  projectsEnabled: Boolean

  """
  Reference to the Google Analytics tracking ID that is used for the Country GA reports
  """
  gtag: String

  """
  The coordinates of the middle of the Market on a map
  """
  geoMiddle: PointInput

  """
  The length of the radius in km (from the geo_middle lat/lng), for which the Google Places API biases the search results for address autocomplete. Locations outside of the radius will not be excluded.
  """
  locationBiasRadiusKm: Int
  createdAt: Datetime
  updatedAt: Datetime
  accountsUsingId: AccountMarketIdFkeyInverseInput
  companiesUsingId: CompanyMarketIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberMarketIdFkeyInverseInput
  productsUsingId: ProductMarketIdFkeyInverseInput
  systemsUsingId: SystemMarketIdFkeyInverseInput
  systemMembersUsingId: SystemMemberMarketIdFkeyInverseInput
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnAccountForAccountMarketIdFkeyUsingAccountEmailKeyUpdate {
  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnAccountForAccountMarketIdFkeyPatch!

  """
  The email address associated with the account
  """
  email: String!
}

"""
The fields on `account` to look up the row to update.
"""
input AccountOnAccountForAccountMarketIdFkeyUsingAccountDoceboUserIdKeyUpdate {
  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnAccountForAccountMarketIdFkeyPatch!

  """
  User account in Docebo
  """
  doceboUserId: Int!
}

"""
The globally unique `ID` look up for the row to update.
"""
input MarketOnAccountForAccountMarketIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `account` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: AccountPatch!
}

"""
The fields on `market` to look up the row to update.
"""
input MarketOnCompanyForCompanyMarketIdFkeyUsingMarketDomainKeyUpdate {
  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: updateMarketOnCompanyForCompanyMarketIdFkeyPatch!

  """
  the country code used for example as the subdomain
  """
  domain: String!
}

"""
The fields on `market` to look up the row to update.
"""
input MarketOnCompanyForCompanyMarketIdFkeyUsingMarketDoceboCatalogueIdKeyUpdate {
  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: updateMarketOnCompanyForCompanyMarketIdFkeyPatch!

  """
  The default catalogue for the market.  All users in the market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int!
}

"""
The globally unique `ID` look up for the row to update.
"""
input CompanyOnCompanyForCompanyMarketIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `market` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `market` being updated.
  """
  patch: MarketPatch!
}

"""
The `market` to be created by this mutation.
"""
input CompanyMarketIdFkeyMarketCreateInput {
  """
  Primary key
  """
  id: Int

  """
  ek
  """
  language: Language

  """
  the country code used for example as the subdomain
  """
  domain: String!

  """
  The space in Contenful
  """
  cmsSpaceId: String

  """
  A short name for the market, e.g. Italy, Norway, Netherlands
  """
  name: String

  """
  The From name used when sending an email
  """
  sendName: String

  """
  The mailbox on intouch.bmigroup.com that emails will be sent from for this Market
  """
  sendMailbox: String

  """
  The default branch in Docebo that installers go into
  """
  doceboInstallersBranchId: String

  """
  The branch in Docebo that company admins go into
  """
  doceboCompanyAdminBranchId: String

  """
  The default catalogue for the market.  All users in the market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int

  """
  The address of the merchandising site for the market.  CTAs of the MERCHANDISING type will link to this address
  """
  merchandisingUrl: String

  """
  Whether the market supports Projects.  If so then the Projects link should be available in th left hand navigation.
  """
  projectsEnabled: Boolean

  """
  Reference to the Google Analytics tracking ID that is used for the Country GA reports
  """
  gtag: String

  """
  The coordinates of the middle of the Market on a map
  """
  geoMiddle: PointInput

  """
  The length of the radius in km (from the geo_middle lat/lng), for which the Google Places API biases the search results for address autocomplete. Locations outside of the radius will not be excluded.
  """
  locationBiasRadiusKm: Int
  createdAt: Datetime
  updatedAt: Datetime
  accountsUsingId: AccountMarketIdFkeyInverseInput
  companiesUsingId: CompanyMarketIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberMarketIdFkeyInverseInput
  productsUsingId: ProductMarketIdFkeyInverseInput
  systemsUsingId: SystemMarketIdFkeyInverseInput
  systemMembersUsingId: SystemMemberMarketIdFkeyInverseInput
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnCompanyForCompanyRegisteredAddressIdFkeyUsingCompanyNameKeyUpdate {
  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnCompanyForCompanyRegisteredAddressIdFkeyPatch!

  """
  The registered name of the Company
  """
  name: String!
}

"""
The fields on `company` to look up the row to update.
"""
input CompanyOnCompanyForCompanyRegisteredAddressIdFkeyUsingCompanyReferenceNumberKeyUpdate {
  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: updateCompanyOnCompanyForCompanyRegisteredAddressIdFkeyPatch!

  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: String!
}

"""
The globally unique `ID` look up for the row to update.
"""
input AddressOnCompanyForCompanyRegisteredAddressIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `company` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `company` being updated.
  """
  patch: CompanyPatch!
}

"""
The output of our create `Certification` mutation.
"""
type CreateCertificationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Certification` that was created by this mutation.
  """
  certification: Certification

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Account` that is related to this `Certification`.
  """
  doceboUser: Account

  """
  An edge for our `Certification`. May be used by Relay 1.
  """
  certificationEdge(
    """
    The method to use when ordering `Certification`.
    """
    orderBy: [CertificationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CertificationsEdge
}

"""
All input for the create `Certification` mutation.
"""
input CreateCertificationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `Certification` to be created by this mutation.
  """
  certification: CertificationInput!
}

"""
An input for mutations affecting `Certification`
"""
input CertificationInput {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  doceboUserId: Int

  """
  technology
  """
  technology: String

  """
  The name of the certification according to Docebo
  """
  name: String

  """
  The last day that this certification is valid
  """
  expiryDate: Datetime
  createdAt: Datetime
  updatedAt: Datetime
  accountToDoceboUserId: CertificationDoceboUserIdFkeyInput
}

"""
The output of our create `CompanyDocument` mutation.
"""
type CreateCompanyDocumentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `CompanyDocument` that was created by this mutation.
  """
  companyDocument: CompanyDocument

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Company` that is related to this `CompanyDocument`.
  """
  company: Company

  """
  An edge for our `CompanyDocument`. May be used by Relay 1.
  """
  companyDocumentEdge(
    """
    The method to use when ordering `CompanyDocument`.
    """
    orderBy: [CompanyDocumentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompanyDocumentsEdge
}

"""
All input for the create `CompanyDocument` mutation.
"""
input CreateCompanyDocumentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `CompanyDocument` to be created by this mutation.
  """
  companyDocument: CompanyDocumentInput!
}

"""
An input for mutations affecting `CompanyDocument`
"""
input CompanyDocumentInput {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  companyId: Int

  """
  The reference to the document
  """
  document: String
  createdAt: Datetime
  updatedAt: Datetime
  companyToCompanyId: CompanyDocumentCompanyIdFkeyInput
}

"""
The output of our create `CompanyMember` mutation.
"""
type CreateCompanyMemberPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `CompanyMember` that was created by this mutation.
  """
  companyMember: CompanyMember

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Market` that is related to this `CompanyMember`.
  """
  market: Market

  """
  Reads a single `Account` that is related to this `CompanyMember`.
  """
  account: Account

  """
  Reads a single `Company` that is related to this `CompanyMember`.
  """
  company: Company

  """
  An edge for our `CompanyMember`. May be used by Relay 1.
  """
  companyMemberEdge(
    """
    The method to use when ordering `CompanyMember`.
    """
    orderBy: [CompanyMembersOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompanyMembersEdge
}

"""
All input for the create `CompanyMember` mutation.
"""
input CreateCompanyMemberInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `CompanyMember` to be created by this mutation.
  """
  companyMember: CompanyMemberInput!
}

"""
An input for mutations affecting `CompanyMember`
"""
input CompanyMemberInput {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int

  """
  fk
  """
  accountId: Int

  """
  fk
  """
  companyId: Int
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: CompanyMemberMarketIdFkeyInput
  accountToAccountId: CompanyMemberAccountIdFkeyInput
  companyToCompanyId: CompanyMemberCompanyIdFkeyInput
}

"""
The output of our create `CompanyOperation` mutation.
"""
type CreateCompanyOperationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `CompanyOperation` that was created by this mutation.
  """
  companyOperation: CompanyOperation

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Company` that is related to this `CompanyOperation`.
  """
  companyByCompany: Company

  """
  An edge for our `CompanyOperation`. May be used by Relay 1.
  """
  companyOperationEdge(
    """
    The method to use when ordering `CompanyOperation`.
    """
    orderBy: [CompanyOperationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompanyOperationsEdge
}

"""
All input for the create `CompanyOperation` mutation.
"""
input CreateCompanyOperationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `CompanyOperation` to be created by this mutation.
  """
  companyOperation: CompanyOperationInput!
}

"""
An input for mutations affecting `CompanyOperation`
"""
input CompanyOperationInput {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  company: Int

  """
  ek
  """
  operation: Operation
  createdAt: Datetime
  updatedAt: Datetime
  companyToCompany: CompanyOperationCompanyFkeyInput
}

"""
The output of our create `EvidenceItem` mutation.
"""
type CreateEvidenceItemPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `EvidenceItem` that was created by this mutation.
  """
  evidenceItem: EvidenceItem

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Project` that is related to this `EvidenceItem`.
  """
  project: Project

  """
  Reads a single `Guarantee` that is related to this `EvidenceItem`.
  """
  guarantee: Guarantee

  """
  An edge for our `EvidenceItem`. May be used by Relay 1.
  """
  evidenceItemEdge(
    """
    The method to use when ordering `EvidenceItem`.
    """
    orderBy: [EvidenceItemsOrderBy!] = [PRIMARY_KEY_ASC]
  ): EvidenceItemsEdge
}

"""
All input for the create `EvidenceItem` mutation.
"""
input CreateEvidenceItemInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `EvidenceItem` to be created by this mutation.
  """
  evidenceItem: EvidenceItemInput!
}

"""
An input for mutations affecting `EvidenceItem`
"""
input EvidenceItemInput {
  """
  Primary key
  """
  id: Int

  """
  a reference to the evidenceCategory sys id in Contentful
  """
  customEvidenceCategoryId: String

  """
  fk
  """
  projectId: Int

  """
  fk
  """
  guaranteeId: Int

  """
  ek
  """
  evidenceCategoryType: EvidenceCategoryType

  """
  Short name for the item of evidence
  """
  name: String!

  """
  File reference or the file itself. Photo of the evidence
  """
  attachment: String!
  createdAt: Datetime
  updatedAt: Datetime
  projectToProjectId: EvidenceItemProjectIdFkeyInput
  guaranteeToGuaranteeId: EvidenceItemGuaranteeIdFkeyInput
  attachmentUpload: Upload
}

"""
The output of our create `Guarantee` mutation.
"""
type CreateGuaranteePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Guarantee` that was created by this mutation.
  """
  guarantee: Guarantee

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Account` that is related to this `Guarantee`.
  """
  requestorAccount: Account

  """
  Reads a single `Project` that is related to this `Guarantee`.
  """
  project: Project

  """
  Reads a single `System` that is related to this `Guarantee`.
  """
  systemBySystemBmiRef: System

  """
  Reads a single `Product` that is related to this `Guarantee`.
  """
  productByProductBmiRef: Product

  """
  Reads a single `Account` that is related to this `Guarantee`.
  """
  reviewerAccount: Account

  """
  An edge for our `Guarantee`. May be used by Relay 1.
  """
  guaranteeEdge(
    """
    The method to use when ordering `Guarantee`.
    """
    orderBy: [GuaranteesOrderBy!] = [PRIMARY_KEY_ASC]
  ): GuaranteesEdge
}

"""
All input for the create `Guarantee` mutation.
"""
input CreateGuaranteeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `Guarantee` to be created by this mutation.
  """
  guarantee: GuaranteeInput!
}

"""
An input for mutations affecting `Guarantee`
"""
input GuaranteeInput {
  """
  Primary key - starts at 6100
  """
  id: Int

  """
  The pdf file that is emailed out, or a reference to it, or reference to the service that will generate it on demand
  """
  fileStorageId: String

  """
  fk
  """
  requestorAccountId: Int

  """
  fk
  """
  projectId: Int

  """
  a reference to the guaranteeType sys id in Contentful
  """
  guaranteeTypeId: String!

  """
  fk
  """
  systemBmiRef: String

  """
  fk
  """
  productBmiRef: String

  """
  fk
  """
  reviewerAccountId: Int

  """
  a reference to the guaranteeType sys id in Contentful
  """
  guaranteeTemplateId: String

  """
  ek
  """
  status: RequestStatus

  """
  The date that the Guarantee is approved either automatically or manually
  """
  startDate: Datetime

  """
  When the guarantee will expire.  This should be calculated when the request_status becomes APPROVED. dependent on the StartDate, the Validity of the Product or System and the ValidityOffset in this Tier
  """
  expiryDate: Datetime

  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String
  createdAt: Datetime
  updatedAt: Datetime
  accountToRequestorAccountId: GuaranteeRequestorAccountIdFkeyInput
  projectToProjectId: GuaranteeProjectIdFkeyInput
  systemToSystemBmiRef: GuaranteeSystemBmiRefFkeyInput
  productToProductBmiRef: GuaranteeProductBmiRefFkeyInput
  accountToReviewerAccountId: GuaranteeReviewerAccountIdFkeyInput
  evidenceItemsUsingId: EvidenceItemGuaranteeIdFkeyInverseInput
  guaranteeTypeCoverage: ContentfulGuaranteeCoverageType
}

"""
The output of our create `Market` mutation.
"""
type CreateMarketPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Market` that was created by this mutation.
  """
  market: Market

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  An edge for our `Market`. May be used by Relay 1.
  """
  marketEdge(
    """
    The method to use when ordering `Market`.
    """
    orderBy: [MarketsOrderBy!] = [PRIMARY_KEY_ASC]
  ): MarketsEdge
}

"""
All input for the create `Market` mutation.
"""
input CreateMarketInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `Market` to be created by this mutation.
  """
  market: MarketInput!
}

"""
An input for mutations affecting `Market`
"""
input MarketInput {
  """
  Primary key
  """
  id: Int

  """
  ek
  """
  language: Language

  """
  the country code used for example as the subdomain
  """
  domain: String!

  """
  The space in Contenful
  """
  cmsSpaceId: String

  """
  A short name for the market, e.g. Italy, Norway, Netherlands
  """
  name: String

  """
  The From name used when sending an email
  """
  sendName: String

  """
  The mailbox on intouch.bmigroup.com that emails will be sent from for this Market
  """
  sendMailbox: String

  """
  The default branch in Docebo that installers go into
  """
  doceboInstallersBranchId: String

  """
  The branch in Docebo that company admins go into
  """
  doceboCompanyAdminBranchId: String

  """
  The default catalogue for the market.  All users in the market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int

  """
  The address of the merchandising site for the market.  CTAs of the MERCHANDISING type will link to this address
  """
  merchandisingUrl: String

  """
  Whether the market supports Projects.  If so then the Projects link should be available in th left hand navigation.
  """
  projectsEnabled: Boolean

  """
  Reference to the Google Analytics tracking ID that is used for the Country GA reports
  """
  gtag: String

  """
  The coordinates of the middle of the Market on a map
  """
  geoMiddle: PointInput

  """
  The length of the radius in km (from the geo_middle lat/lng), for which the Google Places API biases the search results for address autocomplete. Locations outside of the radius will not be excluded.
  """
  locationBiasRadiusKm: Int
  createdAt: Datetime
  updatedAt: Datetime
  accountsUsingId: AccountMarketIdFkeyInverseInput
  companiesUsingId: CompanyMarketIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberMarketIdFkeyInverseInput
  productsUsingId: ProductMarketIdFkeyInverseInput
  systemsUsingId: SystemMarketIdFkeyInverseInput
  systemMembersUsingId: SystemMemberMarketIdFkeyInverseInput
}

"""
The output of our create `Note` mutation.
"""
type CreateNotePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Note` that was created by this mutation.
  """
  note: Note

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Account` that is related to this `Note`.
  """
  author: Account

  """
  Reads a single `Project` that is related to this `Note`.
  """
  project: Project

  """
  An edge for our `Note`. May be used by Relay 1.
  """
  noteEdge(
    """
    The method to use when ordering `Note`.
    """
    orderBy: [NotesOrderBy!] = [PRIMARY_KEY_ASC]
  ): NotesEdge
}

"""
All input for the create `Note` mutation.
"""
input CreateNoteInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `Note` to be created by this mutation.
  """
  note: NoteInput!
}

"""
An input for mutations affecting `Note`
"""
input NoteInput {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  authorId: Int

  """
  fk
  """
  projectId: Int

  """
  The body of the Note
  """
  body: String
  createdAt: Datetime
  updatedAt: Datetime
  accountToAuthorId: NoteAuthorIdFkeyInput
  projectToProjectId: NoteProjectIdFkeyInput
}

"""
The output of our create `Notification` mutation.
"""
type CreateNotificationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Notification` that was created by this mutation.
  """
  notification: Notification

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Account` that is related to this `Notification`.
  """
  account: Account

  """
  An edge for our `Notification`. May be used by Relay 1.
  """
  notificationEdge(
    """
    The method to use when ordering `Notification`.
    """
    orderBy: [NotificationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): NotificationsEdge
}

"""
All input for the create `Notification` mutation.
"""
input CreateNotificationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `Notification` to be created by this mutation.
  """
  notification: NotificationInput!
}

"""
An input for mutations affecting `Notification`
"""
input NotificationInput {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  accountId: Int

  """
  The datetime stamp for when the message was sent
  """
  sendDate: Datetime!

  """
  Whether the message has been read
  """
  read: Boolean

  """
  The body of the message
  """
  body: String
  createdAt: Datetime
  updatedAt: Datetime
  accountToAccountId: NotificationAccountIdFkeyInput
}

"""
The output of our create `Product` mutation.
"""
type CreateProductPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Product` that was created by this mutation.
  """
  product: Product

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Market` that is related to this `Product`.
  """
  market: Market

  """
  An edge for our `Product`. May be used by Relay 1.
  """
  productEdge(
    """
    The method to use when ordering `Product`.
    """
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProductsEdge
}

"""
All input for the create `Product` mutation.
"""
input CreateProductInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `Product` to be created by this mutation.
  """
  product: ProductInput!
}

"""
An input for mutations affecting `Product`
"""
input ProductInput {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int

  """
  ek
  """
  technology: Technology

  """
  A unique reference for the product known to BMI
  """
  bmiRef: String!

  """
  The Products brand
  """
  brand: String!

  """
  Short name for the Product
  """
  name: String!

  """
  A description of the Product
  """
  description: String

  """
  The family of Products this Product is in
  """
  family: String!

  """
  Whether the Product is avialable for new guarantees
  """
  published: Boolean!

  """
  The number of years that this product can be guaranteed for
  """
  maximumValidityYears: Int!
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: ProductMarketIdFkeyInput
  guaranteesUsingBmiRef: GuaranteeProductBmiRefFkeyInverseInput
  systemMembersUsingBmiRef: SystemMemberProductBmiRefFkeyInverseInput
}

"""
The output of our create `Project` mutation.
"""
type CreateProjectPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Project` that was created by this mutation.
  """
  project: Project

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Company` that is related to this `Project`.
  """
  company: Company

  """
  Reads a single `Address` that is related to this `Project`.
  """
  siteAddress: Address

  """
  Reads a single `Address` that is related to this `Project`.
  """
  buildingOwnerAddress: Address

  """
  An edge for our `Project`. May be used by Relay 1.
  """
  projectEdge(
    """
    The method to use when ordering `Project`.
    """
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectsEdge
}

"""
All input for the create `Project` mutation.
"""
input CreateProjectInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `Project` to be created by this mutation.
  """
  project: ProjectInput!
}

"""
An input for mutations affecting `Project`
"""
input ProjectInput {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  companyId: Int

  """
  fk
  """
  siteAddressId: Int

  """
  fk
  """
  buildingOwnerAddressId: Int

  """
  ek
  """
  technology: Technology

  """
  Short name for the Project
  """
  name: String!

  """
  Short description of what the Project is about.  Sometimes useful to clarify some points to BMI
  """
  description: String

  """
  If this is true then the Project should be hidden from End Users
  """
  hidden: Boolean

  """
  The number of square meters of roof that this project covers
  """
  roofArea: Int!

  """
  Email address of the person who owns the building that the roof is going on.  Not mandatory for a Project, but mandatory when the Company applies for a Guarantee related to the project.
  """
  buildingOwnerMail: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerFirstname: String

  """
  Name of the Building Owner, seen on the Guarantee. Must be completed before a Guarantee is issued.
  """
  buildingOwnerLastname: String

  """
  Name of the Building Owner company if there is such a thing.  Not the same as an InTouch Company.
  """
  buildingOwnerCompany: String

  """
  The date that the Project officially starts or started
  """
  startDate: Datetime!

  """
  The date that the Project officially expects to end or ended
  """
  endDate: Datetime!
  createdAt: Datetime
  updatedAt: Datetime
  companyToCompanyId: ProjectCompanyIdFkeyInput
  addressToSiteAddressId: ProjectSiteAddressIdFkeyInput
  addressToBuildingOwnerAddressId: ProjectBuildingOwnerAddressIdFkeyInput
  evidenceItemsUsingId: EvidenceItemProjectIdFkeyInverseInput
  guaranteesUsingId: GuaranteeProjectIdFkeyInverseInput
  notesUsingId: NoteProjectIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberProjectIdFkeyInverseInput
}

"""
The output of our create `ProjectMember` mutation.
"""
type CreateProjectMemberPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `ProjectMember` that was created by this mutation.
  """
  projectMember: ProjectMember

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Project` that is related to this `ProjectMember`.
  """
  project: Project

  """
  Reads a single `Account` that is related to this `ProjectMember`.
  """
  account: Account

  """
  An edge for our `ProjectMember`. May be used by Relay 1.
  """
  projectMemberEdge(
    """
    The method to use when ordering `ProjectMember`.
    """
    orderBy: [ProjectMembersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectMembersEdge
}

"""
All input for the create `ProjectMember` mutation.
"""
input CreateProjectMemberInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `ProjectMember` to be created by this mutation.
  """
  projectMember: ProjectMemberInput!
}

"""
An input for mutations affecting `ProjectMember`
"""
input ProjectMemberInput {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  projectId: Int

  """
  fk
  """
  accountId: Int

  """
  The responsible installer
  """
  isResponsibleInstaller: Boolean
  createdAt: Datetime
  updatedAt: Datetime
  projectToProjectId: ProjectMemberProjectIdFkeyInput
  accountToAccountId: ProjectMemberAccountIdFkeyInput
}

"""
The output of our create `System` mutation.
"""
type CreateSystemPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `System` that was created by this mutation.
  """
  system: System

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Market` that is related to this `System`.
  """
  market: Market

  """
  An edge for our `System`. May be used by Relay 1.
  """
  systemEdge(
    """
    The method to use when ordering `System`.
    """
    orderBy: [SystemsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SystemsEdge
}

"""
All input for the create `System` mutation.
"""
input CreateSystemInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `System` to be created by this mutation.
  """
  system: SystemInput!
}

"""
An input for mutations affecting `System`
"""
input SystemInput {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  marketId: Int

  """
  ek
  """
  technology: Technology

  """
  A unique reference for the system known to BMI
  """
  bmiRef: String!

  """
  Short name for the System
  """
  name: String!

  """
  A description for the System
  """
  description: String

  """
  The maximum number of years that this system can be guaranteed for.  Must be greater than 10.
  """
  maximumValidityYears: Int!

  """
  If true this system is available for users to select when applying for a system or solution guarantee
  """
  published: Boolean!
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: SystemMarketIdFkeyInput
  guaranteesUsingBmiRef: GuaranteeSystemBmiRefFkeyInverseInput
  systemMembersUsingBmiRef: SystemMemberSystemBmiRefFkeyInverseInput
}

"""
The output of our create `SystemMember` mutation.
"""
type CreateSystemMemberPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `SystemMember` that was created by this mutation.
  """
  systemMember: SystemMember

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `System` that is related to this `SystemMember`.
  """
  systemBySystemBmiRef: System

  """
  Reads a single `Product` that is related to this `SystemMember`.
  """
  productByProductBmiRef: Product

  """
  Reads a single `Market` that is related to this `SystemMember`.
  """
  market: Market

  """
  An edge for our `SystemMember`. May be used by Relay 1.
  """
  systemMemberEdge(
    """
    The method to use when ordering `SystemMember`.
    """
    orderBy: [SystemMembersOrderBy!] = [PRIMARY_KEY_ASC]
  ): SystemMembersEdge
}

"""
All input for the create `SystemMember` mutation.
"""
input CreateSystemMemberInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `SystemMember` to be created by this mutation.
  """
  systemMember: SystemMemberInput!
}

"""
An input for mutations affecting `SystemMember`
"""
input SystemMemberInput {
  """
  Primary key
  """
  id: Int

  """
  fk
  """
  systemBmiRef: String

  """
  fk
  """
  productBmiRef: String

  """
  fk
  """
  marketId: Int
  createdAt: Datetime
  updatedAt: Datetime
  systemToSystemBmiRef: SystemMemberSystemBmiRefFkeyInput
  productToProductBmiRef: SystemMemberProductBmiRefFkeyInput
  marketToMarketId: SystemMemberMarketIdFkeyInput
}

"""
The output of our update `Account` mutation.
"""
type UpdateAccountPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Account` that was updated by this mutation.
  """
  account: Account

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Market` that is related to this `Account`.
  """
  market: Market

  """
  An edge for our `Account`. May be used by Relay 1.
  """
  accountEdge(
    """
    The method to use when ordering `Account`.
    """
    orderBy: [AccountsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AccountsEdge
}

"""
All input for the `updateAccountByNodeId` mutation.
"""
input UpdateAccountByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Account` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Account` being updated.
  """
  patch: AccountPatch!
}

"""
All input for the `updateAccount` mutation.
"""
input UpdateAccountInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Account` being updated.
  """
  patch: AccountPatch!

  """
  Primary key
  """
  id: Int!
}

"""
All input for the `updateAccountByEmail` mutation.
"""
input UpdateAccountByEmailInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Account` being updated.
  """
  patch: AccountPatch!

  """
  The email address associated with the account
  """
  email: String!
}

"""
All input for the `updateAccountByDoceboUserId` mutation.
"""
input UpdateAccountByDoceboUserIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Account` being updated.
  """
  patch: AccountPatch!

  """
  User account in Docebo
  """
  doceboUserId: Int!
}

"""
The output of our update `Address` mutation.
"""
type UpdateAddressPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Address` that was updated by this mutation.
  """
  address: Address

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  An edge for our `Address`. May be used by Relay 1.
  """
  addressEdge(
    """
    The method to use when ordering `Address`.
    """
    orderBy: [AddressesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AddressesEdge
}

"""
All input for the `updateAddressByNodeId` mutation.
"""
input UpdateAddressByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Address` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Address` being updated.
  """
  patch: AddressPatch!
}

"""
All input for the `updateAddress` mutation.
"""
input UpdateAddressInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Address` being updated.
  """
  patch: AddressPatch!

  """
  Primary key
  """
  id: Int!
}

"""
The output of our update `Certification` mutation.
"""
type UpdateCertificationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Certification` that was updated by this mutation.
  """
  certification: Certification

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Account` that is related to this `Certification`.
  """
  doceboUser: Account

  """
  An edge for our `Certification`. May be used by Relay 1.
  """
  certificationEdge(
    """
    The method to use when ordering `Certification`.
    """
    orderBy: [CertificationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CertificationsEdge
}

"""
All input for the `updateCertificationByNodeId` mutation.
"""
input UpdateCertificationByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Certification` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Certification` being updated.
  """
  patch: CertificationPatch!
}

"""
All input for the `updateCertification` mutation.
"""
input UpdateCertificationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Certification` being updated.
  """
  patch: CertificationPatch!

  """
  Primary key
  """
  id: Int!
}

"""
The output of our update `Company` mutation.
"""
type UpdateCompanyPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Company` that was updated by this mutation.
  """
  company: Company

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Market` that is related to this `Company`.
  """
  market: Market

  """
  Reads a single `Address` that is related to this `Company`.
  """
  registeredAddress: Address

  """
  Reads a single `Address` that is related to this `Company`.
  """
  tradingAddress: Address

  """
  An edge for our `Company`. May be used by Relay 1.
  """
  companyEdge(
    """
    The method to use when ordering `Company`.
    """
    orderBy: [CompaniesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompaniesEdge
}

"""
All input for the `updateCompanyByNodeId` mutation.
"""
input UpdateCompanyByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Company` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Company` being updated.
  """
  patch: CompanyPatch!
}

"""
All input for the `updateCompany` mutation.
"""
input UpdateCompanyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Company` being updated.
  """
  patch: CompanyPatch!

  """
  Primary key
  """
  id: Int!
}

"""
All input for the `updateCompanyByName` mutation.
"""
input UpdateCompanyByNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Company` being updated.
  """
  patch: CompanyPatch!

  """
  The registered name of the Company
  """
  name: String!
}

"""
All input for the `updateCompanyByReferenceNumber` mutation.
"""
input UpdateCompanyByReferenceNumberInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Company` being updated.
  """
  patch: CompanyPatch!

  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: String!
}

"""
The output of our update `CompanyDocument` mutation.
"""
type UpdateCompanyDocumentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `CompanyDocument` that was updated by this mutation.
  """
  companyDocument: CompanyDocument

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Company` that is related to this `CompanyDocument`.
  """
  company: Company

  """
  An edge for our `CompanyDocument`. May be used by Relay 1.
  """
  companyDocumentEdge(
    """
    The method to use when ordering `CompanyDocument`.
    """
    orderBy: [CompanyDocumentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompanyDocumentsEdge
}

"""
All input for the `updateCompanyDocumentByNodeId` mutation.
"""
input UpdateCompanyDocumentByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CompanyDocument` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `CompanyDocument` being updated.
  """
  patch: CompanyDocumentPatch!
}

"""
All input for the `updateCompanyDocument` mutation.
"""
input UpdateCompanyDocumentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `CompanyDocument` being updated.
  """
  patch: CompanyDocumentPatch!

  """
  Primary key
  """
  id: Int!
}

"""
The output of our update `CompanyMember` mutation.
"""
type UpdateCompanyMemberPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `CompanyMember` that was updated by this mutation.
  """
  companyMember: CompanyMember

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Market` that is related to this `CompanyMember`.
  """
  market: Market

  """
  Reads a single `Account` that is related to this `CompanyMember`.
  """
  account: Account

  """
  Reads a single `Company` that is related to this `CompanyMember`.
  """
  company: Company

  """
  An edge for our `CompanyMember`. May be used by Relay 1.
  """
  companyMemberEdge(
    """
    The method to use when ordering `CompanyMember`.
    """
    orderBy: [CompanyMembersOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompanyMembersEdge
}

"""
All input for the `updateCompanyMemberByNodeId` mutation.
"""
input UpdateCompanyMemberByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CompanyMember` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `CompanyMember` being updated.
  """
  patch: CompanyMemberPatch!
}

"""
All input for the `updateCompanyMember` mutation.
"""
input UpdateCompanyMemberInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `CompanyMember` being updated.
  """
  patch: CompanyMemberPatch!

  """
  Primary key
  """
  id: Int!
}

"""
All input for the `updateCompanyMemberByMarketIdAndAccountIdAndCompanyId` mutation.
"""
input UpdateCompanyMemberByMarketIdAndAccountIdAndCompanyIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `CompanyMember` being updated.
  """
  patch: CompanyMemberPatch!

  """
  fk
  """
  marketId: Int!

  """
  fk
  """
  accountId: Int!

  """
  fk
  """
  companyId: Int!
}

"""
The output of our update `CompanyOperation` mutation.
"""
type UpdateCompanyOperationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `CompanyOperation` that was updated by this mutation.
  """
  companyOperation: CompanyOperation

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Company` that is related to this `CompanyOperation`.
  """
  companyByCompany: Company

  """
  An edge for our `CompanyOperation`. May be used by Relay 1.
  """
  companyOperationEdge(
    """
    The method to use when ordering `CompanyOperation`.
    """
    orderBy: [CompanyOperationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompanyOperationsEdge
}

"""
All input for the `updateCompanyOperationByNodeId` mutation.
"""
input UpdateCompanyOperationByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CompanyOperation` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `CompanyOperation` being updated.
  """
  patch: CompanyOperationPatch!
}

"""
All input for the `updateCompanyOperation` mutation.
"""
input UpdateCompanyOperationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `CompanyOperation` being updated.
  """
  patch: CompanyOperationPatch!

  """
  Primary key
  """
  id: Int!
}

"""
The output of our update `EvidenceItem` mutation.
"""
type UpdateEvidenceItemPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `EvidenceItem` that was updated by this mutation.
  """
  evidenceItem: EvidenceItem

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Project` that is related to this `EvidenceItem`.
  """
  project: Project

  """
  Reads a single `Guarantee` that is related to this `EvidenceItem`.
  """
  guarantee: Guarantee

  """
  An edge for our `EvidenceItem`. May be used by Relay 1.
  """
  evidenceItemEdge(
    """
    The method to use when ordering `EvidenceItem`.
    """
    orderBy: [EvidenceItemsOrderBy!] = [PRIMARY_KEY_ASC]
  ): EvidenceItemsEdge
}

"""
All input for the `updateEvidenceItemByNodeId` mutation.
"""
input UpdateEvidenceItemByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `EvidenceItem` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `EvidenceItem` being updated.
  """
  patch: EvidenceItemPatch!
}

"""
All input for the `updateEvidenceItem` mutation.
"""
input UpdateEvidenceItemInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `EvidenceItem` being updated.
  """
  patch: EvidenceItemPatch!

  """
  Primary key
  """
  id: Int!
}

"""
The output of our update `Guarantee` mutation.
"""
type UpdateGuaranteePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Guarantee` that was updated by this mutation.
  """
  guarantee: Guarantee

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Account` that is related to this `Guarantee`.
  """
  requestorAccount: Account

  """
  Reads a single `Project` that is related to this `Guarantee`.
  """
  project: Project

  """
  Reads a single `System` that is related to this `Guarantee`.
  """
  systemBySystemBmiRef: System

  """
  Reads a single `Product` that is related to this `Guarantee`.
  """
  productByProductBmiRef: Product

  """
  Reads a single `Account` that is related to this `Guarantee`.
  """
  reviewerAccount: Account

  """
  An edge for our `Guarantee`. May be used by Relay 1.
  """
  guaranteeEdge(
    """
    The method to use when ordering `Guarantee`.
    """
    orderBy: [GuaranteesOrderBy!] = [PRIMARY_KEY_ASC]
  ): GuaranteesEdge
}

"""
All input for the `updateGuaranteeByNodeId` mutation.
"""
input UpdateGuaranteeByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Guarantee` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Guarantee` being updated.
  """
  patch: GuaranteePatch!
}

"""
All input for the `updateGuarantee` mutation.
"""
input UpdateGuaranteeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Guarantee` being updated.
  """
  patch: GuaranteePatch!

  """
  Primary key - starts at 6100
  """
  id: Int!
  guaranteeEventType: GuaranteeEventType
}

enum GuaranteeEventType {
  SUBMIT_SOLUTION
  ASSIGN_SOLUTION
  REASSIGN_SOLUTION
  UNASSIGN_SOLUTION
  APPROVE_SOLUTION
  REJECT_SOLUTION
}

"""
All input for the `updateGuaranteeByBmiReferenceId` mutation.
"""
input UpdateGuaranteeByBmiReferenceIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Guarantee` being updated.
  """
  patch: GuaranteePatch!

  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String!
}

"""
The output of our update `Invitation` mutation.
"""
type UpdateInvitationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Invitation` that was updated by this mutation.
  """
  invitation: Invitation

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Account` that is related to this `Invitation`.
  """
  senderAccount: Account

  """
  Reads a single `Company` that is related to this `Invitation`.
  """
  company: Company

  """
  An edge for our `Invitation`. May be used by Relay 1.
  """
  invitationEdge(
    """
    The method to use when ordering `Invitation`.
    """
    orderBy: [InvitationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): InvitationsEdge
}

"""
All input for the `updateInvitationByNodeId` mutation.
"""
input UpdateInvitationByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Invitation` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Invitation` being updated.
  """
  patch: InvitationPatch!
}

"""
All input for the `updateInvitation` mutation.
"""
input UpdateInvitationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Invitation` being updated.
  """
  patch: InvitationPatch!

  """
  Primary key
  """
  id: Int!
}

"""
The output of our update `Market` mutation.
"""
type UpdateMarketPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Market` that was updated by this mutation.
  """
  market: Market

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  An edge for our `Market`. May be used by Relay 1.
  """
  marketEdge(
    """
    The method to use when ordering `Market`.
    """
    orderBy: [MarketsOrderBy!] = [PRIMARY_KEY_ASC]
  ): MarketsEdge
}

"""
All input for the `updateMarketByNodeId` mutation.
"""
input UpdateMarketByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Market` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Market` being updated.
  """
  patch: MarketPatch!
}

"""
All input for the `updateMarket` mutation.
"""
input UpdateMarketInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Market` being updated.
  """
  patch: MarketPatch!

  """
  Primary key
  """
  id: Int!
}

"""
All input for the `updateMarketByDomain` mutation.
"""
input UpdateMarketByDomainInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Market` being updated.
  """
  patch: MarketPatch!

  """
  the country code used for example as the subdomain
  """
  domain: String!
}

"""
All input for the `updateMarketByDoceboCatalogueId` mutation.
"""
input UpdateMarketByDoceboCatalogueIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Market` being updated.
  """
  patch: MarketPatch!

  """
  The default catalogue for the market.  All users in the market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int!
}

"""
The output of our update `Note` mutation.
"""
type UpdateNotePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Note` that was updated by this mutation.
  """
  note: Note

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Account` that is related to this `Note`.
  """
  author: Account

  """
  Reads a single `Project` that is related to this `Note`.
  """
  project: Project

  """
  An edge for our `Note`. May be used by Relay 1.
  """
  noteEdge(
    """
    The method to use when ordering `Note`.
    """
    orderBy: [NotesOrderBy!] = [PRIMARY_KEY_ASC]
  ): NotesEdge
}

"""
All input for the `updateNoteByNodeId` mutation.
"""
input UpdateNoteByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Note` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Note` being updated.
  """
  patch: NotePatch!
}

"""
All input for the `updateNote` mutation.
"""
input UpdateNoteInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Note` being updated.
  """
  patch: NotePatch!

  """
  Primary key
  """
  id: Int!
}

"""
The output of our update `Notification` mutation.
"""
type UpdateNotificationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Notification` that was updated by this mutation.
  """
  notification: Notification

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Account` that is related to this `Notification`.
  """
  account: Account

  """
  An edge for our `Notification`. May be used by Relay 1.
  """
  notificationEdge(
    """
    The method to use when ordering `Notification`.
    """
    orderBy: [NotificationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): NotificationsEdge
}

"""
All input for the `updateNotificationByNodeId` mutation.
"""
input UpdateNotificationByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Notification` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Notification` being updated.
  """
  patch: NotificationPatch!
}

"""
All input for the `updateNotification` mutation.
"""
input UpdateNotificationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Notification` being updated.
  """
  patch: NotificationPatch!

  """
  Primary key
  """
  id: Int!
}

"""
The output of our update `Product` mutation.
"""
type UpdateProductPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Product` that was updated by this mutation.
  """
  product: Product

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Market` that is related to this `Product`.
  """
  market: Market

  """
  An edge for our `Product`. May be used by Relay 1.
  """
  productEdge(
    """
    The method to use when ordering `Product`.
    """
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProductsEdge
}

"""
All input for the `updateProductByNodeId` mutation.
"""
input UpdateProductByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Product` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Product` being updated.
  """
  patch: ProductPatch!
}

"""
All input for the `updateProduct` mutation.
"""
input UpdateProductInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Product` being updated.
  """
  patch: ProductPatch!

  """
  Primary key
  """
  id: Int!
}

"""
All input for the `updateProductByBmiRef` mutation.
"""
input UpdateProductByBmiRefInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Product` being updated.
  """
  patch: ProductPatch!

  """
  A unique reference for the product known to BMI
  """
  bmiRef: String!
}

"""
The output of our update `Project` mutation.
"""
type UpdateProjectPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Project` that was updated by this mutation.
  """
  project: Project

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Company` that is related to this `Project`.
  """
  company: Company

  """
  Reads a single `Address` that is related to this `Project`.
  """
  siteAddress: Address

  """
  Reads a single `Address` that is related to this `Project`.
  """
  buildingOwnerAddress: Address

  """
  An edge for our `Project`. May be used by Relay 1.
  """
  projectEdge(
    """
    The method to use when ordering `Project`.
    """
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectsEdge
}

"""
All input for the `updateProjectByNodeId` mutation.
"""
input UpdateProjectByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Project` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Project` being updated.
  """
  patch: ProjectPatch!
}

"""
All input for the `updateProject` mutation.
"""
input UpdateProjectInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Project` being updated.
  """
  patch: ProjectPatch!

  """
  Primary key
  """
  id: Int!
}

"""
The output of our update `ProjectMember` mutation.
"""
type UpdateProjectMemberPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `ProjectMember` that was updated by this mutation.
  """
  projectMember: ProjectMember

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Project` that is related to this `ProjectMember`.
  """
  project: Project

  """
  Reads a single `Account` that is related to this `ProjectMember`.
  """
  account: Account

  """
  An edge for our `ProjectMember`. May be used by Relay 1.
  """
  projectMemberEdge(
    """
    The method to use when ordering `ProjectMember`.
    """
    orderBy: [ProjectMembersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectMembersEdge
}

"""
All input for the `updateProjectMemberByNodeId` mutation.
"""
input UpdateProjectMemberByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ProjectMember` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `ProjectMember` being updated.
  """
  patch: ProjectMemberPatch!
}

"""
All input for the `updateProjectMember` mutation.
"""
input UpdateProjectMemberInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `ProjectMember` being updated.
  """
  patch: ProjectMemberPatch!

  """
  Primary key
  """
  id: Int!
}

"""
The output of our update `System` mutation.
"""
type UpdateSystemPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `System` that was updated by this mutation.
  """
  system: System

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Market` that is related to this `System`.
  """
  market: Market

  """
  An edge for our `System`. May be used by Relay 1.
  """
  systemEdge(
    """
    The method to use when ordering `System`.
    """
    orderBy: [SystemsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SystemsEdge
}

"""
All input for the `updateSystemByNodeId` mutation.
"""
input UpdateSystemByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `System` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `System` being updated.
  """
  patch: SystemPatch!
}

"""
All input for the `updateSystem` mutation.
"""
input UpdateSystemInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `System` being updated.
  """
  patch: SystemPatch!

  """
  Primary key
  """
  id: Int!
}

"""
All input for the `updateSystemByBmiRef` mutation.
"""
input UpdateSystemByBmiRefInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `System` being updated.
  """
  patch: SystemPatch!

  """
  A unique reference for the system known to BMI
  """
  bmiRef: String!
}

"""
The output of our update `SystemMember` mutation.
"""
type UpdateSystemMemberPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `SystemMember` that was updated by this mutation.
  """
  systemMember: SystemMember

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `System` that is related to this `SystemMember`.
  """
  systemBySystemBmiRef: System

  """
  Reads a single `Product` that is related to this `SystemMember`.
  """
  productByProductBmiRef: Product

  """
  Reads a single `Market` that is related to this `SystemMember`.
  """
  market: Market

  """
  An edge for our `SystemMember`. May be used by Relay 1.
  """
  systemMemberEdge(
    """
    The method to use when ordering `SystemMember`.
    """
    orderBy: [SystemMembersOrderBy!] = [PRIMARY_KEY_ASC]
  ): SystemMembersEdge
}

"""
All input for the `updateSystemMemberByNodeId` mutation.
"""
input UpdateSystemMemberByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `SystemMember` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `SystemMember` being updated.
  """
  patch: SystemMemberPatch!
}

"""
All input for the `updateSystemMember` mutation.
"""
input UpdateSystemMemberInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `SystemMember` being updated.
  """
  patch: SystemMemberPatch!

  """
  Primary key
  """
  id: Int!
}

"""
All input for the `updateSystemMemberBySystemBmiRefAndProductBmiRefAndMarketId` mutation.
"""
input UpdateSystemMemberBySystemBmiRefAndProductBmiRefAndMarketIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `SystemMember` being updated.
  """
  patch: SystemMemberPatch!

  """
  fk
  """
  systemBmiRef: String!

  """
  fk
  """
  productBmiRef: String!

  """
  fk
  """
  marketId: Int!
}

"""
The output of our delete `Account` mutation.
"""
type DeleteAccountPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Account` that was deleted by this mutation.
  """
  account: Account
  deletedAccountNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Market` that is related to this `Account`.
  """
  market: Market

  """
  An edge for our `Account`. May be used by Relay 1.
  """
  accountEdge(
    """
    The method to use when ordering `Account`.
    """
    orderBy: [AccountsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AccountsEdge
}

"""
All input for the `deleteAccountByNodeId` mutation.
"""
input DeleteAccountByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Account` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteAccount` mutation.
"""
input DeleteAccountInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
All input for the `deleteAccountByEmail` mutation.
"""
input DeleteAccountByEmailInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The email address associated with the account
  """
  email: String!
}

"""
All input for the `deleteAccountByDoceboUserId` mutation.
"""
input DeleteAccountByDoceboUserIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  User account in Docebo
  """
  doceboUserId: Int!
}

"""
The output of our delete `Address` mutation.
"""
type DeleteAddressPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Address` that was deleted by this mutation.
  """
  address: Address
  deletedAddressNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  An edge for our `Address`. May be used by Relay 1.
  """
  addressEdge(
    """
    The method to use when ordering `Address`.
    """
    orderBy: [AddressesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AddressesEdge
}

"""
All input for the `deleteAddressByNodeId` mutation.
"""
input DeleteAddressByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Address` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteAddress` mutation.
"""
input DeleteAddressInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
The output of our delete `Certification` mutation.
"""
type DeleteCertificationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Certification` that was deleted by this mutation.
  """
  certification: Certification
  deletedCertificationNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Account` that is related to this `Certification`.
  """
  doceboUser: Account

  """
  An edge for our `Certification`. May be used by Relay 1.
  """
  certificationEdge(
    """
    The method to use when ordering `Certification`.
    """
    orderBy: [CertificationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CertificationsEdge
}

"""
All input for the `deleteCertificationByNodeId` mutation.
"""
input DeleteCertificationByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Certification` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteCertification` mutation.
"""
input DeleteCertificationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
The output of our delete `Company` mutation.
"""
type DeleteCompanyPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Company` that was deleted by this mutation.
  """
  company: Company
  deletedCompanyNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Market` that is related to this `Company`.
  """
  market: Market

  """
  Reads a single `Address` that is related to this `Company`.
  """
  registeredAddress: Address

  """
  Reads a single `Address` that is related to this `Company`.
  """
  tradingAddress: Address

  """
  An edge for our `Company`. May be used by Relay 1.
  """
  companyEdge(
    """
    The method to use when ordering `Company`.
    """
    orderBy: [CompaniesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompaniesEdge
}

"""
All input for the `deleteCompanyByNodeId` mutation.
"""
input DeleteCompanyByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Company` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteCompany` mutation.
"""
input DeleteCompanyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
All input for the `deleteCompanyByName` mutation.
"""
input DeleteCompanyByNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The registered name of the Company
  """
  name: String!
}

"""
All input for the `deleteCompanyByReferenceNumber` mutation.
"""
input DeleteCompanyByReferenceNumberInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  A 7 digit reference number generated for all Companies and visible to Roofpro member Companies. (aka membership number).  Should be unique.
  """
  referenceNumber: String!
}

"""
The output of our delete `CompanyDocument` mutation.
"""
type DeleteCompanyDocumentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `CompanyDocument` that was deleted by this mutation.
  """
  companyDocument: CompanyDocument
  deletedCompanyDocumentNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Company` that is related to this `CompanyDocument`.
  """
  company: Company

  """
  An edge for our `CompanyDocument`. May be used by Relay 1.
  """
  companyDocumentEdge(
    """
    The method to use when ordering `CompanyDocument`.
    """
    orderBy: [CompanyDocumentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompanyDocumentsEdge
}

"""
All input for the `deleteCompanyDocumentByNodeId` mutation.
"""
input DeleteCompanyDocumentByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CompanyDocument` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteCompanyDocument` mutation.
"""
input DeleteCompanyDocumentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
The output of our delete `CompanyMember` mutation.
"""
type DeleteCompanyMemberPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `CompanyMember` that was deleted by this mutation.
  """
  companyMember: CompanyMember
  deletedCompanyMemberNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Market` that is related to this `CompanyMember`.
  """
  market: Market

  """
  Reads a single `Account` that is related to this `CompanyMember`.
  """
  account: Account

  """
  Reads a single `Company` that is related to this `CompanyMember`.
  """
  company: Company

  """
  An edge for our `CompanyMember`. May be used by Relay 1.
  """
  companyMemberEdge(
    """
    The method to use when ordering `CompanyMember`.
    """
    orderBy: [CompanyMembersOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompanyMembersEdge
}

"""
All input for the `deleteCompanyMemberByNodeId` mutation.
"""
input DeleteCompanyMemberByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CompanyMember` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteCompanyMember` mutation.
"""
input DeleteCompanyMemberInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
All input for the `deleteCompanyMemberByMarketIdAndAccountIdAndCompanyId` mutation.
"""
input DeleteCompanyMemberByMarketIdAndAccountIdAndCompanyIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  fk
  """
  marketId: Int!

  """
  fk
  """
  accountId: Int!

  """
  fk
  """
  companyId: Int!
}

"""
The output of our delete `CompanyOperation` mutation.
"""
type DeleteCompanyOperationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `CompanyOperation` that was deleted by this mutation.
  """
  companyOperation: CompanyOperation
  deletedCompanyOperationNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Company` that is related to this `CompanyOperation`.
  """
  companyByCompany: Company

  """
  An edge for our `CompanyOperation`. May be used by Relay 1.
  """
  companyOperationEdge(
    """
    The method to use when ordering `CompanyOperation`.
    """
    orderBy: [CompanyOperationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompanyOperationsEdge
}

"""
All input for the `deleteCompanyOperationByNodeId` mutation.
"""
input DeleteCompanyOperationByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CompanyOperation` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteCompanyOperation` mutation.
"""
input DeleteCompanyOperationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
The output of our delete `EvidenceItem` mutation.
"""
type DeleteEvidenceItemPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `EvidenceItem` that was deleted by this mutation.
  """
  evidenceItem: EvidenceItem
  deletedEvidenceItemNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Project` that is related to this `EvidenceItem`.
  """
  project: Project

  """
  Reads a single `Guarantee` that is related to this `EvidenceItem`.
  """
  guarantee: Guarantee

  """
  An edge for our `EvidenceItem`. May be used by Relay 1.
  """
  evidenceItemEdge(
    """
    The method to use when ordering `EvidenceItem`.
    """
    orderBy: [EvidenceItemsOrderBy!] = [PRIMARY_KEY_ASC]
  ): EvidenceItemsEdge
}

"""
All input for the `deleteEvidenceItemByNodeId` mutation.
"""
input DeleteEvidenceItemByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `EvidenceItem` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteEvidenceItem` mutation.
"""
input DeleteEvidenceItemInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
The output of our delete `Guarantee` mutation.
"""
type DeleteGuaranteePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Guarantee` that was deleted by this mutation.
  """
  guarantee: Guarantee
  deletedGuaranteeNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Account` that is related to this `Guarantee`.
  """
  requestorAccount: Account

  """
  Reads a single `Project` that is related to this `Guarantee`.
  """
  project: Project

  """
  Reads a single `System` that is related to this `Guarantee`.
  """
  systemBySystemBmiRef: System

  """
  Reads a single `Product` that is related to this `Guarantee`.
  """
  productByProductBmiRef: Product

  """
  Reads a single `Account` that is related to this `Guarantee`.
  """
  reviewerAccount: Account

  """
  An edge for our `Guarantee`. May be used by Relay 1.
  """
  guaranteeEdge(
    """
    The method to use when ordering `Guarantee`.
    """
    orderBy: [GuaranteesOrderBy!] = [PRIMARY_KEY_ASC]
  ): GuaranteesEdge
}

"""
All input for the `deleteGuaranteeByNodeId` mutation.
"""
input DeleteGuaranteeByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Guarantee` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteGuarantee` mutation.
"""
input DeleteGuaranteeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key - starts at 6100
  """
  id: Int!
}

"""
All input for the `deleteGuaranteeByBmiReferenceId` mutation.
"""
input DeleteGuaranteeByBmiReferenceIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  This will be presented on the Guarantee pdf itself, if approved and is the primary reference for the Guarantees report. It is unique in the In the legacy system, the number is 3 sets of 4 digit numbers concatenated into one long number from the Company Id, Project Id and Guarantee Id
  """
  bmiReferenceId: String!
}

"""
The output of our delete `Invitation` mutation.
"""
type DeleteInvitationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Invitation` that was deleted by this mutation.
  """
  invitation: Invitation
  deletedInvitationNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Account` that is related to this `Invitation`.
  """
  senderAccount: Account

  """
  Reads a single `Company` that is related to this `Invitation`.
  """
  company: Company

  """
  An edge for our `Invitation`. May be used by Relay 1.
  """
  invitationEdge(
    """
    The method to use when ordering `Invitation`.
    """
    orderBy: [InvitationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): InvitationsEdge
}

"""
All input for the `deleteInvitationByNodeId` mutation.
"""
input DeleteInvitationByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Invitation` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteInvitation` mutation.
"""
input DeleteInvitationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
The output of our delete `Market` mutation.
"""
type DeleteMarketPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Market` that was deleted by this mutation.
  """
  market: Market
  deletedMarketNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  An edge for our `Market`. May be used by Relay 1.
  """
  marketEdge(
    """
    The method to use when ordering `Market`.
    """
    orderBy: [MarketsOrderBy!] = [PRIMARY_KEY_ASC]
  ): MarketsEdge
}

"""
All input for the `deleteMarketByNodeId` mutation.
"""
input DeleteMarketByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Market` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteMarket` mutation.
"""
input DeleteMarketInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
All input for the `deleteMarketByDomain` mutation.
"""
input DeleteMarketByDomainInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  the country code used for example as the subdomain
  """
  domain: String!
}

"""
All input for the `deleteMarketByDoceboCatalogueId` mutation.
"""
input DeleteMarketByDoceboCatalogueIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The default catalogue for the market.  All users in the market are able to see all courses in the default catalog from InTouch
  """
  doceboCatalogueId: Int!
}

"""
The output of our delete `Note` mutation.
"""
type DeleteNotePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Note` that was deleted by this mutation.
  """
  note: Note
  deletedNoteNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Account` that is related to this `Note`.
  """
  author: Account

  """
  Reads a single `Project` that is related to this `Note`.
  """
  project: Project

  """
  An edge for our `Note`. May be used by Relay 1.
  """
  noteEdge(
    """
    The method to use when ordering `Note`.
    """
    orderBy: [NotesOrderBy!] = [PRIMARY_KEY_ASC]
  ): NotesEdge
}

"""
All input for the `deleteNoteByNodeId` mutation.
"""
input DeleteNoteByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Note` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteNote` mutation.
"""
input DeleteNoteInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
The output of our delete `Notification` mutation.
"""
type DeleteNotificationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Notification` that was deleted by this mutation.
  """
  notification: Notification
  deletedNotificationNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Account` that is related to this `Notification`.
  """
  account: Account

  """
  An edge for our `Notification`. May be used by Relay 1.
  """
  notificationEdge(
    """
    The method to use when ordering `Notification`.
    """
    orderBy: [NotificationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): NotificationsEdge
}

"""
All input for the `deleteNotificationByNodeId` mutation.
"""
input DeleteNotificationByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Notification` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteNotification` mutation.
"""
input DeleteNotificationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
The output of our delete `Product` mutation.
"""
type DeleteProductPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Product` that was deleted by this mutation.
  """
  product: Product
  deletedProductNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Market` that is related to this `Product`.
  """
  market: Market

  """
  An edge for our `Product`. May be used by Relay 1.
  """
  productEdge(
    """
    The method to use when ordering `Product`.
    """
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProductsEdge
}

"""
All input for the `deleteProductByNodeId` mutation.
"""
input DeleteProductByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Product` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteProduct` mutation.
"""
input DeleteProductInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
All input for the `deleteProductByBmiRef` mutation.
"""
input DeleteProductByBmiRefInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  A unique reference for the product known to BMI
  """
  bmiRef: String!
}

"""
The output of our delete `Project` mutation.
"""
type DeleteProjectPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Project` that was deleted by this mutation.
  """
  project: Project
  deletedProjectNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Company` that is related to this `Project`.
  """
  company: Company

  """
  Reads a single `Address` that is related to this `Project`.
  """
  siteAddress: Address

  """
  Reads a single `Address` that is related to this `Project`.
  """
  buildingOwnerAddress: Address

  """
  An edge for our `Project`. May be used by Relay 1.
  """
  projectEdge(
    """
    The method to use when ordering `Project`.
    """
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectsEdge
}

"""
All input for the `deleteProjectByNodeId` mutation.
"""
input DeleteProjectByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Project` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteProject` mutation.
"""
input DeleteProjectInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
The output of our delete `ProjectMember` mutation.
"""
type DeleteProjectMemberPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `ProjectMember` that was deleted by this mutation.
  """
  projectMember: ProjectMember
  deletedProjectMemberNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Project` that is related to this `ProjectMember`.
  """
  project: Project

  """
  Reads a single `Account` that is related to this `ProjectMember`.
  """
  account: Account

  """
  An edge for our `ProjectMember`. May be used by Relay 1.
  """
  projectMemberEdge(
    """
    The method to use when ordering `ProjectMember`.
    """
    orderBy: [ProjectMembersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectMembersEdge
}

"""
All input for the `deleteProjectMemberByNodeId` mutation.
"""
input DeleteProjectMemberByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ProjectMember` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteProjectMember` mutation.
"""
input DeleteProjectMemberInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
The output of our delete `System` mutation.
"""
type DeleteSystemPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `System` that was deleted by this mutation.
  """
  system: System
  deletedSystemNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Market` that is related to this `System`.
  """
  market: Market

  """
  An edge for our `System`. May be used by Relay 1.
  """
  systemEdge(
    """
    The method to use when ordering `System`.
    """
    orderBy: [SystemsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SystemsEdge
}

"""
All input for the `deleteSystemByNodeId` mutation.
"""
input DeleteSystemByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `System` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteSystem` mutation.
"""
input DeleteSystemInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
All input for the `deleteSystemByBmiRef` mutation.
"""
input DeleteSystemByBmiRefInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  A unique reference for the system known to BMI
  """
  bmiRef: String!
}

"""
The output of our delete `SystemMember` mutation.
"""
type DeleteSystemMemberPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `SystemMember` that was deleted by this mutation.
  """
  systemMember: SystemMember
  deletedSystemMemberNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `System` that is related to this `SystemMember`.
  """
  systemBySystemBmiRef: System

  """
  Reads a single `Product` that is related to this `SystemMember`.
  """
  productByProductBmiRef: Product

  """
  Reads a single `Market` that is related to this `SystemMember`.
  """
  market: Market

  """
  An edge for our `SystemMember`. May be used by Relay 1.
  """
  systemMemberEdge(
    """
    The method to use when ordering `SystemMember`.
    """
    orderBy: [SystemMembersOrderBy!] = [PRIMARY_KEY_ASC]
  ): SystemMembersEdge
}

"""
All input for the `deleteSystemMemberByNodeId` mutation.
"""
input DeleteSystemMemberByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `SystemMember` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteSystemMember` mutation.
"""
input DeleteSystemMemberInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  Primary key
  """
  id: Int!
}

"""
All input for the `deleteSystemMemberBySystemBmiRefAndProductBmiRefAndMarketId` mutation.
"""
input DeleteSystemMemberBySystemBmiRefAndProductBmiRefAndMarketIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  fk
  """
  systemBmiRef: String!

  """
  fk
  """
  productBmiRef: String!

  """
  fk
  """
  marketId: Int!
}

"""
The output of our `createAccount` mutation.
"""
type CreateAccountPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  account: Account

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Market` that is related to this `Account`.
  """
  market: Market

  """
  An edge for our `Account`. May be used by Relay 1.
  """
  accountEdge(
    """
    The method to use when ordering `Account`.
    """
    orderBy: [AccountsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AccountsEdge
}

"""
All input for the `createAccount` mutation.
"""
input CreateAccountInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  account: AccountInput
  marketCode: String
}

"""
An input for mutations affecting `Account`
"""
input AccountInput {
  """
  Primary key
  """
  id: Int

  """
  ek
  """
  status: AccountStatus

  """
  fk
  """
  marketId: Int

  """
  ek
  """
  role: Role

  """
  The email address associated with the account
  """
  email: String!

  """
  A phone number that can optionally be provided, and is useful for Company Admin people to provide
  """
  phone: String

  """
  First name
  """
  firstName: String!

  """
  Last name
  """
  lastName: String!

  """
  When the account was created
  """
  created: Datetime

  """
  User account in Docebo
  """
  doceboUserId: Int

  """
  Username in Docebo.  Needed to generate the SSO link
  """
  doceboUsername: String

  """
  File reference. A profile picture of the user
  """
  photo: String

  """
  Used for reference when importing data from the legacy system
  """
  migrationId: String
  createdAt: Datetime
  updatedAt: Datetime
  marketToMarketId: AccountMarketIdFkeyInput
  certificationsUsingDoceboUserId: CertificationDoceboUserIdFkeyInverseInput
  companyMembersUsingId: CompanyMemberAccountIdFkeyInverseInput
  guaranteesToRequestorAccountIdUsingId: GuaranteeRequestorAccountIdFkeyInverseInput
  guaranteesToReviewerAccountIdUsingId: GuaranteeReviewerAccountIdFkeyInverseInput
  invitationsUsingId: InvitationSenderAccountIdFkeyInverseInput
  notesUsingId: NoteAuthorIdFkeyInverseInput
  notificationsUsingId: NotificationAccountIdFkeyInverseInput
  projectMembersUsingId: ProjectMemberAccountIdFkeyInverseInput
  marketCode: String
}

"""
The output of our `createCompany` mutation.
"""
type CreateCompanyPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  company: Company

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Market` that is related to this `Company`.
  """
  market: Market

  """
  Reads a single `Address` that is related to this `Company`.
  """
  registeredAddress: Address

  """
  Reads a single `Address` that is related to this `Company`.
  """
  tradingAddress: Address

  """
  An edge for our `Company`. May be used by Relay 1.
  """
  companyEdge(
    """
    The method to use when ordering `Company`.
    """
    orderBy: [CompaniesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompaniesEdge
}

"""
All input for the `createCompany` mutation.
"""
input CreateCompanyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  ownerFullname: String
  ownerEmail: String
  ownerPhone: String
  businessType: BusinessType
  tier: Tier
  status: CompanyStatus
  name: String
  taxNumber: String
  phone: String
  aboutUs: String
  publicEmail: String
  website: String
  facebook: String
  linkedIn: String
}

"""
The output of our `evidenceItemsAdd` mutation.
"""
type EvidenceItemsAddPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  evidenceItems: [EvidenceItem!]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `evidenceItemsAdd` mutation.
"""
input EvidenceItemsAddInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  evidences: [EvidenceItemInput]!
}

"""
The output of our `linkAccountToCompany` mutation.
"""
type LinkAccountToCompanyPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  companyMember: CompanyMember

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Market` that is related to this `CompanyMember`.
  """
  market: Market

  """
  Reads a single `Account` that is related to this `CompanyMember`.
  """
  account: Account

  """
  Reads a single `Company` that is related to this `CompanyMember`.
  """
  company: Company

  """
  An edge for our `CompanyMember`. May be used by Relay 1.
  """
  companyMemberEdge(
    """
    The method to use when ordering `CompanyMember`.
    """
    orderBy: [CompanyMembersOrderBy!] = [PRIMARY_KEY_ASC]
  ): CompanyMembersEdge
}

"""
All input for the `linkAccountToCompany` mutation.
"""
input LinkAccountToCompanyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  accountId: Int
  companyId: Int
}

"""
The output of our `projectMembersAdd` mutation.
"""
type ProjectMembersAddPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  projectMembers: [ProjectMember!]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `projectMembersAdd` mutation.
"""
input ProjectMembersAddInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  members: [ProjectMemberInput]!
}

type Publish {
  title: String
  text: String
  html: String
  email: String
}

input PublishInput {
  title: String
  text: String
  html: String
  email: String
}

type PublishOutput {
  messageId: String
}

input InviteInput {
  emails: [String!]!
  firstName: String
  lastName: String
  personalNote: String
}

type ImportOutput {
  systemsToUpdate: [System!]
  systemsToInsert: [System!]
  productsToUpdate: [Product!]
  productsToInsert: [Product!]
  errorSystemsToUpdate: [ImportError!]
  errorSystemsToInsert: [ImportError!]
  errorProductsToUpdate: [ImportError!]
  errorProductsToInsert: [ImportError!]
  errorSystemMembersInsert: [ImportError!]
}

type ImportError {
  ref: String
  message: String
}

input BulkImportInput {
  files: [Upload!]!
  dryRun: Boolean
}

"""
Used to represent a set of fields. Grammatically, a field set is a
selection set minus the braces.
"""
scalar _FieldSet
